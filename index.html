<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI双人对话系统</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
        }

        .container {
            display: flex;
            width: 100%;
            height: 100vh;
            background: white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        /* 左侧配置栏 */
        .config-panel {
            width: 350px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            padding: 20px;
            overflow-y: auto;
        }

        .config-section {
            margin-bottom: 25px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .config-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
            font-size: 13px;
        }

        .form-input, .form-select, .form-textarea {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            transition: border-color 0.3s;
        }

        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: #3498db;
        }

        .form-textarea {
            height: 60px;
            resize: vertical;
        }

        .api-hint {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
            font-style: italic;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #219a52;
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .btn-warning:hover {
            background: #e67e22;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* 右侧对话栏 */
        .chat-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            min-width: 0;
        }

        .chat-header {
            background: #2c3e50;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-title {
            font-size: 18px;
            font-weight: 600;
        }

        .status-indicator {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-ready {
            background: #27ae60;
        }

        .status-running {
            background: #f39c12;
        }

        .status-stopped {
            background: #e74c3c;
        }

        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            background: #f8f9fa;
            min-width: 0;
        }

        .message {
            margin-bottom: 15px;
            padding: 12px 15px;
            border-radius: 8px;
            max-width: 80%;
            overflow: hidden;
            word-wrap: break-word;
            min-width: 0;
        }

        .message-a {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
        }

        .message-b {
            background: #f3e5f5;
            border-left: 4px solid #9c27b0;
            margin-left: auto;
        }

        /* 新增：loading消息样式 */
        .message-loading {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            opacity: 0.8;
        }

        .message-header {
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .message-content {
            line-height: 1.6;
            color: #333;
            max-width: 100%;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        .message-content h1, .message-content h2, .message-content h3 {
            margin-top: 15px;
            margin-bottom: 10px;
        }

        .message-content h1 {
            font-size: 20px;
        }

        .message-content h2 {
            font-size: 18px;
        }

        .message-content h3 {
            font-size: 16px;
        }

        .message-content p {
            margin-bottom: 10px;
        }

        .message-content code {
            background: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            word-break: break-word;
        }

        .message-content pre {
            background: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            overflow-y: hidden;
            margin: 10px 0;
            max-width: 100%;
            white-space: pre;
        }

        .message-content pre code {
            background: transparent;
            padding: 0;
            white-space: pre;
            word-break: normal;
            display: block;
        }

        .chat-input {
            padding: 20px;
            border-top: 1px solid #e9ecef;
            background: white;
        }

        .input-group {
            display: flex;
            gap: 10px;
        }

        .input-field {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        /* 改进的loading动画 */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* 新增：打字机效果的loading */
        .typing-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .typing-dot {
            width: 6px;
            height: 6px;
            background: #999;
            border-radius: 50%;
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: scale(1);
                opacity: 0.5;
            }
            30% {
                transform: scale(1.2);
                opacity: 1;
            }
        }

        .error-message {
            color: #e74c3c;
            font-size: 12px;
            margin-top: 5px;
        }

        .round-counter {
            background: rgba(255,255,255,0.2);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        /* 压缩消息样式 */
        .message-compressed {
            border-left-color: #f39c12 !important;
            background: linear-gradient(90deg, #fff3cd 0%, #f8f9fa 100%) !important;
        }

        .compression-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            margin-left: 8px;
            font-size: 11px;
            color: #f39c12;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 10px;
            background: rgba(243, 156, 18, 0.1);
            border: 1px solid rgba(243, 156, 18, 0.3);
            transition: all 0.2s;
        }

        .compression-indicator:hover {
            background: rgba(243, 156, 18, 0.2);
            transform: scale(1.05);
        }

        .compression-icon {
            font-size: 12px;
        }

        /* 原始内容弹窗 */
        .original-content-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 80%;
            max-height: 80%;
            z-index: 1000;
            display: none;
        }

        .popup-header {
            padding: 15px 20px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f8f9fa;
            border-radius: 8px 8px 0 0;
        }

        .popup-title {
            font-weight: 600;
            color: #2c3e50;
            margin: 0;
        }

        .popup-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #6c757d;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .popup-close:hover {
            background: #e9ecef;
            color: #495057;
        }

        .popup-content {
            padding: 20px;
            overflow-y: auto;
            max-height: 60vh;
        }

        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            display: none;
        }

        .original-message {
            margin-bottom: 15px;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #3498db;
            background: #f8f9fa;
        }

        .original-message-header {
            font-weight: 600;
            margin-bottom: 8px;
            color: #2c3e50;
            font-size: 14px;
        }

        .original-message-content {
            line-height: 1.6;
            color: #333;
        }

        .compression-stats {
            margin-top: 15px;
            padding: 10px;
            background: #e3f2fd;
            border-radius: 4px;
            font-size: 12px;
            color: #1976d2;
        }

        /* 消息操作按钮样式 */
        .message-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .message-action-btn {
            padding: 4px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .message-action-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .message-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-retry {
            background: #f39c12;
            color: white;
        }

        .btn-retry:hover:not(:disabled) {
            background: #e67e22;
        }

        .btn-copy {
            background: #3498db;
            color: white;
        }

        .btn-copy:hover:not(:disabled) {
            background: #2980b9;
        }

        /* Tab导航样式 */
        .config-tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }

        .tab-button {
            flex: 1;
            padding: 10px 15px;
            border: none;
            background: transparent;
            color: #666;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 2px solid transparent;
        }

        .tab-button:hover {
            color: #3498db;
            background: rgba(52, 152, 219, 0.1);
        }

        .tab-button.active {
            color: #3498db;
            border-bottom-color: #3498db;
            background: rgba(52, 152, 219, 0.1);
        }

        /* Tab内容容器 */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* 代理配置项样式 */
        .proxy-item {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            margin-bottom: 15px;
            padding: 15px;
            position: relative;
        }

        .proxy-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #f0f0f0;
        }

        .proxy-item-title {
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
        }

        .proxy-item-actions {
            display: flex;
            gap: 8px;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 3px;
        }

        .proxy-form-row {
            display: flex;
            gap: 10px;
            margin-bottom: 12px;
        }

        .proxy-form-row .form-group {
            flex: 1;
            margin-bottom: 0;
        }


    </style>
</head>
<body>    <div class="container">
        <!-- 左侧配置栏 -->
        <div class="config-panel">
            <!-- Tab切换导航 -->
            <div class="config-tabs">
                <button class="tab-button active" data-tab="ai-config">AI配置</button>
                <button class="tab-button" data-tab="proxy-config">代理配置</button>
            </div>

            <!-- Tab内容容器 -->
            <div class="tab-content" id="ai-config" style="display: block;">
                <!-- 操作按钮 -->
                <div class="config-section">
                    <div class="config-title">操作</div>
                    <button class="btn btn-warning" id="pauseResumeChat">暂停</button>
                    <button class="btn btn-primary" id="exportChat">导出对话</button>
                    <button class="btn btn-danger" id="clearChat">清除对话</button>
                    <button class="btn btn-warning" id="retryChat" style="display:none;">重试</button>
                </div>

                <!-- 配置管理 -->
                <div class="config-section">
                    <div class="config-title">配置管理</div>
                    <button class="btn btn-primary" id="saveConfig">保存配置</button>
                    <button class="btn btn-primary" id="exportConfig">导出</button>
                    <button class="btn btn-success" id="importConfig">导入</button>
                    <input type="file" id="importConfigFile" accept=".json" style="display: none;">
                </div>

                <!-- AI A 配置 -->
                <div class="config-section">
                    <div class="config-title">AI A 配置</div>
                    <div class="form-group">
                        <label class="form-label">选择代理</label>
                        <select class="form-select" id="proxySelectA">
                            <option value="">请选择代理配置</option>
                        </select>
                        <div class="api-hint">从代理配置页面中选择一个已配置的代理</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">提示词</label>
                        <textarea class="form-textarea" id="promptA" placeholder="AI A的系统提示词"></textarea>
                    </div>
                </div>

                <!-- AI B 配置 -->
                <div class="config-section">
                    <div class="config-title">AI B 配置</div>
                    <div class="form-group">
                        <label class="form-label">选择代理</label>
                        <select class="form-select" id="proxySelectB">
                            <option value="">请选择代理配置</option>
                        </select>
                        <div class="api-hint">从代理配置页面中选择一个已配置的代理</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">提示词</label>
                        <textarea class="form-textarea" id="promptB" placeholder="AI B的系统提示词"></textarea>
                    </div>
                </div>

                <!-- 系统AI配置 -->
                <div class="config-section">
                    <div class="config-title">系统AI配置 (用于压缩等功能)</div>
                    <div class="form-group">
                        <label class="form-label">选择代理</label>
                        <select class="form-select" id="proxySelectSystem">
                            <option value="">请选择代理配置</option>
                        </select>
                        <div class="api-hint">从代理配置页面中选择一个已配置的代理</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">提示词</label>
                        <textarea class="form-textarea" id="promptSystem" placeholder="系统AI的压缩提示词"></textarea>
                    </div>
                </div>

            <!-- 对话控制 -->
            <div class="config-section">
                <div class="config-title">对话控制</div>
                <div class="form-group">
                    <label class="form-label">最大轮次 (0=无限制)</label>
                    <input type="number" class="form-input" id="maxRounds" value="0" min="0">
                </div>
                <div class="form-group">
                    <label class="form-label">上下文消息数量 (0=全部)</label>
                    <input type="number" class="form-input" id="contextLimit" value="0" min="0">
                    <div class="api-hint">限制每次API调用时发送的历史消息数量，可以减少Token消耗</div>
                </div>
                <div class="form-group">
                    <label class="form-label">
                        <input type="checkbox" id="enableCompression" style="margin-right: 8px;">
                        启用AI智能上下文压缩
                    </label>
                    <div class="api-hint">使用系统AI自动压缩历史对话以减少Token消耗，保留关键信息</div>
                </div>
                <div class="form-group">
                    <label class="form-label">压缩强度</label>
                    <select class="form-select" id="compressionRatio">
                        <option value="0.3">轻度压缩 (保留70%内容)</option>
                        <option value="0.5" selected>中度压缩 (保留50%内容)</option>
                        <option value="0.7">重度压缩 (保留30%内容)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">不压缩条数</label>
                    <input type="number" class="form-input" id="keepRecentCount" value="5" min="0" max="20">
                    <div class="api-hint">最近的X条消息不参与压缩，保持完整上下文</div>
                </div>
                <div class="form-group">
                    <label class="form-label">重试次数</label>
                    <input type="number" class="form-input" id="retryCount" value="3" min="0">
                </div>
                <div class="form-group">
                    <label class="form-label">重试间隔 (秒)</label>
                    <input type="number" class="form-input" id="retryDelay" value="2" min="1">
                </div>
            </div>

                <!-- 压缩统计 -->
                <div class="config-section" id="compressionStatsSection" style="display:none;">
                    <div class="config-title">压缩统计</div>
                    <div id="compressionStats" style="font-size: 12px; color: #666; line-height: 1.5;">
                        暂无压缩数据
                    </div>
                </div>
            </div>

            <!-- 代理配置Tab内容 -->
            <div class="tab-content" id="proxy-config" style="display: none;">
                <!-- 代理管理操作 -->
                <div class="config-section">
                    <div class="config-title">代理管理</div>
                    <button class="btn btn-primary" id="addProxy">新增代理</button>
                    <button class="btn btn-primary" id="saveProxyConfig">保存代理配置</button>
                </div>

                <!-- 代理列表容器 -->
                <div id="proxyListContainer">
                    <!-- 代理配置项将动态插入这里 -->
                </div>
            </div>
        </div>

        <!-- 右侧对话栏 -->
        <div class="chat-panel">
            <div class="chat-header">
                <div class="chat-title">AI双人对话</div>
                <div style="display: flex; align-items: center; gap: 15px;">
                    <div class="round-counter">轮次: <span id="roundCounter">0</span></div>
                    <div class="status-indicator status-ready" id="statusIndicator">就绪</div>
                </div>
            </div>

            <div class="chat-messages" id="chatMessages">
                <div style="text-align: center; color: #666; margin-top: 50px;">
                    <h3>欢迎使用AI双人对话系统</h3>
                    <p>请先配置AI参数，然后输入开场白开始对话</p>
                </div>
            </div>

            <div class="chat-input">
                <div class="input-group">
                    <input type="text" class="input-field" id="openingMessage" placeholder="输入开场白，由AI A发起对话...">
                    <button class="btn btn-primary" id="sendOpening">发起对话</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        /**
         * 消息对象模型
         */
        class Message {
            constructor({ id, speaker, role, content, status = 'completed', timestamp = Date.now() }) {
                this.id = id || `msg_${timestamp}_${Math.random().toString(36).substr(2, 9)}`;
                this.speaker = speaker;
                this.role = role;
                this.content = content;
                this.status = status; // 'loading', 'streaming', 'completed', 'error'
                this.timestamp = timestamp;
                this.isCompressed = false;
                this.compressedContent = null;
                this.compressionIndex = null;
            }

            // 标记为压缩消息
            markAsCompressed(compressedContent, compressionIndex) {
                this.isCompressed = true;
                this.compressedContent = compressedContent;
                this.compressionIndex = compressionIndex;
            }

            // 更新消息内容
            updateContent(content) {
                this.content = content;
            }

            // 更新消息状态
            updateStatus(status) {
                this.status = status;
            }

            // 获取用于API的内容（压缩后的内容或原始内容）
            getAPIContent() {
                return this.isCompressed ? this.compressedContent : this.content;
            }

            // 转换为旧格式（用于向后兼容）
            toLegacyFormat() {
                return {
                    role: this.role,
                    content: this.content,
                    speaker: this.speaker,
                    isCompressed: this.isCompressed,
                    compressedContent: this.compressedContent,
                    compressionIndex: this.compressionIndex
                };
            }

            // 从旧格式创建消息对象
            static fromLegacyFormat(legacy) {
                const msg = new Message({
                    speaker: legacy.speaker,
                    role: legacy.role,
                    content: legacy.content,
                    status: 'completed'
                });
                if (legacy.isCompressed) {
                    msg.markAsCompressed(legacy.compressedContent, legacy.compressionIndex);
                }
                return msg;
            }
        }

        class AIDialogueSystem {
            constructor() {
                this.conversations = [];
                this.currentRound = 0;
                this.maxRounds = 0;
                this.contextLimit = 0; // 新增：上下文限制
                this.isRunning = false;
                this.isPaused = false;
                this.isPausedManually = false; // 新增：标记是否手动暂停
                this.retryCount = 3;
                this.retryDelay = 2000;
                this.currentRetries = 0;
                this.needsReset = false;
                this.openingMessage = '';
                this.nextSpeaker = 'B';
                // 新增：用于跟踪当前正在流式显示的消息
                this.currentStreamingMessageId = null;
                // 新增：用于跟踪当前是否有AI正在工作（防止并发）
                this.isAIWorking = false;

                // 代理配置相关
                this.proxies = new Map(); // 存储所有代理配置
                this.currentTab = 'ai-config'; // 当前激活的Tab
                
                // 新增：跟踪每个AI当前的端点类型
                this.currentEndpointTypes = {
                    'A': 'openai',
                    'B': 'openai', 
                    'System': 'openai'
                };
                
                // 新增：跟踪全局配置当前的端点类型
                this.currentGlobalEndpointType = 'openai';
                
                // ====== 上下文压缩功能相关属性 ======
                this.enableCompression = false; // 是否启用压缩
                this.compressionRatio = 0.5; // 压缩比率 (0.1-0.9)
                this.keepRecentCount = 5; // 最近X条消息不压缩
                this.compressedMessages = []; // 存储压缩后的消息摘要
                this.compressionCache = new Map(); // 压缩缓存，key为消息内容hash，value为压缩结果
                this.lastCompressionIndex = 0; // 上次压缩到的消息索引
                this.compressionStats = { // 压缩统计信息
                    originalTokens: 0,
                    compressedTokens: 0,
                    compressionCount: 0,
                    aiCompressionTokens: 0 // AI压缩消耗的Token
                };

                this.initializeElements();
                this.loadProxyConfiguration(); // 先加载代理配置
                this.updateProxySelectors(); // 更新代理下拉选择器
                this.loadConfiguration();
                this.setupEventListeners();
                this.updateUI();
                
                // 设置全局引用以便在onclick中访问
                window.aiDialogue = this;
            }

            initializeElements() {
                // 配置元素
                this.elements = {
                    // AI配置（使用代理选择）
                    proxySelectA: document.getElementById('proxySelectA'),
                    promptA: document.getElementById('promptA'),

                    proxySelectB: document.getElementById('proxySelectB'),
                    promptB: document.getElementById('promptB'),

                    proxySelectSystem: document.getElementById('proxySelectSystem'),
                    promptSystem: document.getElementById('promptSystem'),

                    maxRounds: document.getElementById('maxRounds'),
                    contextLimit: document.getElementById('contextLimit'), // 新增
                    enableCompression: document.getElementById('enableCompression'),
                    compressionRatio: document.getElementById('compressionRatio'),
                    keepRecentCount: document.getElementById('keepRecentCount'),
                    retryCount: document.getElementById('retryCount'),
                    retryDelay: document.getElementById('retryDelay'),

                    chatMessages: document.getElementById('chatMessages'),
                    openingMessage: document.getElementById('openingMessage'),
                    statusIndicator: document.getElementById('statusIndicator'),
                    roundCounter: document.getElementById('roundCounter'),

                    saveConfig: document.getElementById('saveConfig'),
                    pauseResumeChat: document.getElementById('pauseResumeChat'),
                    exportChat: document.getElementById('exportChat'),
                    clearChat: document.getElementById('clearChat'),
                    retryChat: document.getElementById('retryChat'),
                    sendOpening: document.getElementById('sendOpening'),

                    // Tab和代理相关元素
                    addProxy: document.getElementById('addProxy'),
                    saveProxyConfig: document.getElementById('saveProxyConfig'),
                    proxyListContainer: document.getElementById('proxyListContainer'),

                    // 配置导入导出
                    exportConfig: document.getElementById('exportConfig'),
                    importConfig: document.getElementById('importConfig'),
                    importConfigFile: document.getElementById('importConfigFile')
                };
            }

            setupEventListeners() {
                // 代理选择器变化事件
                this.elements.proxySelectA.addEventListener('change', () => this.updateProxySelectors());
                this.elements.proxySelectB.addEventListener('change', () => this.updateProxySelectors());
                this.elements.proxySelectSystem.addEventListener('change', () => this.updateProxySelectors());

                // 压缩功能相关事件
                this.elements.enableCompression.addEventListener('change', () => this.updateCompressionStatsUI());

                // 按钮事件
                this.elements.saveConfig.addEventListener('click', () => this.saveConfiguration());
                this.elements.pauseResumeChat.addEventListener('click', () => this.togglePauseResume());
                this.elements.exportChat.addEventListener('click', () => this.exportDialogue());
                this.elements.clearChat.addEventListener('click', () => this.clearDialogue());
                this.elements.retryChat.addEventListener('click', () => this.retryLastRequest());
                this.elements.sendOpening.addEventListener('click', () => this.sendOpeningMessage());

                // Tab切换事件
                document.querySelectorAll('.tab-button').forEach(button => {
                    button.addEventListener('click', (e) => this.switchTab(e.target.dataset.tab));
                });

                // 代理管理事件
                this.elements.addProxy.addEventListener('click', () => this.addNewProxy());
                this.elements.saveProxyConfig.addEventListener('click', () => this.saveProxyConfiguration());

                // 配置导入导出事件
                this.elements.exportConfig.addEventListener('click', () => this.exportConfiguration());
                this.elements.importConfig.addEventListener('click', () => this.elements.importConfigFile.click());
                this.elements.importConfigFile.addEventListener('change', (e) => this.importConfiguration(e));

                // 回车发送
                this.elements.openingMessage.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendOpeningMessage();
                });
            }

            /**
             * 更新代理选择器
             */
            updateProxySelectors() {
                const selectors = [
                    this.elements.proxySelectA,
                    this.elements.proxySelectB,
                    this.elements.proxySelectSystem
                ];

                selectors.forEach(selector => {
                    if (!selector) return;

                    const currentValue = selector.value;

                    // 清空现有选项，保留默认选项
                    selector.innerHTML = '<option value="">请选择代理配置</option>';

                    // 添加代理选项
                    for (const [id, proxy] of this.proxies) {
                        const option = document.createElement('option');
                        option.value = id;
                        option.textContent = `${proxy.name} (${proxy.modelName})`;
                        selector.appendChild(option);
                    }

                    // 恢复之前选择的值
                    if (currentValue) {
                        selector.value = currentValue;
                    }
                });
            }



            loadConfiguration() {
                const saved = localStorage.getItem('aiDialogueConfig');
                if (saved) {
                    const config = JSON.parse(saved);
                    Object.keys(config).forEach(key => {
                        if (this.elements[key]) {
                            if (this.elements[key].type === 'checkbox') {
                                this.elements[key].checked = config[key];
                            } else {
                                this.elements[key].value = config[key];
                            }
                        }
                    });

                    // 恢复AI选择的代理
                    if (config.selectedProxyA && this.proxies.has(config.selectedProxyA)) {
                        this.elements.proxySelectA.value = config.selectedProxyA;
                    }
                    if (config.selectedProxyB && this.proxies.has(config.selectedProxyB)) {
                        this.elements.proxySelectB.value = config.selectedProxyB;
                    }
                    if (config.selectedProxySystem && this.proxies.has(config.selectedProxySystem)) {
                        this.elements.proxySelectSystem.value = config.selectedProxySystem;
                    }

                    // 确保系统AI提示词有默认值（如果为空的话）
                    if (!this.elements.promptSystem.value.trim()) {
                        this.elements.promptSystem.value = this.getDefaultCompressionPromptTemplate();
                    }
                } else {
                    // 设置默认的系统AI提示词
                    this.elements.promptSystem.value = this.getDefaultCompressionPromptTemplate();
                }

                // 更新压缩统计UI
                this.updateCompressionStatsUI();
            }

            saveConfiguration() {
                // 保存AI配置
                const config = {};
                Object.keys(this.elements).forEach(key => {
                    if (this.elements[key]) {
                        if (this.elements[key].type === 'checkbox') {
                            config[key] = this.elements[key].checked;
                        } else if (this.elements[key].value !== undefined) {
                            config[key] = this.elements[key].value;
                        }
                    }
                });

                // 额外保存AI选择的代理ID
                config.selectedProxyA = this.elements.proxySelectA.value;
                config.selectedProxyB = this.elements.proxySelectB.value;
                config.selectedProxySystem = this.elements.proxySelectSystem.value;

                localStorage.setItem('aiDialogueConfig', JSON.stringify(config));
                this.showMessage('AI配置已保存', 'success');
            }

            /**
             * 添加或更新消息到UI，支持流式更新和压缩消息显示
             * @param {string} speaker - 发言者
             * @param {string} content - 消息内容
             * @param {boolean} isStreaming - 是否为流式更新
             * @param {string|null} messageId - 消息ID，用于更新现有消息
             * @param {Object|null} messageData - 完整的消息数据（包含压缩信息）
             */
            addMessageToUI(speaker, content, isStreaming = false, messageId = null, messageData = null) {
                const messagesContainer = this.elements.chatMessages;

                if (messageId) {
                    // 更新现有消息
                    const existingMessage = document.getElementById(messageId);
                    if (existingMessage) {
                        const contentElement = existingMessage.querySelector('.message-content');
                        if (contentElement) {
                            // 对于流式更新，直接设置文本，避免重复解析Markdown
                            if (isStreaming) {
                                contentElement.textContent = content;
                            } else {
                                // 最终完成时解析Markdown
                                contentElement.innerHTML = marked.parse(content);
                            }
                        }
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        return messageId;
                    }
                }

                // 创建新消息
                const newMessageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                const messageDiv = document.createElement('div');

                const isAIB = speaker === 'AI B';
                messageDiv.className = `message ${isAIB ? 'message-b' : 'message-a'}`;
                messageDiv.id = newMessageId;

                // 如果是loading状态，使用特殊样式
                if (content === '[思考中...]' || content.includes('正在')) {
                    messageDiv.classList.add('message-loading');
                }

                // 检查是否应该跳过显示（如果这条消息已经被压缩到摘要中）
                if (this.shouldSkipMessage(speaker, content)) {
                    // 不显示这条消息，因为它已经被包含在压缩摘要中
                    return null;
                }

                // 检查消息是否被压缩（从conversations数组中查找）
                const isCompressedMessage = messageData && messageData.isCompressed && messageData.compressedContent;
                
                // 构建消息头部（包含压缩指示器）
                let headerHTML = `<div class="message-header">${speaker}`;
                if (isCompressedMessage) {
                    // 为压缩消息添加压缩图标（但消息内容仍显示完整版本）
                    const originalLength = this.estimateTokens(messageData.content);
                    const compressedLength = this.estimateTokens(messageData.compressedContent);
                    const ratio = originalLength > 0 ? 
                        Math.round(((originalLength - compressedLength) / originalLength) * 100) : 0;
                    
                    headerHTML += `<span class="compression-indicator" onclick="window.aiDialogue.showCompressedContent('${newMessageId}')" title="点击查看压缩后的内容">
                        <span class="compression-icon">🗜️</span>
                        <span>已压缩 ${ratio}%</span>
                    </span>`;
                }
                headerHTML += `</div>`;

                // 构建消息内容
                const contentHTML = `<div class="message-content">${isStreaming ? content : marked.parse(content)}</div>`;
                
                // 构建消息操作按钮（仅对AI消息显示）
                let actionsHTML = '';
                if (speaker.startsWith('AI')) {
                    actionsHTML = `
                        <div class="message-actions" style="display: none;">
                            <button class="message-action-btn btn-retry" onclick="window.aiDialogue.retryMessage('${newMessageId}')" title="重试此消息">
                                🔄 重试
                            </button>
                            <button class="message-action-btn btn-copy" onclick="window.aiDialogue.copyMessage('${newMessageId}')" title="复制消息内容">
                                📋 复制
                            </button>
                        </div>
                    `;
                }
                
                messageDiv.innerHTML = headerHTML + contentHTML + actionsHTML;

                // 如果是压缩消息，存储压缩相关数据
                if (isCompressedMessage && messageData.compressedContent) {
                    const originalLength = this.estimateTokens(messageData.content);
                    const compressedLength = this.estimateTokens(messageData.compressedContent);
                    
                    messageDiv.setAttribute('data-compressed-content', messageData.compressedContent);
                    messageDiv.setAttribute('data-compression-stats', JSON.stringify({
                        originalLength: originalLength,
                        compressedLength: compressedLength,
                        savedLength: originalLength - compressedLength,
                        ratio: `${Math.round(((originalLength - compressedLength) / originalLength) * 100)}%`,
                        compressionIndex: messageData.compressionIndex
                    }));
                }

                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;

                return newMessageId;
            }

            /**
             * 添加loading占位消息
             * @param {string} speaker - 发言者
             * @return {string} 消息ID
             */
            addLoadingMessage(speaker) {
                const loadingContent = `
                    <div class="typing-indicator">
                        正在思考中
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                `;

                const messageId = this.addMessageToUI(speaker, '', true);

                // 直接设置loading内容到content区域
                const messageElement = document.getElementById(messageId);
                if (messageElement) {
                    const contentElement = messageElement.querySelector('.message-content');
                    if (contentElement) {
                        contentElement.innerHTML = loadingContent;
                    }
                }

                return messageId;
            }

            togglePauseResume() {
                if (this.isPaused) {
                    // 当前是暂停状态，点击继续
                    this.resumeDialogue();
                } else if (this.isRunning) {
                    // 当前是运行状态，点击暂停
                    this.pauseDialogue();
                }
            }

            pauseDialogue() {
                this.isPaused = true;
                this.isPausedManually = true; // 标记为手动暂停
                this.updateUI();
                this.addSystemMessage('⏸️ 对话已手动暂停', 'info');
            }

            resumeDialogue() {
                // 检查是否有AI正在工作
                if (this.isAIWorking) {
                    this.showMessage('请等待当前AI完成工作后再继续', 'error');
                    return;
                }
                
                const wasManuallyPaused = this.isPausedManually;
                
                this.isPaused = false;
                this.isPausedManually = false; // 清除手动暂停标记
                
                // 如果达到最大会话数，开启新一轮
                if (this.needsReset) {
                    this.currentRound = 0;
                    this.needsReset = false;
                    this.addSystemMessage('🔄 开启新一轮对话', 'success');
                } else {
                    this.addSystemMessage('▶️ 继续对话', 'success');
                }

                // 重新读取最新的配置
                this.maxRounds = parseInt(this.elements.maxRounds.value) || 0;
                this.contextLimit = parseInt(this.elements.contextLimit.value) || 0;
                this.enableCompression = this.elements.enableCompression.checked;
                this.compressionRatio = parseFloat(this.elements.compressionRatio.value) || 0.5;
                this.keepRecentCount = parseInt(this.elements.keepRecentCount.value) || 5;
                this.retryCount = parseInt(this.elements.retryCount.value);
                if (isNaN(this.retryCount) || this.retryCount < 0) this.retryCount = 0;
                this.retryDelay = parseInt(this.elements.retryDelay.value) * 1000 || 2000;

                // 无论是自动暂停还是手动暂停，都不修改nextSpeaker
                // 因为nextSpeaker始终指向下一个应该发言的AI
                // 如果是自动暂停(失败导致)，nextSpeaker指向失败的AI，应该让它重试
                // 如果是手动暂停，nextSpeaker指向下一个应该发言的AI，保持不变
                
                this.updateUI();
                this.runDialogue();
            }

            updateNextSpeaker() {
                if (this.conversations.length === 0) {
                    this.nextSpeaker = 'B';
                    return;
                }

                const lastSpeaker = this.conversations[this.conversations.length - 1].speaker;

                if (lastSpeaker === 'AI A') {
                    this.nextSpeaker = 'B';
                } else {
                    this.nextSpeaker = 'A';
                }
            }

            async sendOpeningMessage() {
                const message = this.elements.openingMessage.value.trim();
                if (!message) {
                    this.showMessage('请输入开场白', 'error');
                    return;
                }

                if (!this.validateConfiguration()) return;

                // 清空之前的对话
                this.conversations = [];
                this.currentRound = 0;
                this.openingMessage = message;
                this.nextSpeaker = 'B';
                this.currentStreamingMessageId = null;

                this.elements.chatMessages.innerHTML = '';
                this.elements.openingMessage.value = '';

                // AI A 本地发出开场白（不调用API）
                const openingMsg = new Message({
                    speaker: 'AI A',
                    role: 'assistant',
                    content: message,
                    status: 'completed'
                });
                this.addMessageToUI('AI A', message);
                this.conversations.push(openingMsg);

                // 设置对话参数
                this.maxRounds = parseInt(this.elements.maxRounds.value) || 0;
                this.contextLimit = parseInt(this.elements.contextLimit.value) || 0; // 新增
                this.enableCompression = this.elements.enableCompression.checked;
                this.compressionRatio = parseFloat(this.elements.compressionRatio.value) || 0.5;
                this.keepRecentCount = parseInt(this.elements.keepRecentCount.value) || 5;
                this.retryCount = parseInt(this.elements.retryCount.value);
                if (isNaN(this.retryCount) || this.retryCount < 0) this.retryCount = 0;
                this.retryDelay = parseInt(this.elements.retryDelay.value) * 1000 || 2000;

                // 直接开始对话，AI B 响应
                this.isRunning = true;
                this.isPaused = false;
                this.isPausedManually = false;
                this.needsReset = false;
                this.updateUI();

                await this.runDialogue();
            }

            async runDialogue() {
                while (this.isRunning && !this.isPaused) {
                    if (this.maxRounds > 0 && this.currentRound >= this.maxRounds) {
                        this.isPaused = true;
                        this.needsReset = true;
                        this.updateUI();
                        break;
                    }

                    const currentAI = this.nextSpeaker;
                    const success = await this.callAI(currentAI);

                    if (!success) {
                        this.isPaused = true;
                        this.updateUI();
                        break;
                    }

                    this.currentRound++;
                    this.updateRoundCounter();

                    // 切换下一个发言者
                    this.nextSpeaker = this.nextSpeaker === 'A' ? 'B' : 'A';

                    // 添加延迟避免过快请求
                    await this.sleep(1000);
                }
                
                // 对话结束后，更新所有消息的压缩图标显示
                this.updateAllCompressionIcons();
            }

            /**
             * 更新所有消息的压缩图标显示
             */
            updateAllCompressionIcons() {
                console.log('🔄 开始更新所有压缩图标...');
                let compressedCount = 0;
                
                this.conversations.forEach((conv, index) => {
                    if (conv.isCompressed && conv.compressedContent) {
                        compressedCount++;
                        console.log(`📝 发现压缩消息 ${index}: ${conv.speaker}`);
                        setTimeout(() => {
                            this.updateMessageCompressionIcon(index);
                        }, index * 50); // 错开执行时间
                    }
                });
                
                console.log(`📊 总共找到 ${compressedCount} 条压缩消息`);
            }
            // ====== 修复后的API调用方法 ======

            async callAI(aiType) {
                // 设置AI工作标志
                this.isAIWorking = true;
                this.updateUI();
                
                const config = this.getAIConfig(aiType);
                const messages = await this.buildMessages(aiType);

                this.currentRetries = 0;

                // 添加loading消息
                const loadingMessageId = this.addLoadingMessage(`AI ${aiType}`);
                this.currentStreamingMessageId = loadingMessageId;

                while (this.currentRetries <= this.retryCount) {
                    try {
                        this.setStatus('运行中', 'running');
                        const response = await this.makeAPIRequest(config, messages, `AI ${aiType}`, loadingMessageId);

                        if (response && response.content) {
                            // 流式响应在makeAPIRequest中已经实时更新了UI
                            // 创建新的消息对象并添加到对话历史中
                            const newMessage = new Message({
                                speaker: `AI ${aiType}`,
                                role: 'assistant',
                                content: response.content,
                                status: 'completed'
                            });
                            this.conversations.push(newMessage);

                            // 在新消息添加后，检查并更新压缩图标
                            setTimeout(() => {
                                console.log('🆕 新消息添加完成，更新压缩图标');
                                this.updateAllCompressionIcons();
                            }, 500);

                            this.setStatus('就绪', 'ready');
                            this.currentStreamingMessageId = null;
                            // 清除AI工作标志
                            this.isAIWorking = false;
                            this.updateUI();
                            return true;
                        }

                        throw new Error('响应内容为空');

                    } catch (error) {
                        console.error(`AI ${aiType} 调用失败:`, error);
                        this.currentRetries++;

                        if (this.currentRetries <= this.retryCount) {
                            // 更新loading消息显示重试信息
                            this.addMessageToUI(`AI ${aiType}`, `调用失败，${this.retryDelay/1000}秒后重试 (${this.currentRetries}/${this.retryCount})`, true, loadingMessageId);
                            this.showMessage(`AI ${aiType} 调用失败，${this.retryDelay/1000}秒后重试 (${this.currentRetries}/${this.retryCount})`, 'error');
                            await this.sleep(this.retryDelay);
                        } else {
                            // 重试次数用完，显示错误消息，并自动进入暂停状态
                            this.addMessageToUI(`AI ${aiType}`, `❌ 调用失败，已达重试上限: ${error.message}`, false, loadingMessageId);
                            this.showMessage(`AI ${aiType} 调用失败，已达重试上限，系统已自动暂停`, 'error');
                            this.setStatus('暂停', 'stopped');
                            this.currentStreamingMessageId = null;
                            
                            // 自动进入暂停状态（非手动暂停）
                            this.isPaused = true;
                            this.isPausedManually = false;
                            // 清除AI工作标志
                            this.isAIWorking = false;
                            this.updateUI();
                            
                            return false;
                        }
                    }
                }

                // 清除AI工作标志
                this.isAIWorking = false;
                this.updateUI();
                return false;
            }

            async makeAPIRequest(config, messages, speaker, messageId) {
                if (config.endpointType === 'openai') {
                    return await this.callOpenAI(config, messages, speaker, messageId);
                } else if (config.endpointType === 'gemini') {
                    return await this.callGemini(config, messages, speaker, messageId);
                }
            }

            async callOpenAI(config, messages, speaker, messageId) {
                // 修复：如果URL以#结尾，强制使用输入地址；否则自动补全
                let url;
                if (config.apiUrl.endsWith('#')) {
                    url = config.apiUrl.slice(0, -1); // 去掉末尾的#
                } else if (config.apiUrl.endsWith('/v1/chat/completions')) {
                    url = config.apiUrl;
                } else {
                    url = `${config.apiUrl}/v1/chat/completions`;
                }

                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apiKey}`
                    },
                    body: JSON.stringify({
                        model: config.model,
                        messages: messages,
                        stream: true,
                        temperature: 0.7
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                return await this.handleOpenAIStreamResponse(response, speaker, messageId);
            }

            async callGemini(config, messages, speaker, messageId) {
                const url = `${config.apiUrl}/v1beta/models/${config.model}:streamGenerateContent?alt=sse&key=${config.apiKey}`;

                // 转换消息格式为Gemini格式
                const contents = messages.filter(m => m.role !== 'system').map(m => ({
                    role: m.role === 'assistant' ? 'model' : 'user',
                    parts: [{ text: m.content }]
                }));

                const systemInstruction = messages.find(m => m.role === 'system');
                const requestBody = {
                    contents: contents,
                    generationConfig: {
                        temperature: 0.7
                    }
                };

                if (systemInstruction) {
                    requestBody.systemInstruction = {
                        parts: [{ text: systemInstruction.content }]
                    };
                }

                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorText}`);
                }

                return await this.handleGeminiStreamResponse(response, speaker, messageId);
            }

            // 修复后的OpenAI流式响应处理
            async handleOpenAIStreamResponse(response, speaker, messageId) {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let content = '';
                let isFirstChunk = true;

                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6).trim();
                                if (data === '[DONE]') continue;
                                if (!data) continue;

                                try {
                                    const parsed = JSON.parse(data);
                                    const delta = parsed.choices?.[0]?.delta?.content;
                                    if (delta) {
                                        content += delta;

                                        // 实时更新UI - 第一次更新时清除loading状态
                                        if (isFirstChunk) {
                                            // 移除loading样式
                                            const messageElement = document.getElementById(messageId);
                                            if (messageElement) {
                                                messageElement.classList.remove('message-loading');
                                            }
                                            isFirstChunk = false;
                                        }

                                        // 实时更新消息内容
                                        this.addMessageToUI(speaker, content, true, messageId);
                                    }
                                } catch (e) {
                                    console.warn('解析OpenAI流式响应失败:', e, 'data:', data);
                                }
                            }
                        }
                    }
                } finally {
                    reader.releaseLock();
                }

                // 最终处理Markdown
                if (content) {
                    this.addMessageToUI(speaker, content, false, messageId);
                }

                return { content: content.trim() };
            }

            // 修复后的Gemini流式响应处理 - 这是关键修复
            async handleGeminiStreamResponse(response, speaker, messageId) {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let content = '';
                let buffer = '';
                let isFirstChunk = true;

                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value, { stream: true });
                        buffer += chunk;

                        // 按行分割处理
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || ''; // 保留最后一个可能不完整的行

                        for (const line of lines) {
                            if (line.trim() === '') continue;

                            // Gemini的流式响应格式通常是直接的JSON，不需要data:前缀
                            try {
                                let jsonStr = line.trim();

                                // 如果行以data:开头，去掉这个前缀
                                if (jsonStr.startsWith('data: ')) {
                                    jsonStr = jsonStr.substring(6);
                                }

                                if (!jsonStr || jsonStr === '[DONE]') continue;

                                const parsed = JSON.parse(jsonStr);

                                // Gemini API的标准响应结构
                                const text = parsed.candidates?.[0]?.content?.parts?.[0]?.text;

                                if (text) {
                                    content += text;

                                    // 实时更新UI - 第一次更新时清除loading状态
                                    if (isFirstChunk) {
                                        const messageElement = document.getElementById(messageId);
                                        if (messageElement) {
                                            messageElement.classList.remove('message-loading');
                                        }
                                        isFirstChunk = false;
                                    }

                                    // 实时更新消息内容
                                    this.addMessageToUI(speaker, content, true, messageId);
                                }
                            } catch (e) {
                                // 忽略JSON解析错误，继续处理下一行
                                console.warn('解析Gemini流式响应失败:', e, 'line:', line);
                            }
                        }
                    }

                    // 处理buffer中剩余的内容
                    if (buffer.trim()) {
                        try {
                            let jsonStr = buffer.trim();
                            if (jsonStr.startsWith('data: ')) {
                                jsonStr = jsonStr.substring(6);
                            }

                            if (jsonStr && jsonStr !== '[DONE]') {
                                const parsed = JSON.parse(jsonStr);
                                const text = parsed.candidates?.[0]?.content?.parts?.[0]?.text;
                                if (text) {
                                    content += text;
                                    this.addMessageToUI(speaker, content, true, messageId);
                                }
                            }
                        } catch (e) {
                            console.warn('解析Gemini流式响应剩余内容失败:', e);
                        }
                    }

                } finally {
                    reader.releaseLock();
                }

                // 最终处理Markdown
                if (content) {
                    this.addMessageToUI(speaker, content, false, messageId);
                } else {
                    // 如果没有收到任何内容，显示错误信息
                    this.addMessageToUI(speaker, '❌ 未收到响应内容', false, messageId);
                    throw new Error('Gemini API未返回任何内容');
                }

                return { content: content.trim() };
            }
            // ====== 辅助方法和事件处理 ======

            getAIConfig(aiType) {
                // 获取选择的代理ID
                const proxyId = this.elements[`proxySelect${aiType}`].value;

                if (!proxyId) {
                    throw new Error(`AI ${aiType} 未选择代理配置`);
                }

                // 从代理配置中获取信息
                const proxy = this.proxies.get(proxyId);
                if (!proxy) {
                    throw new Error(`AI ${aiType} 选择的代理配置不存在`);
                }

                return {
                    endpointType: proxy.endpoint,
                    apiUrl: proxy.apiUrl,
                    apiKey: proxy.apiKey,
                    model: proxy.modelName,
                    prompt: this.elements[`prompt${aiType}`].value
                };
            }

            /**
             * 构建API请求的消息数组，支持上下文限制
             * @param {string} aiType - AI类型 ('A' 或 'B')
             * @param {boolean} skipCompression - 是否跳过压缩（重试时使用）
             * @returns {Array} 消息数组
             */
            async buildMessages(aiType, skipCompression = false) {
                const config = this.getAIConfig(aiType);
                const messages = [];

                // 添加系统提示词
                if (config.prompt) {
                    messages.push({
                        role: 'system',
                        content: config.prompt
                    });
                }

                // 获取需要发送的对话历史
                let conversationsToSend = this.conversations;

                // 首先应用智能压缩（如果启用且未跳过）
                if (!skipCompression && this.enableCompression && conversationsToSend.length > this.keepRecentCount) {
                    conversationsToSend = await this.compressConversations([...conversationsToSend]);
                }

                // 然后应用上下文限制
                if (this.contextLimit > 0 && conversationsToSend.length > this.contextLimit) {
                    // 取最近的 contextLimit 条消息
                    conversationsToSend = conversationsToSend.slice(-this.contextLimit);
                    
                    // 在UI中显示上下文截断信息（仅在第一次截断时）
                    if (this.conversations.length === this.contextLimit + 1) {
                        this.addSystemMessage(`📋 启用上下文限制：仅使用最近 ${this.contextLimit} 条消息`, 'info');
                    }
                }

                // 构建交替的用户/助手对话
                // 从当前AI的角度看，对方都是user，自己是assistant
                for (let i = 0; i < conversationsToSend.length; i++) {
                    const conv = conversationsToSend[i];
                    const speakerType = conv.speaker === `AI ${aiType}` ? 'assistant' : 'user';

                    messages.push({
                        role: speakerType,
                        content: conv.content
                    });
                }

                // 在控制台输出debug信息
                console.log(`AI ${aiType} 发送消息数量: ${messages.length}`, {
                    系统消息: messages.filter(m => m.role === 'system').length,
                    对话消息: messages.filter(m => m.role !== 'system').length,
                    总对话条数: this.conversations.length,
                    发送对话条数: conversationsToSend.length,
                    上下文限制: this.contextLimit || '无限制',
                    AI智能压缩: this.enableCompression ? '已启用' : '未启用',
                    跳过压缩: skipCompression ? '是' : '否',
                    保护最近消息: this.keepRecentCount,
                    压缩统计: this.compressionStats
                });

                return messages;
            }

            validateConfiguration() {
                // 验证AI A配置
                if (!this.validateAIConfig('A')) {
                    return false;
                }
                
                // 验证AI B配置
                if (!this.validateAIConfig('B')) {
                    return false;
                }

                // 如果启用AI压缩，验证系统AI配置
                if (this.enableCompression) {
                    if (!this.validateAIConfig('System')) {
                        return false;
                    }
                }

                return true;
            }

            /**
             * 验证单个AI的配置
             * @param {string} aiType - AI类型
             * @returns {boolean} 配置是否有效
             */
            validateAIConfig(aiType) {
                // 检查是否选择了代理
                const proxyId = this.elements[`proxySelect${aiType}`].value;
                if (!proxyId) {
                    this.showMessage(`AI ${aiType} 未选择代理配置`, 'error');
                    return false;
                }

                // 检查代理是否存在
                const proxy = this.proxies.get(proxyId);
                if (!proxy) {
                    this.showMessage(`AI ${aiType} 选择的代理配置不存在`, 'error');
                    return false;
                }

                // 检查代理配置是否完整
                if (!proxy.apiUrl.trim()) {
                    this.showMessage(`代理"${proxy.name}"的API地址未填写`, 'error');
                    return false;
                }
                if (!proxy.apiKey.trim()) {
                    this.showMessage(`代理"${proxy.name}"的API密钥未填写`, 'error');
                    return false;
                }
                if (!proxy.modelName.trim()) {
                    this.showMessage(`代理"${proxy.name}"的模型名称未填写`, 'error');
                    return false;
                }

                return true;
            }

            setStatus(text, type) {
                this.elements.statusIndicator.textContent = text;
                this.elements.statusIndicator.className = `status-indicator status-${type}`;
            }

            updateRoundCounter() {
                this.elements.roundCounter.textContent = this.currentRound;
            }

            updateUI() {
                const isRunning = this.isRunning && !this.isPaused;
                const isStopped = !this.isRunning;
                const isPaused = this.isPaused;

                // 显示/隐藏按钮
                this.elements.pauseResumeChat.style.display = (isRunning || isPaused) ? 'inline-block' : 'none';
                this.elements.retryChat.style.display = 'none'; // 隐藏全局重试按钮，使用每条消息的重试按钮

                // 更新暂停/继续按钮的文字和样式
                if (isPaused) {
                    this.elements.pauseResumeChat.textContent = '继续';
                    this.elements.pauseResumeChat.className = 'btn btn-success';
                    // 如果AI正在工作，禁用继续按钮
                    this.elements.pauseResumeChat.disabled = this.isAIWorking;
                } else if (isRunning) {
                    this.elements.pauseResumeChat.textContent = '暂停';
                    this.elements.pauseResumeChat.className = 'btn btn-warning';
                    this.elements.pauseResumeChat.disabled = false;
                }

                // 更新状态指示器
                if (isRunning) {
                    this.setStatus('运行中', 'running');
                } else if (isPaused) {
                    this.setStatus('暂停', 'stopped');
                } else {
                    this.setStatus('就绪', 'ready');
                }

                // 更新所有消息的操作按钮显示/隐藏
                this.updateMessageActions(isPaused);
            }

            /**
             * 更新所有消息的操作按钮显示状态
             * @param {boolean} show - 是否显示操作按钮
             */
            updateMessageActions(show) {
                const messageActions = document.querySelectorAll('.message-actions');
                messageActions.forEach(actions => {
                    actions.style.display = show ? 'flex' : 'none';
                });
            }

            /**
             * 重试指定消息
             * @param {string} messageId - 消息DOM元素的ID
             */
            async retryMessage(messageId) {
                if (!this.isPaused) {
                    this.showMessage('只有在暂停状态才能重试', 'error');
                    return;
                }

                if (this.isAIWorking) {
                    this.showMessage('请等待当前AI完成工作后再重试', 'error');
                    return;
                }

                // 查找消息在conversations数组中的索引
                const messageElement = document.getElementById(messageId);
                if (!messageElement) {
                    this.showMessage('未找到消息元素', 'error');
                    return;
                }

                // 获取消息索引（通过计算DOM位置）
                const allMessages = Array.from(this.elements.chatMessages.querySelectorAll('.message'));
                const messageIndex = allMessages.indexOf(messageElement);
                
                if (messageIndex < 0 || messageIndex >= this.conversations.length) {
                    this.showMessage('无法确定消息位置', 'error');
                    return;
                }

                // 获取要重试的消息
                const messageToRetry = this.conversations[messageIndex];
                if (!messageToRetry || !messageToRetry.speaker.startsWith('AI')) {
                    this.showMessage('只能重试AI消息', 'error');
                    return;
                }

                // 确定AI类型
                const aiType = messageToRetry.speaker === 'AI A' ? 'A' : 'B';

                this.addSystemMessage(`🔄 重试 ${messageToRetry.speaker} 的消息...`, 'info');

                // 临时移除该消息及之后的所有消息
                const messagesAfter = this.conversations.splice(messageIndex);
                
                // 执行重试
                this.isAIWorking = true;
                this.updateUI();

                try {
                    const config = this.getAIConfig(aiType);
                    const messages = await this.buildMessages(aiType, true);

                    // 创建新的loading消息
                    const loadingMessageId = this.addLoadingMessage(`AI ${aiType}`);
                    this.currentStreamingMessageId = loadingMessageId;

                    this.setStatus('重试中', 'running');
                    const response = await this.makeAPIRequest(config, messages, `AI ${aiType}`, loadingMessageId);

                    if (response && response.content) {
                        // 创建新的消息对象
                        const newMessage = new Message({
                            speaker: `AI ${aiType}`,
                            role: 'assistant',
                            content: response.content,
                            status: 'completed'
                        });

                        // 添加到conversations数组
                        this.conversations.push(newMessage);

                        // 移除旧的DOM元素
                        messageElement.remove();

                        this.currentStreamingMessageId = null;
                        this.isAIWorking = false;
                        this.addSystemMessage('✅ 重试成功', 'success');
                        this.setStatus('暂停', 'stopped');
                        this.updateUI();
                    } else {
                        throw new Error('响应内容为空');
                    }
                } catch (error) {
                    console.error(`重试失败:`, error);
                    
                    // 恢复原消息
                    this.conversations.push(...messagesAfter);
                    
                    this.showMessage(`重试失败: ${error.message}`, 'error');
                    this.setStatus('暂停', 'stopped');
                    this.currentStreamingMessageId = null;
                    this.isAIWorking = false;
                    this.updateUI();
                }
            }

            /**
             * 复制消息内容到剪贴板
             * @param {string} messageId - 消息DOM元素的ID
             */
            async copyMessage(messageId) {
                const messageElement = document.getElementById(messageId);
                if (!messageElement) {
                    this.showMessage('未找到消息元素', 'error');
                    return;
                }

                const contentElement = messageElement.querySelector('.message-content');
                if (!contentElement) {
                    this.showMessage('未找到消息内容', 'error');
                    return;
                }

                // 获取纯文本内容
                const textContent = contentElement.textContent || contentElement.innerText;

                try {
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        await navigator.clipboard.writeText(textContent);
                        this.showMessage('已复制到剪贴板', 'success');
                    } else {
                        // 降级方案：使用传统的复制方法
                        const textarea = document.createElement('textarea');
                        textarea.value = textContent;
                        textarea.style.position = 'fixed';
                        textarea.style.opacity = '0';
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                        this.showMessage('已复制到剪贴板', 'success');
                    }
                } catch (error) {
                    console.error('复制失败:', error);
                    this.showMessage('复制失败', 'error');
                }
            }

            async retryLastRequest() {
                if (!this.isPaused) {
                    this.showMessage('只有在暂停状态才能重试', 'error');
                    return;
                }

                // 检查是否有AI正在工作
                if (this.isAIWorking) {
                    this.showMessage('请等待当前AI完成工作后再重试', 'error');
                    return;
                }

                const wasManuallyPaused = this.isPausedManually;

                // 检查是否有上一条消息
                if (this.conversations.length === 0) {
                    this.showMessage('没有可重试的消息', 'error');
                    return;
                }

                // 确定要重试的AI - 应该使用nextSpeaker（它指向了应该发言的AI）
                const aiToRetry = this.nextSpeaker;

                // 移除最后一条失败的消息（如果有）
                const lastConv = this.conversations[this.conversations.length - 1];

                // 如果最后一条消息是错误消息，删除它
                if (lastConv.content.includes('❌')) {
                    this.conversations.pop();
                    // 同时从UI中删除这条消息
                    const messagesContainer = this.elements.chatMessages;
                    const lastMessageElement = messagesContainer.lastElementChild;
                    if (lastMessageElement && lastMessageElement.classList.contains('message')) {
                        lastMessageElement.remove();
                    }
                }

                this.addSystemMessage(`🔄 重试AI ${aiToRetry}的消息...`, 'info');

                // 执行重试（仅一次，不使用自动重试机制）
                const loadingMessageId = this.addLoadingMessage(`AI ${aiToRetry}`);
                this.currentStreamingMessageId = loadingMessageId;
                this.isAIWorking = true;
                this.updateUI();

                try {
                    const config = this.getAIConfig(aiToRetry);
                    // 重试时跳过压缩，因为第一次调用已经触发过压缩了
                    const messages = await this.buildMessages(aiToRetry, true);

                    this.setStatus('重试中', 'running');
                    const response = await this.makeAPIRequest(config, messages, `AI ${aiToRetry}`, loadingMessageId);

                    if (response && response.content) {
                        // 重试成功 - 创建新的消息对象
                        const newMessage = new Message({
                            speaker: `AI ${aiToRetry}`,
                            role: 'assistant',
                            content: response.content,
                            status: 'completed'
                        });
                        this.conversations.push(newMessage);

                        this.currentStreamingMessageId = null;
                        this.isAIWorking = false;
                        this.addSystemMessage('✅ 重试成功', 'success');

                        // 根据暂停类型决定后续操作
                        if (wasManuallyPaused) {
                            // 手动暂停：保持暂停状态
                            this.setStatus('暂停', 'stopped');
                            this.updateUI();
                            this.addSystemMessage('⏸️ 保持暂停状态，请手动点击继续按钮', 'info');
                        } else {
                            // 自动暂停：自动继续对话
                            this.addSystemMessage('▶️ 自动继续对话', 'success');
                            this.isPaused = false;
                            this.isPausedManually = false;
                            this.updateUI();

                            // 重试成功后，切换到对方AI继续发言
                            // 例如：AIB重试成功后，nextSpeaker从B切换到A
                            this.nextSpeaker = this.nextSpeaker === 'A' ? 'B' : 'A';
                            this.currentRound++;
                            this.updateRoundCounter();
                            await this.sleep(1000);
                            this.runDialogue();
                        }
                    } else {
                        throw new Error('响应内容为空');
                    }
                } catch (error) {
                    // 重试失败
                    console.error(`重试失败:`, error);
                    this.addMessageToUI(`AI ${aiToRetry}`, `❌ 重试失败: ${error.message}`, false, loadingMessageId);
                    this.showMessage(`重试失败: ${error.message}`, 'error');
                    this.setStatus('暂停', 'stopped');
                    this.currentStreamingMessageId = null;
                    this.isAIWorking = false;
                    this.updateUI();
                    // 保持暂停状态
                }
            }

            exportDialogue() {
                let exportText = '# AI双人对话记录\n\n';
                exportText += `导出时间: ${new Date().toLocaleString()}\n`;
                exportText += `总轮次: ${this.currentRound}\n`;
                exportText += `上下文限制: ${this.contextLimit || '无限制'}\n`;
                exportText += `AI智能压缩: ${this.enableCompression ? '已启用' : '未启用'}\n`;
                if (this.enableCompression) {
                    exportText += `压缩强度: ${(this.compressionRatio * 100).toFixed(0)}%\n`;
                    exportText += `保护最近: ${this.keepRecentCount}条消息\n`;
                    if (this.compressionStats.compressionCount > 0) {
                        const totalSaved = this.compressionStats.originalTokens - this.compressionStats.compressedTokens;
                        const savedPercentage = ((totalSaved / this.compressionStats.originalTokens) * 100).toFixed(1);
                        const netSaved = totalSaved - this.compressionStats.aiCompressionTokens;
                        exportText += `Token节省: ${totalSaved} (${savedPercentage}%)\n`;
                        exportText += `AI压缩成本: ${this.compressionStats.aiCompressionTokens} tokens\n`;
                        exportText += `净节省: ${netSaved} tokens\n`;
                    }
                }
                exportText += '\n';

                this.conversations.forEach((conv, index) => {
                    exportText += `## ${conv.speaker}\n\n${conv.content}\n\n`;
                });

                const blob = new Blob([exportText], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ai_dialogue_${new Date().getTime()}.txt`;
                a.click();
                URL.revokeObjectURL(url);
            }

            clearDialogue() {
                if (confirm('确定要清除所有对话记录吗？')) {
                    this.conversations = [];
                    this.currentRound = 0;
                    this.isRunning = false;
                    this.isPaused = false;
                    this.isPausedManually = false;
                    this.needsReset = false;
                    this.openingMessage = '';
                    this.nextSpeaker = 'B';
                    this.currentStreamingMessageId = null;
                    this.isAIWorking = false;
                    
                    // 重置压缩统计和缓存
                    this.compressedMessages = [];
                    this.compressionCache.clear();
                    this.lastCompressionIndex = 0;
                    this.compressionStats = {
                        originalTokens: 0,
                        compressedTokens: 0,
                        compressionCount: 0,
                        aiCompressionTokens: 0
                    };

                    this.elements.chatMessages.innerHTML = `
                        <div style="text-align: center; color: #666; margin-top: 50px;">
                            <h3>欢迎使用AI双人对话系统</h3>
                            <p>请先配置AI参数，然后输入开场白开始对话</p>
                        </div>
                    `;

                    this.updateRoundCounter();
                    this.updateUI();
                    this.updateCompressionStatsUI();
                }
            }

            // 改进的消息显示方法
            showMessage(message, type) {
                // 在聊天界面显示消息而不是弹出框
                if (type === 'error') {
                    this.addSystemMessage(`❌ ${message}`, 'error');
                } else if (type === 'success') {
                    this.addSystemMessage(`✅ ${message}`, 'success');
                } else {
                    this.addSystemMessage(`ℹ️ ${message}`, 'info');
                }
            }

            // 新增系统消息显示方法
            addSystemMessage(message, type = 'info') {
                const messagesContainer = this.elements.chatMessages;
                const messageDiv = document.createElement('div');

                const colorMap = {
                    'error': '#e74c3c',
                    'success': '#27ae60',
                    'info': '#3498db'
                };

                messageDiv.style.cssText = `
                    margin: 10px 0;
                    padding: 8px 12px;
                    border-radius: 4px;
                    background: rgba(${type === 'error' ? '231, 76, 60' : type === 'success' ? '39, 174, 96' : '52, 152, 219'}, 0.1);
                    border-left: 3px solid ${colorMap[type]};
                    color: ${colorMap[type]};
                    font-size: 13px;
                    text-align: center;
                `;

                messageDiv.textContent = message;
                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            /**
             * 检查是否应该跳过显示这条消息（因为已被压缩到摘要中）
             * @param {string} speaker - 发言者
             * @param {string} content - 消息内容
             * @returns {boolean} 是否应该跳过显示
             */
            shouldSkipMessage(speaker, content) {
                // 检查conversations数组中是否有压缩摘要消息包含这条原始消息
                const compressedMessage = this.conversations.find(conv => 
                    (conv.aiCompressed || conv.batchCompressed) &&
                    conv.originalMessages &&
                    conv.originalMessages.some(orig => 
                        orig.speaker === speaker && orig.content === content
                    )
                );
                
                return !!compressedMessage;
            }

            /**
             * 获取消息的压缩信息（基于原始消息查找对应的压缩消息）
             * @param {string} speaker - 发言者
             * @param {string} content - 消息内容
             * @param {Object} messageData - 消息数据
             * @returns {Object} 压缩信息
             */
            getCompressionInfoForMessage(speaker, content, messageData) {
                // 查找包含这条原始消息的压缩消息
                const compressedMessage = this.conversations.find(conv => 
                    (conv.aiCompressed || conv.batchCompressed) &&
                    conv.originalMessages &&
                    conv.originalMessages.some(orig => 
                        orig.speaker === speaker && orig.content === content
                    )
                );
                
                if (!compressedMessage) {
                    return { ratio: '0%', originalLength: 0, compressedLength: 0 };
                }
                
                const originalLength = compressedMessage.originalLength || 0;
                const compressedLength = compressedMessage.compressedLength || 0;
                const savedLength = originalLength - compressedLength;
                const ratio = originalLength > 0 ? Math.round((savedLength / originalLength) * 100) : 0;
                
                return {
                    originalLength,
                    compressedLength,
                    savedLength,
                    ratio: `${ratio}%`,
                    batchSize: compressedMessage.batchSize || 1,
                    compressionLevel: compressedMessage.compressionLevel || 0.5,
                    compressedContent: compressedMessage.compressedContent || compressedMessage.content
                };
            }

            /**
             * 获取压缩后的内容（基于原始消息查找）
             * @param {string} speaker - 发言者
             * @param {string} content - 消息内容
             * @param {Object} messageData - 消息数据
             * @returns {string} 压缩后的内容
             */
            getCompressedContentForMessage(speaker, content, messageData) {
                // 查找包含这条原始消息的压缩消息
                const compressedMessage = this.conversations.find(conv => 
                    (conv.aiCompressed || conv.batchCompressed) &&
                    conv.originalMessages &&
                    conv.originalMessages.some(orig => 
                        orig.speaker === speaker && orig.content === content
                    )
                );
                
                return compressedMessage?.compressedContent || compressedMessage?.content || null;
            }

            /**
             * 显示压缩后的内容
             * @param {string} messageId - 消息ID
             */
            showCompressedContent(messageId) {
                const messageElement = document.getElementById(messageId);
                if (!messageElement) return;

                const compressedContent = messageElement.getAttribute('data-compressed-content');
                const compressionStatsData = messageElement.getAttribute('data-compression-stats');
                
                if (!compressedContent) {
                    this.showMessage('未找到压缩内容', 'error');
                    return;
                }

                try {
                    const compressionStats = JSON.parse(compressionStatsData || '{}');
                    
                    // 获取原始消息内容
                    const originalContent = messageElement.querySelector('.message-content').textContent;
                    
                    this.createCompressedContentPopup(originalContent, compressedContent, compressionStats);
                } catch (error) {
                    console.error('解析压缩数据失败:', error);
                    this.showMessage('压缩数据格式错误', 'error');
                }
            }

            /**
             * 创建压缩内容对比弹窗
             * @param {string} originalContent - 原始内容
             * @param {string} compressedContent - 压缩内容
             * @param {Object} compressionStats - 压缩统计
             */
            createCompressedContentPopup(originalContent, compressedContent, compressionStats) {
                // 移除现有弹窗
                this.closeOriginalMessagesPopup();

                // 创建遮罩层
                const overlay = document.createElement('div');
                overlay.className = 'popup-overlay';
                overlay.onclick = () => this.closeOriginalMessagesPopup();

                // 创建弹窗
                const popup = document.createElement('div');
                popup.className = 'original-content-popup';
                popup.id = 'originalMessagesPopup';
                popup.style.maxWidth = '90%';

                // 弹窗头部
                const header = document.createElement('div');
                header.className = 'popup-header';
                header.innerHTML = `
                    <h3 class="popup-title">压缩内容对比</h3>
                    <button class="popup-close" onclick="window.aiDialogue.closeOriginalMessagesPopup()">×</button>
                `;

                // 弹窗内容
                const content = document.createElement('div');
                content.className = 'popup-content';
                content.innerHTML = `
                    <div style="display: flex; gap: 20px; margin-bottom: 15px;">
                        <div style="flex: 1;">
                            <h4 style="color: #2c3e50; margin-bottom: 10px;">📄 原始内容</h4>
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; border-left: 4px solid #3498db; max-height: 300px; overflow-y: auto;">
                                ${marked.parse(originalContent)}
                            </div>
                        </div>
                        <div style="flex: 1;">
                            <h4 style="color: #e67e22; margin-bottom: 10px;">🗜️ 压缩内容</h4>
                            <div style="background: #fff3cd; padding: 15px; border-radius: 6px; border-left: 4px solid #f39c12; max-height: 300px; overflow-y: auto;">
                                ${marked.parse(compressedContent)}
                            </div>
                        </div>
                    </div>
                `;

                // 显示压缩统计
                if (compressionStats.originalLength) {
                    const statsDiv = document.createElement('div');
                    statsDiv.className = 'compression-stats';
                    statsDiv.innerHTML = `
                        <strong>📊 压缩统计：</strong><br>
                        原始长度: ${compressionStats.originalLength} tokens<br>
                        压缩后长度: ${compressionStats.compressedLength} tokens<br>
                        节省空间: ${compressionStats.savedLength} tokens (${compressionStats.ratio})<br>
                        <em>注：UI中显示完整内容，API调用时使用压缩内容</em>
                    `;
                    content.appendChild(statsDiv);
                }

                popup.appendChild(header);
                popup.appendChild(content);

                document.body.appendChild(overlay);
                document.body.appendChild(popup);

                // 显示弹窗
                setTimeout(() => {
                    overlay.style.display = 'block';
                    popup.style.display = 'block';
                }, 10);

                // ESC键关闭
                const handleEsc = (e) => {
                    if (e.key === 'Escape') {
                        this.closeOriginalMessagesPopup();
                        document.removeEventListener('keydown', handleEsc);
                    }
                };
                document.addEventListener('keydown', handleEsc);
            }

            /**
             * 显示原始消息弹窗
             * @param {string} messageId - 消息ID
             */
            showOriginalMessages(messageId) {
                const messageElement = document.getElementById(messageId);
                if (!messageElement) return;

                const originalMessagesData = messageElement.getAttribute('data-original-messages');
                const compressionStatsData = messageElement.getAttribute('data-compression-stats');
                const contextMessagesData = messageElement.getAttribute('data-context-messages');
                
                if (!originalMessagesData) {
                    this.showMessage('未找到原始消息数据', 'error');
                    return;
                }

                try {
                    const originalMessages = JSON.parse(originalMessagesData);
                    const compressionStats = JSON.parse(compressionStatsData || '{}');
                    const contextMessages = contextMessagesData ? JSON.parse(contextMessagesData) : null;
                    
                    this.createOriginalMessagesPopup(originalMessages, compressionStats, contextMessages);
                } catch (error) {
                    console.error('解析原始消息数据失败:', error);
                    this.showMessage('原始消息数据格式错误', 'error');
                }
            }

            /**
             * 创建原始消息弹窗
             * @param {Array} originalMessages - 原始消息数组
             * @param {Object} compressionStats - 压缩统计
             * @param {Array} contextMessages - 上下文消息数组（可选）
             */
            createOriginalMessagesPopup(originalMessages, compressionStats, contextMessages = null) {
                // 移除现有弹窗
                this.closeOriginalMessagesPopup();

                // 创建遮罩层
                const overlay = document.createElement('div');
                overlay.className = 'popup-overlay';
                overlay.onclick = () => this.closeOriginalMessagesPopup();

                // 创建弹窗
                const popup = document.createElement('div');
                popup.className = 'original-content-popup';
                popup.id = 'originalMessagesPopup';

                // 弹窗头部
                const header = document.createElement('div');
                header.className = 'popup-header';
                const totalMessages = originalMessages.length + (contextMessages ? contextMessages.length : 0);
                header.innerHTML = `
                    <h3 class="popup-title">压缩相关消息 (${totalMessages}条${contextMessages ? '，含' + contextMessages.length + '条上下文' : ''})</h3>
                    <button class="popup-close" onclick="window.aiDialogue.closeOriginalMessagesPopup()">×</button>
                `;

                // 弹窗内容
                const content = document.createElement('div');
                content.className = 'popup-content';

                // 显示上下文消息（如果有）
                if (contextMessages && contextMessages.length > 0) {
                    const contextTitle = document.createElement('div');
                    contextTitle.innerHTML = '<h4 style="color: #666; margin: 15px 0 10px 0;">📖 上下文消息（用于理解语境）</h4>';
                    content.appendChild(contextTitle);
                    
                    contextMessages.forEach((msg, index) => {
                        const msgDiv = document.createElement('div');
                        msgDiv.className = 'original-message';
                        msgDiv.style.opacity = '0.7';
                        msgDiv.innerHTML = `
                            <div class="original-message-header">${msg.speaker} (上下文 ${index + 1})</div>
                            <div class="original-message-content">${marked.parse(msg.content)}</div>
                        `;
                        content.appendChild(msgDiv);
                    });
                }

                // 显示原始消息（被压缩的目标消息）
                if (contextMessages && contextMessages.length > 0) {
                    const originalTitle = document.createElement('div');
                    originalTitle.innerHTML = '<h4 style="color: #e74c3c; margin: 15px 0 10px 0;">🎯 被压缩的目标消息</h4>';
                    content.appendChild(originalTitle);
                }

                originalMessages.forEach((msg, index) => {
                    const msgDiv = document.createElement('div');
                    msgDiv.className = 'original-message';
                    if (contextMessages && contextMessages.length > 0) {
                        msgDiv.style.borderLeft = '4px solid #e74c3c';
                    }
                    msgDiv.innerHTML = `
                        <div class="original-message-header">${msg.speaker} ${contextMessages ? '(目标消息)' : '(第' + (index + 1) + '条)'}</div>
                        <div class="original-message-content">${marked.parse(msg.content)}</div>
                    `;
                    content.appendChild(msgDiv);
                });

                // 显示压缩统计
                if (compressionStats.originalLength) {
                    const statsDiv = document.createElement('div');
                    statsDiv.className = 'compression-stats';
                    const compressionType = compressionStats.batchSize > 1 ? '批量压缩' : '单条压缩';
                    statsDiv.innerHTML = `
                        <strong>📊 压缩统计：</strong><br>
                        压缩方式: ${compressionType}<br>
                        原始长度: ${compressionStats.originalLength} 字符<br>
                        压缩后长度: ${compressionStats.compressedLength} 字符<br>
                        节省空间: ${compressionStats.savedLength} 字符 (${compressionStats.ratio})<br>
                        ${compressionStats.batchSize > 1 ? '合并消息数: ' + compressionStats.batchSize + ' 条' : ''}
                    `;
                    content.appendChild(statsDiv);
                }

                popup.appendChild(header);
                popup.appendChild(content);

                document.body.appendChild(overlay);
                document.body.appendChild(popup);

                // 显示弹窗
                setTimeout(() => {
                    overlay.style.display = 'block';
                    popup.style.display = 'block';
                }, 10);

                // ESC键关闭
                const handleEsc = (e) => {
                    if (e.key === 'Escape') {
                        this.closeOriginalMessagesPopup();
                        document.removeEventListener('keydown', handleEsc);
                    }
                };
                document.addEventListener('keydown', handleEsc);
            }

            /**
             * 关闭原始消息弹窗
             */
            closeOriginalMessagesPopup() {
                const overlay = document.querySelector('.popup-overlay');
                const popup = document.getElementById('originalMessagesPopup');
                
                if (overlay) overlay.remove();
                if (popup) popup.remove();
            }

            /**
             * 重新渲染所有消息（包括压缩消息的可视化）
             */
            rerenderAllMessages() {
                const messagesContainer = this.elements.chatMessages;
                messagesContainer.innerHTML = '';

                this.conversations.forEach((conv, index) => {
                    // 始终显示完整消息内容，但传递压缩信息用于显示图标
                    const messageId = this.addMessageToUI(conv.speaker, conv.content, false, null, conv);
                });

                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            /**
             * 更新消息的压缩图标显示
             * @param {number} messageIndex - 消息在conversations数组中的索引
             */
            updateMessageCompressionIcon(messageIndex) {
                if (messageIndex < 0 || messageIndex >= this.conversations.length) return;
                
                const conv = this.conversations[messageIndex];
                if (!conv.isCompressed || !conv.compressedContent) return;
                
                console.log(`🔍 尝试为消息 ${messageIndex} 添加压缩图标:`, conv.speaker);
                
                // 查找对应的消息元素（通过位置和发言者匹配）
                const messageElements = document.querySelectorAll('.message');
                let targetElement = null;
                let matchCount = 0;
                
                // 先按发言者筛选，然后按位置匹配
                for (let i = 0; i < messageElements.length; i++) {
                    const element = messageElements[i];
                    const headerElement = element.querySelector('.message-header');
                    
                    if (headerElement) {
                        const headerText = headerElement.textContent.trim();
                        
                        // 检查发言者是否匹配
                        if (headerText.includes(conv.speaker)) {
                            // 如果这是第messageIndex个匹配的元素，就是我们要找的
                            let speakerMatchIndex = 0;
                            for (let j = 0; j < this.conversations.length; j++) {
                                if (this.conversations[j].speaker === conv.speaker) {
                                    if (j === messageIndex) {
                                        break;
                                    }
                                    speakerMatchIndex++;
                                }
                            }
                            
                            if (matchCount === speakerMatchIndex) {
                                targetElement = element;
                                break;
                            }
                            matchCount++;
                        }
                    }
                }
                
                if (targetElement) {
                    const headerElement = targetElement.querySelector('.message-header');
                    
                    // 检查是否已经有压缩图标
                    if (!headerElement.querySelector('.compression-indicator')) {
                        console.log(`✅ 为消息 ${messageIndex} 添加压缩图标`);
                        
                        // 添加压缩图标
                        const originalLength = this.estimateTokens(conv.content);
                        const compressedLength = this.estimateTokens(conv.compressedContent);
                        const ratio = originalLength > 0 ? 
                            Math.round(((originalLength - compressedLength) / originalLength) * 100) : 0;
                        
                        const compressionIndicator = document.createElement('span');
                        compressionIndicator.className = 'compression-indicator';
                        compressionIndicator.onclick = () => this.showCompressedContent(targetElement.id);
                        compressionIndicator.title = '点击查看压缩后的内容';
                        compressionIndicator.innerHTML = `
                            <span class="compression-icon">🗜️</span>
                            <span>已压缩 ${ratio}%</span>
                        `;
                        
                        headerElement.appendChild(compressionIndicator);
                        
                        // 存储压缩相关数据
                        targetElement.setAttribute('data-compressed-content', conv.compressedContent);
                        targetElement.setAttribute('data-compression-stats', JSON.stringify({
                            originalLength: originalLength,
                            compressedLength: compressedLength,
                            savedLength: originalLength - compressedLength,
                            ratio: `${ratio}%`,
                            compressionIndex: conv.compressionIndex
                        }));
                    } else {
                        console.log(`⚠️ 消息 ${messageIndex} 已有压缩图标，跳过`);
                    }
                } else {
                    console.warn(`❌ 未找到消息 ${messageIndex} 对应的DOM元素:`, conv.speaker);
                }
            }

            // ====== 上下文压缩功能核心方法 ======

            /**
             * 获取默认的压缩提示词模板
             * @returns {string} 默认提示词模板
             */
            getDefaultCompressionPromptTemplate() {
                return `你是一个专业的对话压缩助手。你的任务是将目标消息智能压缩，减少约{compressionRatio}%的内容长度，同时最大程度保留关键信息。

## 压缩原则：
1. **保留核心信息**：保持主要观点、结论和重要细节
2. **维持逻辑连贯**：确保压缩后的内容逻辑清晰、易于理解
3. **删除冗余**：去除重复、啰嗦、客套话、过渡词等无关紧要的内容
4. **保持语气和风格**：尽量保持原有的对话语气
5. **保留关键数据**：专业术语、数字、时间、专有名词等必须保留

## 压缩策略：
- 合并相似观点和重复内容
- 简化冗长表述，用更精炼的语言
- 删除寒暄、感叹词等非核心内容
- 保留论证逻辑和因果关系

## 重要说明：
只需要输出压缩后的文本，禁止输出其他任何内容。`;
            }

            /**
             * 获取AI压缩的系统提示词
             * @param {number} compressionRatio - 压缩比率
             * @returns {string} 压缩提示词
             */
            getCompressionPrompt(compressionRatio) {
                const targetReduction = Math.round(compressionRatio * 100);
                let template = this.elements.promptSystem.value.trim();
                
                // 如果用户没有设置自定义模板，使用默认模板
                if (!template) {
                    template = this.getDefaultCompressionPromptTemplate();
                }
                
                // 替换变量
                return template.replace(/\{compressionRatio\}/g, targetReduction);
            }

            /**
             * 估算文本的Token数量（简化版本）
             * @param {string} text - 要估算的文本
             * @returns {number} 估算的Token数量
             */
            estimateTokens(text) {
                if (!text) return 0;
                // 简化的Token估算：中文字符约1.5个token，英文单词约1个token
                const chineseChars = (text.match(/[\u4e00-\u9fff]/g) || []).length;
                const englishWords = (text.match(/[a-zA-Z]+/g) || []).length;
                const otherChars = text.length - chineseChars - englishWords;
                return Math.ceil(chineseChars * 1.5 + englishWords + otherChars * 0.5);
            }



            /**
             * AI智能压缩对话历史（单条消息压缩机制）
             * @param {Array} conversations - 对话历史数组
             * @returns {Array} 用于API的对话数组（包含压缩内容）
             */
            async compressConversations(conversations) {
                if (!this.enableCompression || conversations.length <= this.keepRecentCount) {
                    return conversations;
                }
                
                const totalCount = conversations.length;
                
                // 计算需要压缩的消息位置（从后往前数第keepRecentCount+1条）
                const targetCompressIndex = totalCount - this.keepRecentCount - 1;
                
                // 如果目标压缩位置无效或已经压缩过，构建API用的对话数组
                if (targetCompressIndex < 0) {
                    return conversations;
                }
                
                // 检查是否需要压缩新消息
                if (targetCompressIndex >= this.lastCompressionIndex) {
                    // 需要压缩新消息
                    const targetMessage = conversations[targetCompressIndex];
                    const cacheKey = this.getMessageCacheKey(targetMessage, targetCompressIndex);
                    
                    if (!this.compressionCache.has(cacheKey)) {
                        // 确定压缩时的上下文范围（包含目标消息在内的最近3条，使用完整消息）
                        const contextSize = 3;
                        const contextStart = Math.max(0, targetCompressIndex - contextSize + 1);
                        const contextMessages = conversations.slice(contextStart, targetCompressIndex + 1);
                        
                        console.log(`🗜️ 压缩消息位置 ${targetCompressIndex}，上下文范围 ${contextStart}-${targetCompressIndex} (${contextMessages.length}条)`);
                        
                        try {
                            // 压缩目标消息，携带上下文（使用完整消息）
                            const compressedContent = await this.compressTargetMessage(
                                targetMessage, 
                                contextMessages, 
                                targetCompressIndex
                            );
                            
                            // 存入压缩缓存（只存储压缩后的内容，不是完整消息对象）
                            this.compressionCache.set(cacheKey, compressedContent);
                            
                            // 更新压缩索引
                            this.lastCompressionIndex = targetCompressIndex + 1;
                            
                            // 标记原消息已被压缩（用于UI显示）
                            const targetMsg = conversations[targetCompressIndex];
                            if (targetMsg instanceof Message) {
                                targetMsg.markAsCompressed(compressedContent, targetCompressIndex);
                            } else {
                                // 向后兼容旧格式
                                targetMsg.isCompressed = true;
                                targetMsg.compressedContent = compressedContent;
                                targetMsg.compressionIndex = targetCompressIndex;
                            }
                            
                            // 立即更新UI显示压缩图标（延迟执行确保DOM已更新）
                            setTimeout(() => {
                                this.updateMessageCompressionIcon(targetCompressIndex);
                            }, 200);
                            
                        } catch (error) {
                            console.error('压缩失败:', error);
                            this.showCompressionError(error, 1);
                        }
                    } else {
                        // 使用缓存的压缩结果
                        const cachedCompressed = this.compressionCache.get(cacheKey);
                        const targetMsg = conversations[targetCompressIndex];
                        if (targetMsg instanceof Message) {
                            targetMsg.markAsCompressed(cachedCompressed, targetCompressIndex);
                        } else {
                            // 向后兼容旧格式
                            targetMsg.isCompressed = true;
                            targetMsg.compressedContent = cachedCompressed;
                            targetMsg.compressionIndex = targetCompressIndex;
                        }
                        
                        // 立即更新UI显示压缩图标（延迟执行确保DOM已更新）
                        setTimeout(() => {
                            this.updateMessageCompressionIcon(targetCompressIndex);
                        }, 200);
                        
                        console.log(`✅ 使用缓存，跳过压缩位置 ${targetCompressIndex}`);
                    }
                }
                
                // 构建用于API的对话数组（使用压缩内容）
                return this.buildAPIConversations(conversations);
            }

            /**
             * 构建用于API的对话数组（使用压缩内容）
             * @param {Array} conversations - 原始对话数组
             * @returns {Array} 用于API的对话数组
             */
            buildAPIConversations(conversations) {
                const totalCount = conversations.length;
                const result = [];
                
                for (let i = 0; i < totalCount; i++) {
                    const conv = conversations[i];
                    
                    // 判断是否应该使用压缩内容
                    const shouldUseCompressed = conv.isCompressed && 
                                               i < (totalCount - this.keepRecentCount) && // 不在保护范围内
                                               conv.compressedContent; // 有压缩内容
                    
                    if (shouldUseCompressed) {
                        // 使用压缩内容
                        result.push({
                            role: conv.role,
                            content: conv.compressedContent,
                            speaker: conv.speaker,
                            isFromCompression: true
                        });
                    } else {
                        // 使用完整内容
                        result.push({
                            role: conv.role,
                            content: conv.content,
                            speaker: conv.speaker
                        });
                    }
                }
                
                return result;
            }

            /**
             * 压缩目标消息（携带上下文）
             * @param {Object} targetMessage - 目标消息
             * @param {Array} contextMessages - 上下文消息数组（包含目标消息）
             * @param {number} targetIndex - 目标消息在原数组中的索引
             * @returns {string} 压缩后的内容
             */
            async compressTargetMessage(targetMessage, contextMessages, targetIndex) {
                try {
                    // 计算原始Token数量
                    const originalTokenCount = this.estimateTokens(targetMessage.content);
                    
                    // 构建压缩请求
                    const compressionPrompt = this.getCompressionPrompt(this.compressionRatio);
                    
                    // 构建上下文文本（用于AI理解上下文，使用完整消息）
                    const contextText = contextMessages.map((msg, idx) => {
                        const isTarget = msg === targetMessage;
                        const prefix = isTarget ? '【目标消息】' : '【上下文】';
                        // 始终使用完整内容作为压缩上下文
                        return `${prefix}${msg.speaker}: ${msg.content}`;
                    }).join('\n\n');
                    
                    const messages = [
                        { role: 'system', content: compressionPrompt },
                        { 
                            role: 'user', 
                            content: `请压缩下面标记为【目标消息】的内容，其他【上下文】消息仅用于理解语境，不需要压缩：\n\n${contextText}\n\n请只返回目标消息的压缩版本。` 
                        }
                    ];
                    
                    // 显示压缩进行中的提示
                    this.addSystemMessage(`🤖 AI正在压缩第${targetIndex + 1}条消息 (携带${contextMessages.length}条上下文)...`, 'info');
                    
                    // 使用统一的AI调用逻辑（带重试）
                    const systemConfig = this.getAIConfig('System');
                    const response = await this.callAIWithRetry('System', systemConfig, messages);
                    
                    if (!response || !response.content) {
                        throw new Error('AI压缩响应为空');
                    }
                    
                    // 解析AI返回的压缩结果（现在直接返回文本）
                    const compressedContent = this.parseCompressionResult(response.content);
                    
                    if (!compressedContent || compressedContent.trim().length === 0) {
                        throw new Error('AI压缩结果为空');
                    }
                    
                    // 计算压缩统计
                    const compressedTokenCount = this.estimateTokens(compressedContent);
                    const aiCompressionCost = this.estimateTokens(compressionPrompt) + 
                                            this.estimateTokens(contextText) + 
                                            this.estimateTokens(response.content);
                    
                    // 更新压缩统计
                    this.compressionStats.originalTokens += originalTokenCount;
                    this.compressionStats.compressedTokens += compressedTokenCount;
                    this.compressionStats.aiCompressionTokens += aiCompressionCost;
                    this.compressionStats.compressionCount++;
                    
                    const savedTokens = originalTokenCount - compressedTokenCount;
                    const savedPercentage = ((savedTokens / originalTokenCount) * 100).toFixed(1);
                    
                    // 显示压缩统计信息
                    this.addSystemMessage(
                        `🤖 压缩完成：第${targetIndex + 1}条消息，节省 ${savedTokens} tokens (${savedPercentage}%)`, 
                        'info'
                    );
                    
                    // 强制更新压缩图标（延迟执行）
                    setTimeout(() => {
                        console.log(`🔧 强制更新消息 ${targetIndex} 的压缩图标`);
                        this.updateMessageCompressionIcon(targetIndex);
                    }, 1000);
                    
                    // 更新压缩统计UI
                    this.updateCompressionStatsUI();
                    
                    // 返回压缩后的内容字符串
                    return compressedContent;
                    
                } catch (error) {
                    console.error('目标消息压缩失败:', error);
                    throw error;
                }
            }

            /**
             * 批量压缩一组消息（多条消息压缩为一条）- 保留用于向后兼容
             * @param {Array} messageBatch - 消息批次（多条消息）
             * @returns {Array} 压缩后的消息数组（只有一条消息）
             */
            async compressMessageBatch(messageBatch) {
                if (!messageBatch || messageBatch.length === 0) {
                    return [];
                }
                
                // 生成批次缓存key（基于所有消息的组合内容）
                const batchCacheKey = this.getBatchCacheKey(messageBatch);
                
                // 检查批次缓存
                if (this.compressionCache.has(batchCacheKey)) {
                    console.log(`✅ 使用批次缓存，跳过压缩 (${messageBatch.length}条消息)`);
                    return this.compressionCache.get(batchCacheKey);
                }
                
                try {
                    // 计算原始Token数量
                    const originalTokenCount = messageBatch.reduce((sum, conv) => 
                        sum + this.estimateTokens(conv.content), 0);
                    
                    // 构建压缩请求
                    const compressionPrompt = this.getCompressionPrompt(this.compressionRatio);
                    const conversationText = messageBatch.map(conv => 
                        `${conv.speaker}: ${conv.content}`
                    ).join('\n\n');
                    
                    const messages = [
                        { role: 'system', content: compressionPrompt },
                        { 
                            role: 'user', 
                            content: `请将以下${messageBatch.length}条连续对话压缩为一条摘要消息，保持对话的核心内容和逻辑：\n\n${conversationText}` 
                        }
                    ];
                    
                    // 显示压缩进行中的提示
                    this.addSystemMessage(`🤖 AI正在将${messageBatch.length}条对话压缩为1条摘要...`, 'info');
                    
                    // 使用统一的AI调用逻辑（带重试）
                    const systemConfig = this.getAIConfig('System');
                    const response = await this.callAIWithRetry('System', systemConfig, messages);
                    
                    if (!response || !response.content) {
                        throw new Error('AI批量压缩响应为空');
                    }
                    
                    // 解析AI返回的压缩结果
                    const compressedResult = this.parseCompressionResult(response.content);
                    
                    if (!compressedResult || !compressedResult.compressed_messages || compressedResult.compressed_messages.length === 0) {
                        throw new Error('AI批量压缩结果解析失败');
                    }
                    
                    // 创建一条压缩摘要消息（合并多条消息为一条）
                    const firstMessage = compressedResult.compressed_messages[0];
                    const compressedMessage = {
                        role: 'assistant',
                        content: firstMessage.content, // 这是压缩后的内容，会显示在界面上
                        speaker: `压缩摘要 (${messageBatch.length}条消息)`,
                        originalLength: originalTokenCount,
                        compressedLength: this.estimateTokens(firstMessage.content),
                        compressionLevel: this.compressionRatio,
                        aiCompressed: true,
                        batchCompressed: true,
                        batchSize: messageBatch.length,
                        originalMessages: messageBatch.map(m => ({
                            speaker: m.speaker,
                            content: m.content,
                            originalLength: m.content.length
                        })),
                        compressedContent: firstMessage.content // 存储压缩后的内容
                    };
                    
                    // 存入批次缓存
                    this.compressionCache.set(batchCacheKey, [compressedMessage]);
                    
                    // 计算压缩统计
                    const compressedTokenCount = this.estimateTokens(firstMessage.content);
                    const aiCompressionCost = this.estimateTokens(compressionPrompt) + 
                                            this.estimateTokens(conversationText) + 
                                            this.estimateTokens(response.content);
                    
                    // 更新压缩统计
                    this.compressionStats.originalTokens += originalTokenCount;
                    this.compressionStats.compressedTokens += compressedTokenCount;
                    this.compressionStats.aiCompressionTokens += aiCompressionCost;
                    this.compressionStats.compressionCount++;
                    
                    const savedTokens = originalTokenCount - compressedTokenCount;
                    const netSavedTokens = savedTokens - aiCompressionCost;
                    const savedPercentage = ((savedTokens / originalTokenCount) * 100).toFixed(1);
                    
                    // 显示批量压缩统计信息
                    this.addSystemMessage(
                        `🤖 压缩完成：${messageBatch.length}条消息→1条摘要，节省 ${savedTokens} tokens (${savedPercentage}%)`, 
                        'info'
                    );
                    
                    // 更新压缩统计UI
                    this.updateCompressionStatsUI();
                    
                    return [compressedMessage];
                    
                } catch (error) {
                    console.error('批量压缩失败:', error);
                    
                    // 显示详细的错误信息
                    this.showCompressionError(error, messageBatch.length);
                    
                    // 批量压缩失败，返回原始消息
                    this.addSystemMessage(`❌ 批量压缩失败，保持原始${messageBatch.length}条消息不压缩`, 'error');
                    return messageBatch;
                }
            }

            /**
             * 生成批次缓存key
             * @param {Array} messageBatch - 消息批次
             * @returns {string} 批次缓存key
             */
            getBatchCacheKey(messageBatch) {
                // 将批次中所有消息的内容组合生成hash
                const batchContent = messageBatch.map(msg => `${msg.speaker}:${msg.content}`).join('|');
                const hash = batchContent.split('').reduce((a, b) => {
                    a = ((a << 5) - a) + b.charCodeAt(0);
                    return a & a;
                }, 0);
                return `batch_${messageBatch.length}_${hash.toString()}`;
            }

            /**
             * 获取缓存的压缩对话
             * @param {Array} conversations - 对话历史数组
             * @returns {Array} 缓存的压缩结果
             */
            getCachedCompressedConversations(conversations) {
                // 如果没有缓存，则返回原始对话
                if (this.compressionCache.size === 0) {
                    return conversations;
                }
                
                return conversations.map(conv => {
                    const cacheKey = this.getMessageCacheKey(conv);
                    return this.compressionCache.get(cacheKey) || conv;
                });
            }

            /**
             * 生成消息的缓存key
             * @param {Object} message - 消息对象
             * @param {number} index - 消息在数组中的索引（可选）
             * @returns {string} 缓存key
             */
            getMessageCacheKey(message, index = null) {
                // 使用消息内容、发言者和位置生成hash
                const content = `${message.speaker}:${message.content}${index !== null ? ':' + index : ''}`;
                const hash = content.split('').reduce((a, b) => {
                    a = ((a << 5) - a) + b.charCodeAt(0);
                    return a & a;
                }, 0);
                return hash.toString();
            }





            /**
             * 解析AI压缩结果（简化版 - 直接返回文本）
             * @param {string} content - AI返回的内容
             * @returns {string} 压缩后的文本
             */
            parseCompressionResult(content) {
                if (!content || typeof content !== 'string') {
                    throw new Error('AI响应内容为空或格式不正确');
                }

                // 清理内容：去除可能的markdown代码块标记
                let cleanContent = content.trim();
                
                // 如果AI返回了代码块格式，提取内容
                const codeBlockMatch = cleanContent.match(/```(?:text|markdown)?\s*([\s\S]*?)\s*```/);
                if (codeBlockMatch) {
                    cleanContent = codeBlockMatch[1].trim();
                }
                
                // 验证内容不为空
                if (!cleanContent || cleanContent.length < 10) {
                    throw new Error('AI返回的压缩内容过短或为空');
                }
                
                console.log('✅ 压缩内容解析成功，长度:', cleanContent.length);
                
                // 直接返回清理后的文本
                return cleanContent;
            }

            /**
             * 显示压缩错误的详细信息
             * @param {Error} error - 错误对象
             * @param {number} messageCount - 消息数量
             */
            showCompressionError(error, messageCount) {
                let errorType = '未知错误';
                let suggestion = '';
                
                if (error.message.includes('HTTP 401') || error.message.includes('Unauthorized')) {
                    errorType = 'API密钥错误';
                    suggestion = '请检查系统AI的API密钥是否正确';
                } else if (error.message.includes('HTTP 429') || error.message.includes('Rate limit')) {
                    errorType = 'API调用频率限制';
                    suggestion = '请稍后重试或检查API配额';
                } else if (error.message.includes('HTTP 400') || error.message.includes('Bad Request')) {
                    errorType = 'API请求格式错误';
                    suggestion = '请检查系统AI模型名称是否正确';
                } else if (error.message.includes('HTTP 404')) {
                    errorType = 'API端点不存在';
                    suggestion = '请检查系统AI的API地址是否正确';
                } else if (error.message.includes('HTTP 500') || error.message.includes('Internal Server Error')) {
                    errorType = 'API服务器内部错误';
                    suggestion = '服务器暂时不可用，请稍后重试';
                } else if (error.message.includes('网络错误') || error.message.includes('Failed to fetch')) {
                    errorType = '网络连接错误';
                    suggestion = '请检查网络连接或API地址';
                } else if (error.message.includes('解析失败') || error.message.includes('JSON')) {
                    errorType = 'AI响应解析失败';
                    suggestion = '可能是模型返回格式不正确，建议调整提示词';
                } else if (error.message.includes('响应为空')) {
                    errorType = 'AI无响应';
                    suggestion = '模型可能遇到问题，请检查配置或稍后重试';
                }
                
                const errorMessage = `
❌ AI压缩失败详情：
• 错误类型: ${errorType}
• 处理消息: ${messageCount}条
• 建议操作: ${suggestion}
• 技术详情: ${error.message}
                `.trim();
                
                this.addSystemMessage(errorMessage, 'error');
            }

            /**
             * 统一的AI调用方法（带重试机制）
             * @param {string} aiType - AI类型
             * @param {Object} config - AI配置
             * @param {Array} messages - 消息数组
             * @returns {Object} API响应
             */
            async callAIWithRetry(aiType, config, messages) {
                let currentRetries = 0;
                
                while (currentRetries <= this.retryCount) {
                    try {
                        if (currentRetries > 0) {
                            this.addSystemMessage(`🔄 ${aiType === 'System' ? '系统AI' : 'AI ' + aiType} 重试中 (${currentRetries}/${this.retryCount})...`, 'info');
                            await this.sleep(this.retryDelay);
                        }
                        
                        // 根据AI类型调用相应的API
                        if (config.endpointType === 'openai') {
                            if (aiType === 'System') {
                                return await this.callOpenAIForCompression(config, messages);
                            } else {
                                // 对话AI使用流式调用（这里简化为非流式）
                                return await this.callOpenAIForCompression(config, messages);
                            }
                        } else if (config.endpointType === 'gemini') {
                            if (aiType === 'System') {
                                return await this.callGeminiForCompression(config, messages);
                            } else {
                                // 对话AI使用流式调用（这里简化为非流式）
                                return await this.callGeminiForCompression(config, messages);
                            }
                        } else {
                            throw new Error(`不支持的AI类型: ${config.endpointType}`);
                        }
                        
                    } catch (error) {
                        console.warn(`AI ${aiType} 尝试 ${currentRetries + 1} 失败:`, error.message);
                        currentRetries++;
                        
                        // 如果是配置错误，不需要重试
                        if (error.message.includes('HTTP 401') || 
                            error.message.includes('HTTP 404') || 
                            error.message.includes('不支持的')) {
                            break;
                        }
                        
                        if (currentRetries <= this.retryCount) {
                            this.addSystemMessage(`❌ AI ${aiType} 调用失败，${this.retryDelay/1000}秒后重试 (${currentRetries}/${this.retryCount})`, 'error');
                        }
                    }
                }
                
                // 重试次数用完，暂停对话
                this.addSystemMessage(`❌ AI ${aiType} 调用失败，已达重试上限，对话已暂停`, 'error');
                this.isPaused = true;
                this.updateUI();
                
                throw new Error(`AI ${aiType} 调用失败，已达重试上限`);
            }

            /**
             * 调用OpenAI进行压缩（非流式）
             */
            async callOpenAIForCompression(config, messages) {
                // 修复：如果URL以#结尾，强制使用输入地址；否则自动补全
                let url;
                if (config.apiUrl.endsWith('#')) {
                    url = config.apiUrl.slice(0, -1); // 去掉末尾的#
                } else if (config.apiUrl.endsWith('/v1/chat/completions')) {
                    url = config.apiUrl;
                } else {
                    url = `${config.apiUrl}/v1/chat/completions`;
                }

                let response;
                try {
                    response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${config.apiKey}`
                        },
                        body: JSON.stringify({
                            model: config.model,
                            messages: messages,
                            temperature: 0.7
                        })
                    });
                } catch (error) {
                    throw new Error(`网络错误: ${error.message}`);
                }

                if (!response.ok) {
                    let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        if (errorData.error && errorData.error.message) {
                            errorMessage += ` - ${errorData.error.message}`;
                        }
                    } catch (e) {
                        // 忽略JSON解析错误
                    }
                    throw new Error(errorMessage);
                }

                let data;
                try {
                    data = await response.json();
                } catch (error) {
                    throw new Error(`响应解析失败: ${error.message}`);
                }

                const content = data.choices?.[0]?.message?.content;
                if (!content) {
                    throw new Error('OpenAI API响应为空或格式不正确');
                }

                return { content };
            }

            /**
             * 调用Gemini进行压缩（非流式）
             */
            async callGeminiForCompression(config, messages) {
                const url = `${config.apiUrl}/v1beta/models/${config.model}:generateContent?key=${config.apiKey}`;

                // 转换消息格式
                const contents = messages.filter(m => m.role !== 'system').map(m => ({
                    role: m.role === 'assistant' ? 'model' : 'user',
                    parts: [{ text: m.content }]
                }));

                const systemInstruction = messages.find(m => m.role === 'system');
                const requestBody = {
                    contents: contents,
                    generationConfig: {
                        temperature: 0.7
                    }
                };

                if (systemInstruction) {
                    requestBody.systemInstruction = {
                        parts: [{ text: systemInstruction.content }]
                    };
                }

                let response;
                try {
                    response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });
                } catch (error) {
                    throw new Error(`网络错误: ${error.message}`);
                }

                if (!response.ok) {
                    let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        if (errorData.error && errorData.error.message) {
                            errorMessage += ` - ${errorData.error.message}`;
                        }
                    } catch (e) {
                        // 忽略JSON解析错误
                    }
                    throw new Error(errorMessage);
                }

                let data;
                try {
                    data = await response.json();
                } catch (error) {
                    throw new Error(`响应解析失败: ${error.message}`);
                }

                // 检查Gemini特有的错误格式
                if (data.error) {
                    throw new Error(`Gemini API错误: ${data.error.message || '未知错误'}`);
                }

                const content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!content) {
                    // 检查是否被安全过滤器阻止
                    if (data.candidates?.[0]?.finishReason === 'SAFETY') {
                        throw new Error('内容被Gemini安全过滤器阻止，请调整提示词');
                    }
                    throw new Error('Gemini API响应为空或格式不正确');
                }

                return { content };
            }

            /**
             * 获取压缩统计信息
             */
            getCompressionStats() {
                const stats = this.compressionStats;
                if (stats.compressionCount === 0) {
                    return '暂无压缩统计';
                }
                
                const totalSaved = stats.originalTokens - stats.compressedTokens;
                const avgSavedPercentage = ((totalSaved / stats.originalTokens) * 100).toFixed(1);
                
                return `总计压缩 ${stats.compressionCount} 次，节省 ${totalSaved} tokens (${avgSavedPercentage}%)`;
            }

            /**
             * 更新压缩统计UI显示
             */
            updateCompressionStatsUI() {
                const statsSection = document.getElementById('compressionStatsSection');
                const statsDiv = document.getElementById('compressionStats');

                if (this.enableCompression && this.compressionStats.compressionCount > 0) {
                    const stats = this.compressionStats;
                    const totalSaved = stats.originalTokens - stats.compressedTokens;
                    const netSaved = totalSaved - (stats.aiCompressionTokens || 0);
                    const avgSavedPercentage = ((totalSaved / stats.originalTokens) * 100).toFixed(1);

                    let statsHtml = `
                        📊 压缩次数: ${stats.compressionCount}<br>
                        💾 节省Token: ${totalSaved} (${avgSavedPercentage}%)<br>
                        📈 原始Token: ${stats.originalTokens}<br>
                        📉 压缩后Token: ${stats.compressedTokens}<br>
                        🤖 AI压缩成本: ${stats.aiCompressionTokens} tokens<br>
                        💰 净节省: ${netSaved} tokens
                    `;

                    statsDiv.innerHTML = statsHtml;
                    statsSection.style.display = 'block';
                } else if (this.enableCompression) {
                    statsDiv.innerHTML = `
                        🤖 压缩模式: AI智能压缩<br>
                        📏 压缩强度: ${(this.compressionRatio * 100).toFixed(0)}%<br>
                        🔒 保护最近: ${this.keepRecentCount}条消息<br>
                        📊 等待压缩数据...
                    `;
                    statsSection.style.display = 'block';
                } else {
                    statsSection.style.display = 'none';
                }
            }

            // ====== Tab切换和代理管理功能 ======

            /**
             * 切换Tab
             * @param {string} tabId - Tab ID
             */
            switchTab(tabId) {
                // 更新按钮状态
                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-tab="${tabId}"]`).classList.add('active');

                // 切换内容显示
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.style.display = 'none';
                });
                document.getElementById(tabId).style.display = 'block';

                this.currentTab = tabId;

                // 如果切换到代理配置页面，刷新代理列表
                if (tabId === 'proxy-config') {
                    this.renderProxyList();
                }
            }

            /**
             * 生成唯一ID
             * @returns {string} 唯一ID
             */
            generateId() {
                return 'proxy_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);
            }

            /**
             * 添加新代理
             */
            addNewProxy() {
                const newProxy = {
                    id: this.generateId(),
                    name: '新代理',
                    endpoint: 'openai',
                    apiUrl: 'https://xxx.com',
                    apiKey: 'sk-xxx',
                    modelName: 'gpt-4'
                };

                this.proxies.set(newProxy.id, newProxy);
                this.renderProxyList();
                this.updateProxySelectors(); // 添加后更新选择器
            }

            /**
             * 渲染代理列表
             */
            renderProxyList() {
                const container = this.elements.proxyListContainer;

                if (this.proxies.size === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; color: #666; padding: 30px;">
                            <p>暂无代理配置</p>
                            <p style="font-size: 12px;">点击"新增代理"按钮添加第一个代理配置</p>
                        </div>
                    `;
                    return;
                }

                // 将Map转换为数组并按创建时间倒序排列（新的在前）
                const proxiesArray = Array.from(this.proxies.entries()).reverse();

                let html = '';
                for (const [id, proxy] of proxiesArray) {
                    html += this.createProxyItemHTML(proxy);
                }

                container.innerHTML = html;

                // 添加事件监听
                this.setupProxyItemListeners();
            }

            /**
             * 创建代理配置项HTML
             * @param {Object} proxy - 代理配置对象
             * @returns {string} HTML字符串
             */
            createProxyItemHTML(proxy) {
                return `
                    <div class="proxy-item" data-proxy-id="${proxy.id}">
                        <div class="proxy-item-header">
                            <div class="proxy-item-title">${proxy.name}</div>
                            <div class="proxy-item-actions">
                                <button class="btn btn-danger btn-small proxy-delete" data-proxy-id="${proxy.id}">删除</button>
                            </div>
                        </div>

                        <div class="proxy-form-row">
                            <div class="form-group">
                                <label class="form-label">代理名称</label>
                                <input type="text" class="form-input proxy-name" value="${proxy.name}" data-proxy-id="${proxy.id}">
                            </div>
                            <div class="form-group">
                                <label class="form-label">端点类型</label>
                                <select class="form-select proxy-endpoint" data-proxy-id="${proxy.id}">
                                    <option value="openai" ${proxy.endpoint === 'openai' ? 'selected' : ''}>OpenAI</option>
                                    <option value="gemini" ${proxy.endpoint === 'gemini' ? 'selected' : ''}>Gemini</option>
                                </select>
                            </div>
                        </div>

                        <div class="proxy-form-row">
                            <div class="form-group">
                                <label class="form-label">API地址</label>
                                <input type="text" class="form-input proxy-apiurl" value="${proxy.apiUrl}" data-proxy-id="${proxy.id}">
                                <div class="api-hint">OpenAI: 系统会自动补全 /v1/chat/completions，如需使用完整地址请在末尾加#</div>
                            </div>
                        </div>

                        <div class="proxy-form-row">
                            <div class="form-group">
                                <label class="form-label">API密钥</label>
                                <input type="text" class="form-input proxy-apikey" value="${proxy.apiKey}" data-proxy-id="${proxy.id}">
                            </div>
                            <div class="form-group">
                                <label class="form-label">模型名称</label>
                                <input type="text" class="form-input proxy-modelname" value="${proxy.modelName}" data-proxy-id="${proxy.id}">
                            </div>
                        </div>
                    </div>
                `;
            }

            /**
             * 设置代理配置项的事件监听
             */
            setupProxyItemListeners() {
                // 删除代理
                document.querySelectorAll('.proxy-delete').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const proxyId = e.target.dataset.proxyId;
                        this.deleteProxy(proxyId);
                    });
                });

                // 监听输入变化，实时更新数据
                document.querySelectorAll('.proxy-name').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const proxyId = e.target.dataset.proxyId;
                        const proxy = this.proxies.get(proxyId);
                        if (proxy) {
                            proxy.name = e.target.value;
                            // 更新标题显示
                            const titleElement = e.target.closest('.proxy-item').querySelector('.proxy-item-title');
                            titleElement.textContent = e.target.value;
                        }
                    });
                });

                document.querySelectorAll('.proxy-endpoint').forEach(select => {
                    select.addEventListener('change', (e) => {
                        const proxyId = e.target.dataset.proxyId;
                        const proxy = this.proxies.get(proxyId);
                        if (proxy) {
                            proxy.endpoint = e.target.value;
                            // 根据端点类型更新默认值
                            this.updateProxyDefaults(proxyId, e.target.value);
                        }
                    });
                });

                document.querySelectorAll('.proxy-apiurl').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const proxyId = e.target.dataset.proxyId;
                        const proxy = this.proxies.get(proxyId);
                        if (proxy) {
                            proxy.apiUrl = e.target.value;
                        }
                    });
                });

                document.querySelectorAll('.proxy-apikey').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const proxyId = e.target.dataset.proxyId;
                        const proxy = this.proxies.get(proxyId);
                        if (proxy) {
                            proxy.apiKey = e.target.value;
                        }
                    });
                });

                document.querySelectorAll('.proxy-modelname').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const proxyId = e.target.dataset.proxyId;
                        const proxy = this.proxies.get(proxyId);
                        if (proxy) {
                            proxy.modelName = e.target.value;
                        }
                    });
                });
            }

            /**
             * 删除代理配置
             * @param {string} proxyId - 代理ID
             */
            deleteProxy(proxyId) {
                if (confirm('确定要删除这个代理配置吗？')) {
                    this.proxies.delete(proxyId);
                    this.renderProxyList();
                    this.updateProxySelectors(); // 删除后更新选择器
                }
            }

            /**
             * 根据端点类型更新代理的默认值
             * @param {string} proxyId - 代理ID
             * @param {string} endpoint - 端点类型
             */
            updateProxyDefaults(proxyId, endpoint) {
                const proxy = this.proxies.get(proxyId);
                if (!proxy) return;

                if (endpoint === 'openai') {
                    proxy.apiUrl = 'https://xxx.com';
                    proxy.apiKey = 'sk-xxx';
                    proxy.modelName = 'gpt-4';
                } else if (endpoint === 'gemini') {
                    proxy.apiUrl = 'https://generativelanguage.googleapis.com';
                    proxy.apiKey = 'akxxx';
                    proxy.modelName = 'gemini-2.5-pro';
                }

                // 重新渲染以更新UI
                this.renderProxyList();
            }

            /**
             * 保存代理配置
             */
            saveProxyConfiguration() {
                const proxiesData = {};
                for (const [id, proxy] of this.proxies) {
                    proxiesData[id] = proxy;
                }

                localStorage.setItem('aiDialogueProxies', JSON.stringify(proxiesData));
                this.updateProxySelectors(); // 保存后更新选择器
                this.showMessage('代理配置已保存', 'success');
            }

            /**
             * 加载代理配置
             */
            loadProxyConfiguration() {
                const saved = localStorage.getItem('aiDialogueProxies');
                if (saved) {
                    const proxiesData = JSON.parse(saved);
                    this.proxies.clear();

                    for (const [id, proxy] of Object.entries(proxiesData)) {
                        this.proxies.set(id, proxy);
                    }

                    console.log('已加载代理配置:', this.proxies.size, '个代理');
                }
            }

            // ====== 配置导入导出功能 ======

            /**
             * 导出配置
             */
            exportConfiguration() {
                try {
                    // 收集所有配置数据
                    const exportData = {
                        version: '1.0',
                        timestamp: new Date().toISOString(),

                        // AI配置
                        aiConfig: JSON.parse(localStorage.getItem('aiDialogueConfig') || '{}'),

                        // 代理配置
                        proxies: {}
                    };

                    // 导出代理配置
                    for (const [id, proxy] of this.proxies) {
                        exportData.proxies[id] = proxy;
                    }

                    // 创建下载文件
                    const dataStr = JSON.stringify(exportData, null, 2);
                    const blob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);

                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `ai_dialogue_config_${new Date().getTime()}.json`;
                    a.click();

                    URL.revokeObjectURL(url);
                    this.showMessage('配置导出成功', 'success');
                } catch (error) {
                    console.error('导出配置失败:', error);
                    this.showMessage('配置导出失败: ' + error.message, 'error');
                }
            }

            /**
             * 导入配置
             * @param {Event} event - 文件选择事件
             */
            importConfiguration(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importData = JSON.parse(e.target.result);

                        // 验证配置文件格式
                        if (!importData.version || !importData.aiConfig || !importData.proxies) {
                            throw new Error('配置文件格式不正确');
                        }

                        // 确认导入
                        if (!confirm('导入配置将覆盖当前所有配置，确定继续吗？')) {
                            return;
                        }

                        // 导入AI配置
                        localStorage.setItem('aiDialogueConfig', JSON.stringify(importData.aiConfig));

                        // 导入代理配置
                        this.proxies.clear();
                        for (const [id, proxy] of Object.entries(importData.proxies)) {
                            this.proxies.set(id, proxy);
                        }
                        localStorage.setItem('aiDialogueProxies', JSON.stringify(importData.proxies));

                        // 重新加载配置到UI
                        this.loadConfiguration();
                        this.updateProxySelectors();
                        this.renderProxyList();

                        this.showMessage('配置导入成功', 'success');

                        // 清空文件选择器
                        event.target.value = '';

                    } catch (error) {
                        console.error('导入配置失败:', error);
                        this.showMessage('配置导入失败: ' + error.message, 'error');
                        event.target.value = '';
                    }
                };

                reader.readAsText(file);
            }
        }

        // 初始化系统
        document.addEventListener('DOMContentLoaded', () => {
            new AIDialogueSystem();
        });
    </script>
</body>
</html>