<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIåŒäººå¯¹è¯ç³»ç»Ÿ</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
        }

        .container {
            display: flex;
            width: 100%;
            height: 100vh;
            background: white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        /* å·¦ä¾§é…ç½®æ  */
        .config-panel {
            width: 350px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            padding: 20px;
            overflow-y: auto;
        }

        .config-section {
            margin-bottom: 25px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .config-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
            font-size: 13px;
        }

        .form-input, .form-select, .form-textarea {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            transition: border-color 0.3s;
        }

        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: #3498db;
        }

        .form-textarea {
            height: 60px;
            resize: vertical;
        }

        .api-hint {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
            font-style: italic;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #219a52;
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .btn-warning:hover {
            background: #e67e22;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* å³ä¾§å¯¹è¯æ  */
        .chat-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            min-width: 0;
        }

        .chat-header {
            background: #2c3e50;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-title {
            font-size: 18px;
            font-weight: 600;
        }

        .status-indicator {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-ready {
            background: #27ae60;
        }

        .status-running {
            background: #f39c12;
        }

        .status-stopped {
            background: #e74c3c;
        }

        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            background: #f8f9fa;
            min-width: 0;
        }

        .message {
            margin-bottom: 15px;
            padding: 12px 15px;
            border-radius: 8px;
            max-width: 80%;
            overflow: hidden;
            word-wrap: break-word;
            min-width: 0;
        }

        .message-a {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
        }

        .message-b {
            background: #f3e5f5;
            border-left: 4px solid #9c27b0;
            margin-left: auto;
        }

        /* æ–°å¢ï¼šloadingæ¶ˆæ¯æ ·å¼ */
        .message-loading {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            opacity: 0.8;
        }

        .message-header {
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .message-content {
            line-height: 1.6;
            color: #333;
            max-width: 100%;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        .message-content h1, .message-content h2, .message-content h3 {
            margin-top: 15px;
            margin-bottom: 10px;
        }

        .message-content h1 {
            font-size: 20px;
        }

        .message-content h2 {
            font-size: 18px;
        }

        .message-content h3 {
            font-size: 16px;
        }

        .message-content p {
            margin-bottom: 10px;
        }

        .message-content code {
            background: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            word-break: break-word;
        }

        .message-content pre {
            background: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            overflow-y: hidden;
            margin: 10px 0;
            max-width: 100%;
            white-space: pre;
        }

        .message-content pre code {
            background: transparent;
            padding: 0;
            white-space: pre;
            word-break: normal;
            display: block;
        }

        .chat-input {
            padding: 20px;
            border-top: 1px solid #e9ecef;
            background: white;
        }

        .input-group {
            display: flex;
            gap: 10px;
        }

        .input-field {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        /* æ”¹è¿›çš„loadingåŠ¨ç”» */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* æ–°å¢ï¼šæ‰“å­—æœºæ•ˆæœçš„loading */
        .typing-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .typing-dot {
            width: 6px;
            height: 6px;
            background: #999;
            border-radius: 50%;
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: scale(1);
                opacity: 0.5;
            }
            30% {
                transform: scale(1.2);
                opacity: 1;
            }
        }

        .error-message {
            color: #e74c3c;
            font-size: 12px;
            margin-top: 5px;
        }

        .round-counter {
            background: rgba(255,255,255,0.2);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        /* å‹ç¼©æ¶ˆæ¯æ ·å¼ */
        .message-compressed {
            border-left-color: #f39c12 !important;
            background: linear-gradient(90deg, #fff3cd 0%, #f8f9fa 100%) !important;
        }

        .compression-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            margin-left: 8px;
            font-size: 11px;
            color: #f39c12;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 10px;
            background: rgba(243, 156, 18, 0.1);
            border: 1px solid rgba(243, 156, 18, 0.3);
            transition: all 0.2s;
        }

        .compression-indicator:hover {
            background: rgba(243, 156, 18, 0.2);
            transform: scale(1.05);
        }

        .compression-icon {
            font-size: 12px;
        }

        /* åŸå§‹å†…å®¹å¼¹çª— */
        .original-content-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 80%;
            max-height: 80%;
            z-index: 1000;
            display: none;
        }

        .popup-header {
            padding: 15px 20px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f8f9fa;
            border-radius: 8px 8px 0 0;
        }

        .popup-title {
            font-weight: 600;
            color: #2c3e50;
            margin: 0;
        }

        .popup-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #6c757d;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .popup-close:hover {
            background: #e9ecef;
            color: #495057;
        }

        .popup-content {
            padding: 20px;
            overflow-y: auto;
            max-height: 60vh;
        }

        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            display: none;
        }

        .original-message {
            margin-bottom: 15px;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #3498db;
            background: #f8f9fa;
        }

        .original-message-header {
            font-weight: 600;
            margin-bottom: 8px;
            color: #2c3e50;
            font-size: 14px;
        }

        .original-message-content {
            line-height: 1.6;
            color: #333;
        }

        .compression-stats {
            margin-top: 15px;
            padding: 10px;
            background: #e3f2fd;
            border-radius: 4px;
            font-size: 12px;
            color: #1976d2;
        }


    </style>
</head>
<body>    <div class="container">
        <!-- å·¦ä¾§é…ç½®æ  -->
        <div class="config-panel">
            <!-- æ“ä½œæŒ‰é’® -->
            <div class="config-section">
                <div class="config-title">æ“ä½œ</div>
                <button class="btn btn-primary" id="saveConfig">ä¿å­˜é…ç½®</button>
                <button class="btn btn-success" id="startChat">å¼€å§‹å¯¹è¯</button>
                <button class="btn btn-warning" id="pauseChat">æš‚åœ</button>
                <button class="btn btn-success" id="resumeChat" style="display:none;">ç»§ç»­</button>
                <button class="btn btn-danger" id="stopChat">åœæ­¢</button>
                <button class="btn btn-primary" id="exportChat">å¯¼å‡ºå¯¹è¯</button>
                <button class="btn btn-danger" id="clearChat">æ¸…é™¤å¯¹è¯</button>
                <button class="btn btn-warning" id="retryChat" style="display:none;">é‡è¯•</button>
            </div>

            <!-- AI A é…ç½® -->
            <div class="config-section">
                <div class="config-title">AI A é…ç½®</div>
                <div class="form-group">
                    <label class="form-label">ç«¯ç‚¹ç±»å‹</label>
                    <select class="form-select" id="endpointTypeA">
                        <option value="openai">OpenAI</option>
                        <option value="gemini">Gemini</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">APIåœ°å€</label>
                    <input type="text" class="form-input" id="apiUrlA" placeholder="APIåœ°å€">
                    <div class="api-hint">OpenAI: ç³»ç»Ÿä¼šè‡ªåŠ¨è¡¥å…¨ /v1/chat/completionsï¼Œå¦‚éœ€ä½¿ç”¨å®Œæ•´åœ°å€è¯·åœ¨æœ«å°¾åŠ #</div>
                </div>
                <div class="form-group">
                    <label class="form-label">APIå¯†é’¥</label>
                    <input type="text" class="form-input" id="apiKeyA" placeholder="APIå¯†é’¥">
                </div>
                <div class="form-group">
                    <label class="form-label">æ¨¡å‹åç§°</label>
                    <input type="text" class="form-input" id="modelA" placeholder="æ¨¡å‹åç§°">
                </div>
                <div class="form-group">
                    <label class="form-label">æç¤ºè¯</label>
                    <textarea class="form-textarea" id="promptA" placeholder="AI Açš„ç³»ç»Ÿæç¤ºè¯"></textarea>
                </div>
            </div>

            <!-- AI B é…ç½® -->
            <div class="config-section">
                <div class="config-title">AI B é…ç½®</div>
                <div class="form-group">
                    <label class="form-label">ç«¯ç‚¹ç±»å‹</label>
                    <select class="form-select" id="endpointTypeB">
                        <option value="openai">OpenAI</option>
                        <option value="gemini">Gemini</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">APIåœ°å€</label>
                    <input type="text" class="form-input" id="apiUrlB" placeholder="APIåœ°å€">
                    <div class="api-hint">OpenAI: ç³»ç»Ÿä¼šè‡ªåŠ¨è¡¥å…¨ /v1/chat/completionsï¼Œå¦‚éœ€ä½¿ç”¨å®Œæ•´åœ°å€è¯·åœ¨æœ«å°¾åŠ #</div>
                </div>
                <div class="form-group">
                    <label class="form-label">APIå¯†é’¥</label>
                    <input type="text" class="form-input" id="apiKeyB" placeholder="APIå¯†é’¥">
                </div>
                <div class="form-group">
                    <label class="form-label">æ¨¡å‹åç§°</label>
                    <input type="text" class="form-input" id="modelB" placeholder="æ¨¡å‹åç§°">
                </div>
                <div class="form-group">
                    <label class="form-label">æç¤ºè¯</label>
                    <textarea class="form-textarea" id="promptB" placeholder="AI Bçš„ç³»ç»Ÿæç¤ºè¯"></textarea>
                </div>
            </div>

            <!-- ç³»ç»ŸAIé…ç½® -->
            <div class="config-section">
                <div class="config-title">ç³»ç»ŸAIé…ç½® (ç”¨äºå‹ç¼©ç­‰åŠŸèƒ½)</div>
                <div class="form-group">
                    <label class="form-label">ç«¯ç‚¹ç±»å‹</label>
                    <select class="form-select" id="endpointTypeSystem">
                        <option value="openai">OpenAI</option>
                        <option value="gemini">Gemini</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">APIåœ°å€</label>
                    <input type="text" class="form-input" id="apiUrlSystem" placeholder="APIåœ°å€">
                    <div class="api-hint">OpenAI: ç³»ç»Ÿä¼šè‡ªåŠ¨è¡¥å…¨ /v1/chat/completionsï¼Œå¦‚éœ€ä½¿ç”¨å®Œæ•´åœ°å€è¯·åœ¨æœ«å°¾åŠ #</div>
                </div>
                <div class="form-group">
                    <label class="form-label">APIå¯†é’¥</label>
                    <input type="text" class="form-input" id="apiKeySystem" placeholder="APIå¯†é’¥">
                </div>
                <div class="form-group">
                    <label class="form-label">æ¨¡å‹åç§°</label>
                    <input type="text" class="form-input" id="modelSystem" placeholder="æ¨¡å‹åç§°">
                </div>
                <div class="form-group">
                    <label class="form-label">æç¤ºè¯</label>
                    <textarea class="form-textarea" id="promptSystem" placeholder="ç³»ç»ŸAIçš„å‹ç¼©æç¤ºè¯"></textarea>
                </div>
            </div>

            <!-- å¯¹è¯æ§åˆ¶ -->
            <div class="config-section">
                <div class="config-title">å¯¹è¯æ§åˆ¶</div>
                <div class="form-group">
                    <label class="form-label">æœ€å¤§è½®æ¬¡ (0=æ— é™åˆ¶)</label>
                    <input type="number" class="form-input" id="maxRounds" value="0" min="0">
                </div>
                <div class="form-group">
                    <label class="form-label">ä¸Šä¸‹æ–‡æ¶ˆæ¯æ•°é‡ (0=å…¨éƒ¨)</label>
                    <input type="number" class="form-input" id="contextLimit" value="0" min="0">
                    <div class="api-hint">é™åˆ¶æ¯æ¬¡APIè°ƒç”¨æ—¶å‘é€çš„å†å²æ¶ˆæ¯æ•°é‡ï¼Œå¯ä»¥å‡å°‘Tokenæ¶ˆè€—</div>
                </div>
                <div class="form-group">
                    <label class="form-label">
                        <input type="checkbox" id="enableCompression" style="margin-right: 8px;">
                        å¯ç”¨AIæ™ºèƒ½ä¸Šä¸‹æ–‡å‹ç¼©
                    </label>
                    <div class="api-hint">ä½¿ç”¨ç³»ç»ŸAIè‡ªåŠ¨å‹ç¼©å†å²å¯¹è¯ä»¥å‡å°‘Tokenæ¶ˆè€—ï¼Œä¿ç•™å…³é”®ä¿¡æ¯</div>
                </div>
                <div class="form-group">
                    <label class="form-label">å‹ç¼©å¼ºåº¦</label>
                    <select class="form-select" id="compressionRatio">
                        <option value="0.3">è½»åº¦å‹ç¼© (ä¿ç•™70%å†…å®¹)</option>
                        <option value="0.5" selected>ä¸­åº¦å‹ç¼© (ä¿ç•™50%å†…å®¹)</option>
                        <option value="0.7">é‡åº¦å‹ç¼© (ä¿ç•™30%å†…å®¹)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">ä¸å‹ç¼©æ¡æ•°</label>
                    <input type="number" class="form-input" id="keepRecentCount" value="5" min="0" max="20">
                    <div class="api-hint">æœ€è¿‘çš„Xæ¡æ¶ˆæ¯ä¸å‚ä¸å‹ç¼©ï¼Œä¿æŒå®Œæ•´ä¸Šä¸‹æ–‡</div>
                </div>
                <div class="form-group">
                    <label class="form-label">é‡è¯•æ¬¡æ•°</label>
                    <input type="number" class="form-input" id="retryCount" value="3" min="0">
                </div>
                <div class="form-group">
                    <label class="form-label">é‡è¯•é—´éš” (ç§’)</label>
                    <input type="number" class="form-input" id="retryDelay" value="2" min="1">
                </div>
            </div>

            <!-- å‹ç¼©ç»Ÿè®¡ -->
            <div class="config-section" id="compressionStatsSection" style="display:none;">
                <div class="config-title">å‹ç¼©ç»Ÿè®¡</div>
                <div id="compressionStats" style="font-size: 12px; color: #666; line-height: 1.5;">
                    æš‚æ— å‹ç¼©æ•°æ®
                </div>
            </div>
        </div>

        <!-- å³ä¾§å¯¹è¯æ  -->
        <div class="chat-panel">
            <div class="chat-header">
                <div class="chat-title">AIåŒäººå¯¹è¯</div>
                <div style="display: flex; align-items: center; gap: 15px;">
                    <div class="round-counter">è½®æ¬¡: <span id="roundCounter">0</span></div>
                    <div class="status-indicator status-ready" id="statusIndicator">å°±ç»ª</div>
                </div>
            </div>

            <div class="chat-messages" id="chatMessages">
                <div style="text-align: center; color: #666; margin-top: 50px;">
                    <h3>æ¬¢è¿ä½¿ç”¨AIåŒäººå¯¹è¯ç³»ç»Ÿ</h3>
                    <p>è¯·å…ˆé…ç½®AIå‚æ•°ï¼Œç„¶åè¾“å…¥å¼€åœºç™½å¼€å§‹å¯¹è¯</p>
                </div>
            </div>

            <div class="chat-input">
                <div class="input-group">
                    <input type="text" class="input-field" id="openingMessage" placeholder="è¾“å…¥å¼€åœºç™½ï¼Œç”±AI Aå‘èµ·å¯¹è¯...">
                    <button class="btn btn-primary" id="sendOpening">å‘èµ·å¯¹è¯</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        class AIDialogueSystem {
            constructor() {
                this.conversations = [];
                this.currentRound = 0;
                this.maxRounds = 0;
                this.contextLimit = 0; // æ–°å¢ï¼šä¸Šä¸‹æ–‡é™åˆ¶
                this.isRunning = false;
                this.isPaused = false;
                this.retryCount = 3;
                this.retryDelay = 2000;
                this.currentRetries = 0;
                this.needsReset = false;
                this.openingMessage = '';
                this.nextSpeaker = 'B';
                // æ–°å¢ï¼šç”¨äºè·Ÿè¸ªå½“å‰æ­£åœ¨æµå¼æ˜¾ç¤ºçš„æ¶ˆæ¯
                this.currentStreamingMessageId = null;
                
                // æ–°å¢ï¼šè·Ÿè¸ªæ¯ä¸ªAIå½“å‰çš„ç«¯ç‚¹ç±»å‹
                this.currentEndpointTypes = {
                    'A': 'openai',
                    'B': 'openai', 
                    'System': 'openai'
                };
                
                // ====== ä¸Šä¸‹æ–‡å‹ç¼©åŠŸèƒ½ç›¸å…³å±æ€§ ======
                this.enableCompression = false; // æ˜¯å¦å¯ç”¨å‹ç¼©
                this.compressionRatio = 0.5; // å‹ç¼©æ¯”ç‡ (0.1-0.9)
                this.keepRecentCount = 5; // æœ€è¿‘Xæ¡æ¶ˆæ¯ä¸å‹ç¼©
                this.compressedMessages = []; // å­˜å‚¨å‹ç¼©åçš„æ¶ˆæ¯æ‘˜è¦
                this.compressionCache = new Map(); // å‹ç¼©ç¼“å­˜ï¼Œkeyä¸ºæ¶ˆæ¯å†…å®¹hashï¼Œvalueä¸ºå‹ç¼©ç»“æœ
                this.lastCompressionIndex = 0; // ä¸Šæ¬¡å‹ç¼©åˆ°çš„æ¶ˆæ¯ç´¢å¼•
                this.compressionStats = { // å‹ç¼©ç»Ÿè®¡ä¿¡æ¯
                    originalTokens: 0,
                    compressedTokens: 0,
                    compressionCount: 0,
                    aiCompressionTokens: 0 // AIå‹ç¼©æ¶ˆè€—çš„Token
                };

                this.initializeElements();
                this.loadConfiguration();
                this.setupEventListeners();
                this.updateUI();
                
                // è®¾ç½®å…¨å±€å¼•ç”¨ä»¥ä¾¿åœ¨onclickä¸­è®¿é—®
                window.aiDialogue = this;
            }

            initializeElements() {
                // é…ç½®å…ƒç´ 
                this.elements = {
                    endpointTypeA: document.getElementById('endpointTypeA'),
                    apiUrlA: document.getElementById('apiUrlA'),
                    apiKeyA: document.getElementById('apiKeyA'),
                    modelA: document.getElementById('modelA'),
                    promptA: document.getElementById('promptA'),

                    endpointTypeB: document.getElementById('endpointTypeB'),
                    apiUrlB: document.getElementById('apiUrlB'),
                    apiKeyB: document.getElementById('apiKeyB'),
                    modelB: document.getElementById('modelB'),
                    promptB: document.getElementById('promptB'),

                    endpointTypeSystem: document.getElementById('endpointTypeSystem'),
                    apiUrlSystem: document.getElementById('apiUrlSystem'),
                    apiKeySystem: document.getElementById('apiKeySystem'),
                    modelSystem: document.getElementById('modelSystem'),
                    promptSystem: document.getElementById('promptSystem'),

                    maxRounds: document.getElementById('maxRounds'),
                    contextLimit: document.getElementById('contextLimit'), // æ–°å¢
                    enableCompression: document.getElementById('enableCompression'),
                    compressionRatio: document.getElementById('compressionRatio'),
                    keepRecentCount: document.getElementById('keepRecentCount'),
                    retryCount: document.getElementById('retryCount'),
                    retryDelay: document.getElementById('retryDelay'),

                    chatMessages: document.getElementById('chatMessages'),
                    openingMessage: document.getElementById('openingMessage'),
                    statusIndicator: document.getElementById('statusIndicator'),
                    roundCounter: document.getElementById('roundCounter'),

                    saveConfig: document.getElementById('saveConfig'),
                    startChat: document.getElementById('startChat'),
                    pauseChat: document.getElementById('pauseChat'),
                    resumeChat: document.getElementById('resumeChat'),
                    stopChat: document.getElementById('stopChat'),
                    exportChat: document.getElementById('exportChat'),
                    clearChat: document.getElementById('clearChat'),
                    retryChat: document.getElementById('retryChat'),
                    sendOpening: document.getElementById('sendOpening')
                };
            }

            setupEventListeners() {
                // ç«¯ç‚¹ç±»å‹å˜åŒ–æ—¶åˆ‡æ¢é…ç½®
                this.elements.endpointTypeA.addEventListener('change', (e) => this.switchEndpointConfig('A', e));
                this.elements.endpointTypeB.addEventListener('change', (e) => this.switchEndpointConfig('B', e));
                this.elements.endpointTypeSystem.addEventListener('change', (e) => this.switchEndpointConfig('System', e));
                
                // å‹ç¼©åŠŸèƒ½ç›¸å…³äº‹ä»¶
                this.elements.enableCompression.addEventListener('change', () => this.updateCompressionStatsUI());

                // æŒ‰é’®äº‹ä»¶
                this.elements.saveConfig.addEventListener('click', () => this.saveConfiguration());
                this.elements.startChat.addEventListener('click', () => this.startDialogue());
                this.elements.pauseChat.addEventListener('click', () => this.pauseDialogue());
                this.elements.resumeChat.addEventListener('click', () => this.resumeDialogue());
                this.elements.stopChat.addEventListener('click', () => this.stopDialogue());
                this.elements.exportChat.addEventListener('click', () => this.exportDialogue());
                this.elements.clearChat.addEventListener('click', () => this.clearDialogue());
                this.elements.retryChat.addEventListener('click', () => this.retryLastRequest());
                this.elements.sendOpening.addEventListener('click', () => this.sendOpeningMessage());

                // å›è½¦å‘é€
                this.elements.openingMessage.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendOpeningMessage();
                });
            }

            /**
             * åˆ‡æ¢ç«¯ç‚¹é…ç½®ï¼ˆä¿å­˜å½“å‰é…ç½®ï¼ŒåŠ è½½ç›®æ ‡ç«¯ç‚¹é…ç½®ï¼‰
             * @param {string} aiType - AIç±»å‹ ('A', 'B', 'System')
             * @param {Event} event - åˆ‡æ¢äº‹ä»¶
             */
            switchEndpointConfig(aiType, event) {
                const newEndpointType = event.target.value;
                const previousEndpointType = this.currentEndpointTypes[aiType];
                
                console.log(`${aiType}: ä» ${previousEndpointType} åˆ‡æ¢åˆ° ${newEndpointType}`);
                
                // å¦‚æœç«¯ç‚¹ç±»å‹æ²¡æœ‰å˜åŒ–ï¼Œä¸éœ€è¦åˆ‡æ¢
                if (previousEndpointType === newEndpointType) {
                    return;
                }
                
                // å…ˆä¿å­˜å½“å‰æ˜¾ç¤ºçš„é…ç½®åˆ°åˆ‡æ¢å‰çš„ç«¯ç‚¹ç±»å‹
                this.saveCurrentEndpointConfigToType(aiType, previousEndpointType);
                
                // æ›´æ–°å½“å‰ç«¯ç‚¹ç±»å‹è·Ÿè¸ª
                this.currentEndpointTypes[aiType] = newEndpointType;
                
                // ç„¶ååŠ è½½æ–°ç«¯ç‚¹çš„é…ç½®
                this.loadEndpointConfig(aiType);
            }

            /**
             * ä¿å­˜å½“å‰ç«¯ç‚¹çš„é…ç½®
             * @param {string} aiType - AIç±»å‹
             */
            saveCurrentEndpointConfig(aiType) {
                // è·å–å½“å‰çš„ç«¯ç‚¹ç±»å‹å’Œé…ç½®
                const currentEndpointType = this.elements[`endpointType${aiType}`].value;
                this.saveCurrentEndpointConfigToType(aiType, currentEndpointType);
            }

            /**
             * ä¿å­˜å½“å‰æ˜¾ç¤ºçš„é…ç½®åˆ°æŒ‡å®šçš„ç«¯ç‚¹ç±»å‹
             * @param {string} aiType - AIç±»å‹
             * @param {string} endpointType - ç«¯ç‚¹ç±»å‹
             */
            saveCurrentEndpointConfigToType(aiType, endpointType) {
                const currentConfig = {
                    apiUrl: this.elements[`apiUrl${aiType}`].value,
                    apiKey: this.elements[`apiKey${aiType}`].value,
                    model: this.elements[`model${aiType}`].value,
                    prompt: this.elements[`prompt${aiType}`].value
                };

                // åªæœ‰åœ¨æœ‰å®é™…é…ç½®å†…å®¹æ—¶æ‰ä¿å­˜
                if (currentConfig.apiUrl.trim() || currentConfig.apiKey.trim() || currentConfig.model.trim()) {
                    const endpointConfigs = this.getEndpointConfigs();
                    if (!endpointConfigs[aiType]) {
                        endpointConfigs[aiType] = {};
                    }
                    endpointConfigs[aiType][endpointType] = currentConfig;
                    this.saveEndpointConfigs(endpointConfigs);
                    
                    console.log(`ä¿å­˜ ${aiType} çš„ ${endpointType} é…ç½®:`, currentConfig);
                }
            }

            /**
             * åŠ è½½æŒ‡å®šç«¯ç‚¹çš„é…ç½®
             * @param {string} aiType - AIç±»å‹
             */
            loadEndpointConfig(aiType) {
                const targetEndpointType = this.elements[`endpointType${aiType}`].value;
                const endpointConfigs = this.getEndpointConfigs();
                
                // å°è¯•åŠ è½½å·²ä¿å­˜çš„é…ç½®
                const savedConfig = endpointConfigs[aiType]?.[targetEndpointType];
                
                if (savedConfig) {
                    // åŠ è½½å·²ä¿å­˜çš„é…ç½®
                    this.elements[`apiUrl${aiType}`].value = savedConfig.apiUrl || '';
                    this.elements[`apiKey${aiType}`].value = savedConfig.apiKey || '';
                    this.elements[`model${aiType}`].value = savedConfig.model || '';
                    this.elements[`prompt${aiType}`].value = savedConfig.prompt || '';
                    
                    console.log(`åŠ è½½ ${aiType} çš„ ${targetEndpointType} å·²ä¿å­˜é…ç½®:`, savedConfig);
                } else {
                    // æ²¡æœ‰ä¿å­˜çš„é…ç½®ï¼Œä½¿ç”¨é»˜è®¤å€¼
                    this.updateDefaults(aiType, true);
                    console.log(`${aiType} çš„ ${targetEndpointType} æ²¡æœ‰ä¿å­˜çš„é…ç½®ï¼Œä½¿ç”¨é»˜è®¤å€¼`);
                }
            }

            /**
             * è·å–ç«¯ç‚¹é…ç½®
             * @returns {Object} ç«¯ç‚¹é…ç½®å¯¹è±¡
             */
            getEndpointConfigs() {
                const saved = localStorage.getItem('aiDialogueEndpointConfigs');
                return saved ? JSON.parse(saved) : {};
            }

            /**
             * ä¿å­˜ç«¯ç‚¹é…ç½®
             * @param {Object} configs - ç«¯ç‚¹é…ç½®å¯¹è±¡
             */
            saveEndpointConfigs(configs) {
                localStorage.setItem('aiDialogueEndpointConfigs', JSON.stringify(configs));
            }

            updateDefaults(aiType, forceUpdate = false) {
                const endpointType = this.elements[`endpointType${aiType}`].value;

                if (endpointType === 'openai') {
                    if (aiType === 'System') {
                        // ç³»ç»ŸAIä½¿ç”¨ä½æˆæœ¬æ¨¡å‹
                        if (forceUpdate || !this.elements[`apiUrl${aiType}`].value.trim()) {
                            this.elements[`apiUrl${aiType}`].value = 'https://xxx.com';
                        }
                        if (forceUpdate || !this.elements[`apiKey${aiType}`].value.trim()) {
                            this.elements[`apiKey${aiType}`].value = 'sk-xxx';
                        }
                        if (forceUpdate || !this.elements[`model${aiType}`].value.trim()) {
                            this.elements[`model${aiType}`].value = 'gpt-3.5-turbo';
                        }
                        if (forceUpdate || !this.elements[`prompt${aiType}`].value.trim()) {
                            this.elements[`prompt${aiType}`].value = this.getDefaultCompressionPromptTemplate();
                        }
                    } else {
                        if (forceUpdate || !this.elements[`apiUrl${aiType}`].value.trim()) {
                            this.elements[`apiUrl${aiType}`].value = 'https://xxx.com';
                        }
                        if (forceUpdate || !this.elements[`apiKey${aiType}`].value.trim()) {
                            this.elements[`apiKey${aiType}`].value = 'sk-xxx';
                        }
                        if (forceUpdate || !this.elements[`model${aiType}`].value.trim()) {
                            this.elements[`model${aiType}`].value = 'gpt-4';
                        }
                    }
                } else if (endpointType === 'gemini') {
                    if (aiType === 'System') {
                        // ç³»ç»ŸAIä½¿ç”¨ä½æˆæœ¬æ¨¡å‹
                        if (forceUpdate || !this.elements[`apiUrl${aiType}`].value.trim()) {
                            this.elements[`apiUrl${aiType}`].value = 'https://generativelanguage.googleapis.com';
                        }
                        if (forceUpdate || !this.elements[`apiKey${aiType}`].value.trim()) {
                            this.elements[`apiKey${aiType}`].value = 'akxxx';
                        }
                        if (forceUpdate || !this.elements[`model${aiType}`].value.trim()) {
                            this.elements[`model${aiType}`].value = 'gemini-1.5-flash';
                        }
                        if (forceUpdate || !this.elements[`prompt${aiType}`].value.trim()) {
                            this.elements[`prompt${aiType}`].value = this.getDefaultCompressionPromptTemplate();
                        }
                    } else {
                        if (forceUpdate || !this.elements[`apiUrl${aiType}`].value.trim()) {
                            this.elements[`apiUrl${aiType}`].value = 'https://generativelanguage.googleapis.com';
                        }
                        if (forceUpdate || !this.elements[`apiKey${aiType}`].value.trim()) {
                            this.elements[`apiKey${aiType}`].value = 'akxxx';
                        }
                        if (forceUpdate || !this.elements[`model${aiType}`].value.trim()) {
                            this.elements[`model${aiType}`].value = 'gemini-2.5-pro';
                        }
                    }
                }
            }

            loadConfiguration() {
                const saved = localStorage.getItem('aiDialogueConfig');
                if (saved) {
                    const config = JSON.parse(saved);
                    Object.keys(config).forEach(key => {
                        if (this.elements[key]) {
                            if (this.elements[key].type === 'checkbox') {
                                this.elements[key].checked = config[key];
                            } else {
                                this.elements[key].value = config[key];
                            }
                        }
                    });
                    
                    // åˆå§‹åŒ–ç«¯ç‚¹ç±»å‹è·Ÿè¸ª
                    ['A', 'B', 'System'].forEach(aiType => {
                        this.currentEndpointTypes[aiType] = this.elements[`endpointType${aiType}`].value;
                    });
                    
                    // åŠ è½½å®Œé€šç”¨é…ç½®åï¼Œä¸ºæ¯ä¸ªAIåŠ è½½å¯¹åº”ç«¯ç‚¹çš„é…ç½®
                    ['A', 'B', 'System'].forEach(aiType => {
                        this.loadEndpointConfig(aiType);
                    });
                    
                    // ç¡®ä¿ç³»ç»ŸAIæç¤ºè¯æœ‰é»˜è®¤å€¼ï¼ˆå¦‚æœä¸ºç©ºçš„è¯ï¼‰
                    if (!this.elements.promptSystem.value.trim()) {
                        this.elements.promptSystem.value = this.getDefaultCompressionPromptTemplate();
                    }
                } else {
                    // åˆå§‹åŒ–ç«¯ç‚¹ç±»å‹è·Ÿè¸ªä¸ºé»˜è®¤å€¼
                    ['A', 'B', 'System'].forEach(aiType => {
                        this.currentEndpointTypes[aiType] = this.elements[`endpointType${aiType}`].value;
                    });
                    
                    // è®¾ç½®é»˜è®¤å€¼ï¼ˆä¸å¼ºåˆ¶æ›´æ–°ï¼Œåªåœ¨å­—æ®µä¸ºç©ºæ—¶è®¾ç½®ï¼‰
                    this.updateDefaults('A', false);
                    this.updateDefaults('B', false);
                    this.updateDefaults('System', false);
                }
                
                // æ›´æ–°å‹ç¼©ç»Ÿè®¡UI
                this.updateCompressionStatsUI();
            }

            saveConfiguration() {
                // ä¿å­˜å½“å‰æ‰€æœ‰ç«¯ç‚¹çš„é…ç½®
                ['A', 'B', 'System'].forEach(aiType => {
                    this.saveCurrentEndpointConfig(aiType);
                });

                // ä¿å­˜é€šç”¨é…ç½®
                const config = {};
                Object.keys(this.elements).forEach(key => {
                    if (this.elements[key]) {
                        if (this.elements[key].type === 'checkbox') {
                            config[key] = this.elements[key].checked;
                        } else if (this.elements[key].value !== undefined) {
                            config[key] = this.elements[key].value;
                        }
                    }
                });
                localStorage.setItem('aiDialogueConfig', JSON.stringify(config));
                this.showMessage('é…ç½®å·²ä¿å­˜', 'success');
            }

            /**
             * æ·»åŠ æˆ–æ›´æ–°æ¶ˆæ¯åˆ°UIï¼Œæ”¯æŒæµå¼æ›´æ–°å’Œå‹ç¼©æ¶ˆæ¯æ˜¾ç¤º
             * @param {string} speaker - å‘è¨€è€…
             * @param {string} content - æ¶ˆæ¯å†…å®¹
             * @param {boolean} isStreaming - æ˜¯å¦ä¸ºæµå¼æ›´æ–°
             * @param {string|null} messageId - æ¶ˆæ¯IDï¼Œç”¨äºæ›´æ–°ç°æœ‰æ¶ˆæ¯
             * @param {Object|null} messageData - å®Œæ•´çš„æ¶ˆæ¯æ•°æ®ï¼ˆåŒ…å«å‹ç¼©ä¿¡æ¯ï¼‰
             */
            addMessageToUI(speaker, content, isStreaming = false, messageId = null, messageData = null) {
                const messagesContainer = this.elements.chatMessages;

                if (messageId) {
                    // æ›´æ–°ç°æœ‰æ¶ˆæ¯
                    const existingMessage = document.getElementById(messageId);
                    if (existingMessage) {
                        const contentElement = existingMessage.querySelector('.message-content');
                        if (contentElement) {
                            // å¯¹äºæµå¼æ›´æ–°ï¼Œç›´æ¥è®¾ç½®æ–‡æœ¬ï¼Œé¿å…é‡å¤è§£æMarkdown
                            if (isStreaming) {
                                contentElement.textContent = content;
                            } else {
                                // æœ€ç»ˆå®Œæˆæ—¶è§£æMarkdown
                                contentElement.innerHTML = marked.parse(content);
                            }
                        }
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        return messageId;
                    }
                }

                // åˆ›å»ºæ–°æ¶ˆæ¯
                const newMessageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                const messageDiv = document.createElement('div');

                const isAIB = speaker === 'AI B';
                messageDiv.className = `message ${isAIB ? 'message-b' : 'message-a'}`;
                messageDiv.id = newMessageId;

                // å¦‚æœæ˜¯loadingçŠ¶æ€ï¼Œä½¿ç”¨ç‰¹æ®Šæ ·å¼
                if (content === '[æ€è€ƒä¸­...]' || content.includes('æ­£åœ¨')) {
                    messageDiv.classList.add('message-loading');
                }

                // æ£€æŸ¥æ˜¯å¦åº”è¯¥è·³è¿‡æ˜¾ç¤ºï¼ˆå¦‚æœè¿™æ¡æ¶ˆæ¯å·²ç»è¢«å‹ç¼©åˆ°æ‘˜è¦ä¸­ï¼‰
                if (this.shouldSkipMessage(speaker, content)) {
                    // ä¸æ˜¾ç¤ºè¿™æ¡æ¶ˆæ¯ï¼Œå› ä¸ºå®ƒå·²ç»è¢«åŒ…å«åœ¨å‹ç¼©æ‘˜è¦ä¸­
                    return null;
                }

                // æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦è¢«å‹ç¼©ï¼ˆä»conversationsæ•°ç»„ä¸­æŸ¥æ‰¾ï¼‰
                const isCompressedMessage = messageData && messageData.isCompressed && messageData.compressedContent;
                
                // æ„å»ºæ¶ˆæ¯å¤´éƒ¨ï¼ˆåŒ…å«å‹ç¼©æŒ‡ç¤ºå™¨ï¼‰
                let headerHTML = `<div class="message-header">${speaker}`;
                if (isCompressedMessage) {
                    // ä¸ºå‹ç¼©æ¶ˆæ¯æ·»åŠ å‹ç¼©å›¾æ ‡ï¼ˆä½†æ¶ˆæ¯å†…å®¹ä»æ˜¾ç¤ºå®Œæ•´ç‰ˆæœ¬ï¼‰
                    const originalLength = this.estimateTokens(messageData.content);
                    const compressedLength = this.estimateTokens(messageData.compressedContent);
                    const ratio = originalLength > 0 ? 
                        Math.round(((originalLength - compressedLength) / originalLength) * 100) : 0;
                    
                    headerHTML += `<span class="compression-indicator" onclick="window.aiDialogue.showCompressedContent('${newMessageId}')" title="ç‚¹å‡»æŸ¥çœ‹å‹ç¼©åçš„å†…å®¹">
                        <span class="compression-icon">ğŸ—œï¸</span>
                        <span>å·²å‹ç¼© ${ratio}%</span>
                    </span>`;
                }
                headerHTML += `</div>`;

                // æ„å»ºæ¶ˆæ¯å†…å®¹
                const contentHTML = `<div class="message-content">${isStreaming ? content : marked.parse(content)}</div>`;
                
                messageDiv.innerHTML = headerHTML + contentHTML;

                // å¦‚æœæ˜¯å‹ç¼©æ¶ˆæ¯ï¼Œå­˜å‚¨å‹ç¼©ç›¸å…³æ•°æ®
                if (isCompressedMessage && messageData.compressedContent) {
                    const originalLength = this.estimateTokens(messageData.content);
                    const compressedLength = this.estimateTokens(messageData.compressedContent);
                    
                    messageDiv.setAttribute('data-compressed-content', messageData.compressedContent);
                    messageDiv.setAttribute('data-compression-stats', JSON.stringify({
                        originalLength: originalLength,
                        compressedLength: compressedLength,
                        savedLength: originalLength - compressedLength,
                        ratio: `${Math.round(((originalLength - compressedLength) / originalLength) * 100)}%`,
                        compressionIndex: messageData.compressionIndex
                    }));
                }

                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;

                return newMessageId;
            }

            /**
             * æ·»åŠ loadingå ä½æ¶ˆæ¯
             * @param {string} speaker - å‘è¨€è€…
             * @return {string} æ¶ˆæ¯ID
             */
            addLoadingMessage(speaker) {
                const loadingContent = `
                    <div class="typing-indicator">
                        æ­£åœ¨æ€è€ƒä¸­
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                `;

                const messageId = this.addMessageToUI(speaker, '', true);

                // ç›´æ¥è®¾ç½®loadingå†…å®¹åˆ°contentåŒºåŸŸ
                const messageElement = document.getElementById(messageId);
                if (messageElement) {
                    const contentElement = messageElement.querySelector('.message-content');
                    if (contentElement) {
                        contentElement.innerHTML = loadingContent;
                    }
                }

                return messageId;
            }

            async startDialogue() {
                if (!this.validateConfiguration()) return;

                this.maxRounds = parseInt(this.elements.maxRounds.value) || 0;
                this.contextLimit = parseInt(this.elements.contextLimit.value) || 0; // æ–°å¢
                this.enableCompression = this.elements.enableCompression.checked;
                this.compressionRatio = parseFloat(this.elements.compressionRatio.value) || 0.5;
                this.keepRecentCount = parseInt(this.elements.keepRecentCount.value) || 5;
                this.retryCount = parseInt(this.elements.retryCount.value) || 3;
                this.retryDelay = parseInt(this.elements.retryDelay.value) * 1000 || 2000;

                this.isRunning = true;
                this.isPaused = false;
                this.needsReset = false;
                this.updateUI();

                await this.runDialogue();
            }

            pauseDialogue() {
                this.isPaused = true;
                this.updateUI();
            }

            resumeDialogue() {
                this.isPaused = false;
                if (this.needsReset) {
                    this.currentRound = 0;
                    this.needsReset = false;
                }

                // é‡æ–°è¯»å–æœ€æ–°çš„é…ç½®
                this.maxRounds = parseInt(this.elements.maxRounds.value) || 0;
                this.contextLimit = parseInt(this.elements.contextLimit.value) || 0;
                this.enableCompression = this.elements.enableCompression.checked;
                this.compressionRatio = parseFloat(this.elements.compressionRatio.value) || 0.5;
                this.keepRecentCount = parseInt(this.elements.keepRecentCount.value) || 5;
                this.retryCount = parseInt(this.elements.retryCount.value) || 3;
                this.retryDelay = parseInt(this.elements.retryDelay.value) * 1000 || 2000;

                this.updateNextSpeaker();
                this.updateUI();
                this.runDialogue();
            }

            updateNextSpeaker() {
                if (this.conversations.length === 0) {
                    this.nextSpeaker = 'B';
                    return;
                }

                const lastSpeaker = this.conversations[this.conversations.length - 1].speaker;

                if (lastSpeaker === 'AI A') {
                    this.nextSpeaker = 'B';
                } else {
                    this.nextSpeaker = 'A';
                }
            }

            stopDialogue() {
                this.isRunning = false;
                this.isPaused = false;
                // æ¸…é™¤å½“å‰æµå¼æ¶ˆæ¯ID
                this.currentStreamingMessageId = null;
                this.updateUI();
            }

            async sendOpeningMessage() {
                const message = this.elements.openingMessage.value.trim();
                if (!message) {
                    this.showMessage('è¯·è¾“å…¥å¼€åœºç™½', 'error');
                    return;
                }

                if (!this.validateConfiguration()) return;

                // æ¸…ç©ºä¹‹å‰çš„å¯¹è¯
                this.conversations = [];
                this.currentRound = 0;
                this.openingMessage = message;
                this.nextSpeaker = 'B';
                this.currentStreamingMessageId = null;

                this.elements.chatMessages.innerHTML = '';
                this.elements.openingMessage.value = '';

                // AI A æœ¬åœ°å‘å‡ºå¼€åœºç™½ï¼ˆä¸è°ƒç”¨APIï¼‰
                this.addMessageToUI('AI A', message);
                this.conversations.push({
                    role: 'assistant',
                    content: message,
                    speaker: 'AI A'
                });

                // è®¾ç½®å¯¹è¯å‚æ•°
                this.maxRounds = parseInt(this.elements.maxRounds.value) || 0;
                this.contextLimit = parseInt(this.elements.contextLimit.value) || 0; // æ–°å¢
                this.enableCompression = this.elements.enableCompression.checked;
                this.compressionRatio = parseFloat(this.elements.compressionRatio.value) || 0.5;
                this.keepRecentCount = parseInt(this.elements.keepRecentCount.value) || 5;
                this.retryCount = parseInt(this.elements.retryCount.value) || 3;
                this.retryDelay = parseInt(this.elements.retryDelay.value) * 1000 || 2000;

                // ç›´æ¥å¼€å§‹å¯¹è¯ï¼ŒAI B å“åº”
                this.isRunning = true;
                this.isPaused = false;
                this.needsReset = false;
                this.updateUI();

                await this.runDialogue();
            }

            async runDialogue() {
                while (this.isRunning && !this.isPaused) {
                    if (this.maxRounds > 0 && this.currentRound >= this.maxRounds) {
                        this.isPaused = true;
                        this.needsReset = true;
                        this.updateUI();
                        break;
                    }

                    const currentAI = this.nextSpeaker;
                    const success = await this.callAI(currentAI);

                    if (!success) {
                        this.isPaused = true;
                        this.updateUI();
                        break;
                    }

                    this.currentRound++;
                    this.updateRoundCounter();

                    // åˆ‡æ¢ä¸‹ä¸€ä¸ªå‘è¨€è€…
                    this.nextSpeaker = this.nextSpeaker === 'A' ? 'B' : 'A';

                    // æ·»åŠ å»¶è¿Ÿé¿å…è¿‡å¿«è¯·æ±‚
                    await this.sleep(1000);
                }
                
                // å¯¹è¯ç»“æŸåï¼Œæ›´æ–°æ‰€æœ‰æ¶ˆæ¯çš„å‹ç¼©å›¾æ ‡æ˜¾ç¤º
                this.updateAllCompressionIcons();
            }

            /**
             * æ›´æ–°æ‰€æœ‰æ¶ˆæ¯çš„å‹ç¼©å›¾æ ‡æ˜¾ç¤º
             */
            updateAllCompressionIcons() {
                console.log('ğŸ”„ å¼€å§‹æ›´æ–°æ‰€æœ‰å‹ç¼©å›¾æ ‡...');
                let compressedCount = 0;
                
                this.conversations.forEach((conv, index) => {
                    if (conv.isCompressed && conv.compressedContent) {
                        compressedCount++;
                        console.log(`ğŸ“ å‘ç°å‹ç¼©æ¶ˆæ¯ ${index}: ${conv.speaker}`);
                        setTimeout(() => {
                            this.updateMessageCompressionIcon(index);
                        }, index * 50); // é”™å¼€æ‰§è¡Œæ—¶é—´
                    }
                });
                
                console.log(`ğŸ“Š æ€»å…±æ‰¾åˆ° ${compressedCount} æ¡å‹ç¼©æ¶ˆæ¯`);
            }
            // ====== ä¿®å¤åçš„APIè°ƒç”¨æ–¹æ³• ======

            async callAI(aiType) {
                const config = this.getAIConfig(aiType);
                const messages = await this.buildMessages(aiType);

                this.currentRetries = 0;

                // æ·»åŠ loadingæ¶ˆæ¯
                const loadingMessageId = this.addLoadingMessage(`AI ${aiType}`);
                this.currentStreamingMessageId = loadingMessageId;

                while (this.currentRetries <= this.retryCount) {
                    try {
                        this.setStatus('è¿è¡Œä¸­', 'running');
                        const response = await this.makeAPIRequest(config, messages, `AI ${aiType}`, loadingMessageId);

                        if (response && response.content) {
                            // æµå¼å“åº”åœ¨makeAPIRequestä¸­å·²ç»å®æ—¶æ›´æ–°äº†UI
                            // è¿™é‡Œåªéœ€è¦æ·»åŠ åˆ°å¯¹è¯å†å²ä¸­
                            this.conversations.push({
                                role: 'assistant',
                                content: response.content,
                                speaker: `AI ${aiType}`
                            });

                            // åœ¨æ–°æ¶ˆæ¯æ·»åŠ åï¼Œæ£€æŸ¥å¹¶æ›´æ–°å‹ç¼©å›¾æ ‡
                            setTimeout(() => {
                                console.log('ğŸ†• æ–°æ¶ˆæ¯æ·»åŠ å®Œæˆï¼Œæ›´æ–°å‹ç¼©å›¾æ ‡');
                                this.updateAllCompressionIcons();
                            }, 500);

                            this.setStatus('å°±ç»ª', 'ready');
                            this.currentStreamingMessageId = null;
                            return true;
                        }

                        throw new Error('å“åº”å†…å®¹ä¸ºç©º');

                    } catch (error) {
                        console.error(`AI ${aiType} è°ƒç”¨å¤±è´¥:`, error);
                        this.currentRetries++;

                        if (this.currentRetries <= this.retryCount) {
                            // æ›´æ–°loadingæ¶ˆæ¯æ˜¾ç¤ºé‡è¯•ä¿¡æ¯
                            this.addMessageToUI(`AI ${aiType}`, `è°ƒç”¨å¤±è´¥ï¼Œ${this.retryDelay/1000}ç§’åé‡è¯• (${this.currentRetries}/${this.retryCount})`, true, loadingMessageId);
                            this.showMessage(`AI ${aiType} è°ƒç”¨å¤±è´¥ï¼Œ${this.retryDelay/1000}ç§’åé‡è¯• (${this.currentRetries}/${this.retryCount})`, 'error');
                            await this.sleep(this.retryDelay);
                        } else {
                            // é‡è¯•æ¬¡æ•°ç”¨å®Œï¼Œæ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
                            this.addMessageToUI(`AI ${aiType}`, `âŒ è°ƒç”¨å¤±è´¥ï¼Œå·²è¾¾é‡è¯•ä¸Šé™: ${error.message}`, false, loadingMessageId);
                            this.showMessage(`AI ${aiType} è°ƒç”¨å¤±è´¥ï¼Œå·²è¾¾é‡è¯•ä¸Šé™`, 'error');
                            this.setStatus('é”™è¯¯', 'stopped');
                            this.currentStreamingMessageId = null;
                            return false;
                        }
                    }
                }

                return false;
            }

            async makeAPIRequest(config, messages, speaker, messageId) {
                if (config.endpointType === 'openai') {
                    return await this.callOpenAI(config, messages, speaker, messageId);
                } else if (config.endpointType === 'gemini') {
                    return await this.callGemini(config, messages, speaker, messageId);
                }
            }

            async callOpenAI(config, messages, speaker, messageId) {
                // ä¿®å¤ï¼šå¦‚æœURLä»¥#ç»“å°¾ï¼Œå¼ºåˆ¶ä½¿ç”¨è¾“å…¥åœ°å€ï¼›å¦åˆ™è‡ªåŠ¨è¡¥å…¨
                let url;
                if (config.apiUrl.endsWith('#')) {
                    url = config.apiUrl.slice(0, -1); // å»æ‰æœ«å°¾çš„#
                } else if (config.apiUrl.endsWith('/v1/chat/completions')) {
                    url = config.apiUrl;
                } else {
                    url = `${config.apiUrl}/v1/chat/completions`;
                }

                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apiKey}`
                    },
                    body: JSON.stringify({
                        model: config.model,
                        messages: messages,
                        stream: true,
                        temperature: 0.7
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                return await this.handleOpenAIStreamResponse(response, speaker, messageId);
            }

            async callGemini(config, messages, speaker, messageId) {
                const url = `${config.apiUrl}/v1beta/models/${config.model}:streamGenerateContent?alt=sse&key=${config.apiKey}`;

                // è½¬æ¢æ¶ˆæ¯æ ¼å¼ä¸ºGeminiæ ¼å¼
                const contents = messages.filter(m => m.role !== 'system').map(m => ({
                    role: m.role === 'assistant' ? 'model' : 'user',
                    parts: [{ text: m.content }]
                }));

                const systemInstruction = messages.find(m => m.role === 'system');
                const requestBody = {
                    contents: contents,
                    generationConfig: {
                        temperature: 0.7
                    }
                };

                if (systemInstruction) {
                    requestBody.systemInstruction = {
                        parts: [{ text: systemInstruction.content }]
                    };
                }

                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorText}`);
                }

                return await this.handleGeminiStreamResponse(response, speaker, messageId);
            }

            // ä¿®å¤åçš„OpenAIæµå¼å“åº”å¤„ç†
            async handleOpenAIStreamResponse(response, speaker, messageId) {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let content = '';
                let isFirstChunk = true;

                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6).trim();
                                if (data === '[DONE]') continue;
                                if (!data) continue;

                                try {
                                    const parsed = JSON.parse(data);
                                    const delta = parsed.choices?.[0]?.delta?.content;
                                    if (delta) {
                                        content += delta;

                                        // å®æ—¶æ›´æ–°UI - ç¬¬ä¸€æ¬¡æ›´æ–°æ—¶æ¸…é™¤loadingçŠ¶æ€
                                        if (isFirstChunk) {
                                            // ç§»é™¤loadingæ ·å¼
                                            const messageElement = document.getElementById(messageId);
                                            if (messageElement) {
                                                messageElement.classList.remove('message-loading');
                                            }
                                            isFirstChunk = false;
                                        }

                                        // å®æ—¶æ›´æ–°æ¶ˆæ¯å†…å®¹
                                        this.addMessageToUI(speaker, content, true, messageId);
                                    }
                                } catch (e) {
                                    console.warn('è§£æOpenAIæµå¼å“åº”å¤±è´¥:', e, 'data:', data);
                                }
                            }
                        }
                    }
                } finally {
                    reader.releaseLock();
                }

                // æœ€ç»ˆå¤„ç†Markdown
                if (content) {
                    this.addMessageToUI(speaker, content, false, messageId);
                }

                return { content: content.trim() };
            }

            // ä¿®å¤åçš„Geminiæµå¼å“åº”å¤„ç† - è¿™æ˜¯å…³é”®ä¿®å¤
            async handleGeminiStreamResponse(response, speaker, messageId) {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let content = '';
                let buffer = '';
                let isFirstChunk = true;

                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value, { stream: true });
                        buffer += chunk;

                        // æŒ‰è¡Œåˆ†å‰²å¤„ç†
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || ''; // ä¿ç•™æœ€åä¸€ä¸ªå¯èƒ½ä¸å®Œæ•´çš„è¡Œ

                        for (const line of lines) {
                            if (line.trim() === '') continue;

                            // Geminiçš„æµå¼å“åº”æ ¼å¼é€šå¸¸æ˜¯ç›´æ¥çš„JSONï¼Œä¸éœ€è¦data:å‰ç¼€
                            try {
                                let jsonStr = line.trim();

                                // å¦‚æœè¡Œä»¥data:å¼€å¤´ï¼Œå»æ‰è¿™ä¸ªå‰ç¼€
                                if (jsonStr.startsWith('data: ')) {
                                    jsonStr = jsonStr.substring(6);
                                }

                                if (!jsonStr || jsonStr === '[DONE]') continue;

                                const parsed = JSON.parse(jsonStr);

                                // Gemini APIçš„æ ‡å‡†å“åº”ç»“æ„
                                const text = parsed.candidates?.[0]?.content?.parts?.[0]?.text;

                                if (text) {
                                    content += text;

                                    // å®æ—¶æ›´æ–°UI - ç¬¬ä¸€æ¬¡æ›´æ–°æ—¶æ¸…é™¤loadingçŠ¶æ€
                                    if (isFirstChunk) {
                                        const messageElement = document.getElementById(messageId);
                                        if (messageElement) {
                                            messageElement.classList.remove('message-loading');
                                        }
                                        isFirstChunk = false;
                                    }

                                    // å®æ—¶æ›´æ–°æ¶ˆæ¯å†…å®¹
                                    this.addMessageToUI(speaker, content, true, messageId);
                                }
                            } catch (e) {
                                // å¿½ç•¥JSONè§£æé”™è¯¯ï¼Œç»§ç»­å¤„ç†ä¸‹ä¸€è¡Œ
                                console.warn('è§£æGeminiæµå¼å“åº”å¤±è´¥:', e, 'line:', line);
                            }
                        }
                    }

                    // å¤„ç†bufferä¸­å‰©ä½™çš„å†…å®¹
                    if (buffer.trim()) {
                        try {
                            let jsonStr = buffer.trim();
                            if (jsonStr.startsWith('data: ')) {
                                jsonStr = jsonStr.substring(6);
                            }

                            if (jsonStr && jsonStr !== '[DONE]') {
                                const parsed = JSON.parse(jsonStr);
                                const text = parsed.candidates?.[0]?.content?.parts?.[0]?.text;
                                if (text) {
                                    content += text;
                                    this.addMessageToUI(speaker, content, true, messageId);
                                }
                            }
                        } catch (e) {
                            console.warn('è§£æGeminiæµå¼å“åº”å‰©ä½™å†…å®¹å¤±è´¥:', e);
                        }
                    }

                } finally {
                    reader.releaseLock();
                }

                // æœ€ç»ˆå¤„ç†Markdown
                if (content) {
                    this.addMessageToUI(speaker, content, false, messageId);
                } else {
                    // å¦‚æœæ²¡æœ‰æ”¶åˆ°ä»»ä½•å†…å®¹ï¼Œæ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                    this.addMessageToUI(speaker, 'âŒ æœªæ”¶åˆ°å“åº”å†…å®¹', false, messageId);
                    throw new Error('Gemini APIæœªè¿”å›ä»»ä½•å†…å®¹');
                }

                return { content: content.trim() };
            }
            // ====== è¾…åŠ©æ–¹æ³•å’Œäº‹ä»¶å¤„ç† ======

            getAIConfig(aiType) {
                return {
                    endpointType: this.elements[`endpointType${aiType}`].value,
                    apiUrl: this.elements[`apiUrl${aiType}`].value,
                    apiKey: this.elements[`apiKey${aiType}`].value,
                    model: this.elements[`model${aiType}`].value,
                    prompt: this.elements[`prompt${aiType}`].value
                };
            }

            /**
             * æ„å»ºAPIè¯·æ±‚çš„æ¶ˆæ¯æ•°ç»„ï¼Œæ”¯æŒä¸Šä¸‹æ–‡é™åˆ¶
             * @param {string} aiType - AIç±»å‹ ('A' æˆ– 'B')
             * @returns {Array} æ¶ˆæ¯æ•°ç»„
             */
            async buildMessages(aiType) {
                const config = this.getAIConfig(aiType);
                const messages = [];

                // æ·»åŠ ç³»ç»Ÿæç¤ºè¯
                if (config.prompt) {
                    messages.push({
                        role: 'system',
                        content: config.prompt
                    });
                }

                // è·å–éœ€è¦å‘é€çš„å¯¹è¯å†å²
                let conversationsToSend = this.conversations;

                // é¦–å…ˆåº”ç”¨æ™ºèƒ½å‹ç¼©ï¼ˆå¦‚æœå¯ç”¨ï¼‰
                if (this.enableCompression && conversationsToSend.length > this.keepRecentCount) {
                    conversationsToSend = await this.compressConversations([...conversationsToSend]);
                }

                // ç„¶ååº”ç”¨ä¸Šä¸‹æ–‡é™åˆ¶
                if (this.contextLimit > 0 && conversationsToSend.length > this.contextLimit) {
                    // å–æœ€è¿‘çš„ contextLimit æ¡æ¶ˆæ¯
                    conversationsToSend = conversationsToSend.slice(-this.contextLimit);
                    
                    // åœ¨UIä¸­æ˜¾ç¤ºä¸Šä¸‹æ–‡æˆªæ–­ä¿¡æ¯ï¼ˆä»…åœ¨ç¬¬ä¸€æ¬¡æˆªæ–­æ—¶ï¼‰
                    if (this.conversations.length === this.contextLimit + 1) {
                        this.addSystemMessage(`ğŸ“‹ å¯ç”¨ä¸Šä¸‹æ–‡é™åˆ¶ï¼šä»…ä½¿ç”¨æœ€è¿‘ ${this.contextLimit} æ¡æ¶ˆæ¯`, 'info');
                    }
                }

                // æ„å»ºäº¤æ›¿çš„ç”¨æˆ·/åŠ©æ‰‹å¯¹è¯
                // ä»å½“å‰AIçš„è§’åº¦çœ‹ï¼Œå¯¹æ–¹éƒ½æ˜¯userï¼Œè‡ªå·±æ˜¯assistant
                for (let i = 0; i < conversationsToSend.length; i++) {
                    const conv = conversationsToSend[i];
                    const speakerType = conv.speaker === `AI ${aiType}` ? 'assistant' : 'user';

                    messages.push({
                        role: speakerType,
                        content: conv.content
                    });
                }

                // åœ¨æ§åˆ¶å°è¾“å‡ºdebugä¿¡æ¯
                console.log(`AI ${aiType} å‘é€æ¶ˆæ¯æ•°é‡: ${messages.length}`, {
                    ç³»ç»Ÿæ¶ˆæ¯: messages.filter(m => m.role === 'system').length,
                    å¯¹è¯æ¶ˆæ¯: messages.filter(m => m.role !== 'system').length,
                    æ€»å¯¹è¯æ¡æ•°: this.conversations.length,
                    å‘é€å¯¹è¯æ¡æ•°: conversationsToSend.length,
                    ä¸Šä¸‹æ–‡é™åˆ¶: this.contextLimit || 'æ— é™åˆ¶',
                    AIæ™ºèƒ½å‹ç¼©: this.enableCompression ? 'å·²å¯ç”¨' : 'æœªå¯ç”¨',
                    ä¿æŠ¤æœ€è¿‘æ¶ˆæ¯: this.keepRecentCount,
                    å‹ç¼©ç»Ÿè®¡: this.compressionStats
                });

                return messages;
            }

            validateConfiguration() {
                const requiredFields = ['apiUrlA', 'apiKeyA', 'modelA', 'apiUrlB', 'apiKeyB', 'modelB'];

                for (const field of requiredFields) {
                    if (!this.elements[field].value.trim()) {
                        this.showMessage(`è¯·å¡«å†™å®Œæ•´çš„é…ç½®ä¿¡æ¯: ${field}`, 'error');
                        return false;
                    }
                }

                // å¦‚æœå¯ç”¨AIå‹ç¼©ï¼ŒéªŒè¯ç³»ç»ŸAIé…ç½®
                if (this.enableCompression) {
                    const systemFields = ['apiUrlSystem', 'apiKeySystem', 'modelSystem'];
                    for (const field of systemFields) {
                        if (!this.elements[field].value.trim()) {
                            this.showMessage(`AIå‹ç¼©éœ€è¦å®Œæ•´çš„ç³»ç»ŸAIé…ç½®: ${field}`, 'error');
                            return false;
                        }
                    }
                }

                return true;
            }

            setStatus(text, type) {
                this.elements.statusIndicator.textContent = text;
                this.elements.statusIndicator.className = `status-indicator status-${type}`;
            }

            updateRoundCounter() {
                this.elements.roundCounter.textContent = this.currentRound;
            }

            updateUI() {
                const isRunning = this.isRunning && !this.isPaused;
                const isStopped = !this.isRunning;
                const isPaused = this.isPaused;

                this.elements.startChat.style.display = isStopped ? 'inline-block' : 'none';
                this.elements.pauseChat.style.display = isRunning ? 'inline-block' : 'none';
                this.elements.resumeChat.style.display = isPaused ? 'inline-block' : 'none';
                this.elements.retryChat.style.display = isPaused ? 'inline-block' : 'none';

                // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
                if (isRunning) {
                    this.setStatus('è¿è¡Œä¸­', 'running');
                } else if (isPaused) {
                    this.setStatus('æš‚åœ', 'stopped');
                } else {
                    this.setStatus('å°±ç»ª', 'ready');
                }
            }

            async retryLastRequest() {
                if (this.isPaused) {
                    // é‡è¯•æ—¶ä¹Ÿéœ€è¦æ›´æ–°ä¸‹ä¸€ä¸ªå‘è¨€è€…
                    this.updateNextSpeaker();
                    this.resumeDialogue();
                }
            }

            exportDialogue() {
                let exportText = '# AIåŒäººå¯¹è¯è®°å½•\n\n';
                exportText += `å¯¼å‡ºæ—¶é—´: ${new Date().toLocaleString()}\n`;
                exportText += `æ€»è½®æ¬¡: ${this.currentRound}\n`;
                exportText += `ä¸Šä¸‹æ–‡é™åˆ¶: ${this.contextLimit || 'æ— é™åˆ¶'}\n`;
                exportText += `AIæ™ºèƒ½å‹ç¼©: ${this.enableCompression ? 'å·²å¯ç”¨' : 'æœªå¯ç”¨'}\n`;
                if (this.enableCompression) {
                    exportText += `å‹ç¼©å¼ºåº¦: ${(this.compressionRatio * 100).toFixed(0)}%\n`;
                    exportText += `ä¿æŠ¤æœ€è¿‘: ${this.keepRecentCount}æ¡æ¶ˆæ¯\n`;
                    if (this.compressionStats.compressionCount > 0) {
                        const totalSaved = this.compressionStats.originalTokens - this.compressionStats.compressedTokens;
                        const savedPercentage = ((totalSaved / this.compressionStats.originalTokens) * 100).toFixed(1);
                        const netSaved = totalSaved - this.compressionStats.aiCompressionTokens;
                        exportText += `TokenèŠ‚çœ: ${totalSaved} (${savedPercentage}%)\n`;
                        exportText += `AIå‹ç¼©æˆæœ¬: ${this.compressionStats.aiCompressionTokens} tokens\n`;
                        exportText += `å‡€èŠ‚çœ: ${netSaved} tokens\n`;
                    }
                }
                exportText += '\n';

                this.conversations.forEach((conv, index) => {
                    exportText += `## ${conv.speaker}\n\n${conv.content}\n\n`;
                });

                const blob = new Blob([exportText], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ai_dialogue_${new Date().getTime()}.txt`;
                a.click();
                URL.revokeObjectURL(url);
            }

            clearDialogue() {
                if (confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰å¯¹è¯è®°å½•å—ï¼Ÿ')) {
                    this.conversations = [];
                    this.currentRound = 0;
                    this.isRunning = false;
                    this.isPaused = false;
                    this.openingMessage = '';
                    this.nextSpeaker = 'B';
                    this.currentStreamingMessageId = null;
                    
                    // é‡ç½®å‹ç¼©ç»Ÿè®¡å’Œç¼“å­˜
                    this.compressedMessages = [];
                    this.compressionCache.clear();
                    this.lastCompressionIndex = 0;
                    this.compressionStats = {
                        originalTokens: 0,
                        compressedTokens: 0,
                        compressionCount: 0,
                        aiCompressionTokens: 0
                    };

                    this.elements.chatMessages.innerHTML = `
                        <div style="text-align: center; color: #666; margin-top: 50px;">
                            <h3>æ¬¢è¿ä½¿ç”¨AIåŒäººå¯¹è¯ç³»ç»Ÿ</h3>
                            <p>è¯·å…ˆé…ç½®AIå‚æ•°ï¼Œç„¶åè¾“å…¥å¼€åœºç™½å¼€å§‹å¯¹è¯</p>
                        </div>
                    `;

                    this.updateRoundCounter();
                    this.updateUI();
                    this.updateCompressionStatsUI();
                }
            }

            // æ”¹è¿›çš„æ¶ˆæ¯æ˜¾ç¤ºæ–¹æ³•
            showMessage(message, type) {
                // åœ¨èŠå¤©ç•Œé¢æ˜¾ç¤ºæ¶ˆæ¯è€Œä¸æ˜¯å¼¹å‡ºæ¡†
                if (type === 'error') {
                    this.addSystemMessage(`âŒ ${message}`, 'error');
                } else if (type === 'success') {
                    this.addSystemMessage(`âœ… ${message}`, 'success');
                } else {
                    this.addSystemMessage(`â„¹ï¸ ${message}`, 'info');
                }
            }

            // æ–°å¢ç³»ç»Ÿæ¶ˆæ¯æ˜¾ç¤ºæ–¹æ³•
            addSystemMessage(message, type = 'info') {
                const messagesContainer = this.elements.chatMessages;
                const messageDiv = document.createElement('div');

                const colorMap = {
                    'error': '#e74c3c',
                    'success': '#27ae60',
                    'info': '#3498db'
                };

                messageDiv.style.cssText = `
                    margin: 10px 0;
                    padding: 8px 12px;
                    border-radius: 4px;
                    background: rgba(${type === 'error' ? '231, 76, 60' : type === 'success' ? '39, 174, 96' : '52, 152, 219'}, 0.1);
                    border-left: 3px solid ${colorMap[type]};
                    color: ${colorMap[type]};
                    font-size: 13px;
                    text-align: center;
                `;

                messageDiv.textContent = message;
                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            /**
             * æ£€æŸ¥æ˜¯å¦åº”è¯¥è·³è¿‡æ˜¾ç¤ºè¿™æ¡æ¶ˆæ¯ï¼ˆå› ä¸ºå·²è¢«å‹ç¼©åˆ°æ‘˜è¦ä¸­ï¼‰
             * @param {string} speaker - å‘è¨€è€…
             * @param {string} content - æ¶ˆæ¯å†…å®¹
             * @returns {boolean} æ˜¯å¦åº”è¯¥è·³è¿‡æ˜¾ç¤º
             */
            shouldSkipMessage(speaker, content) {
                // æ£€æŸ¥conversationsæ•°ç»„ä¸­æ˜¯å¦æœ‰å‹ç¼©æ‘˜è¦æ¶ˆæ¯åŒ…å«è¿™æ¡åŸå§‹æ¶ˆæ¯
                const compressedMessage = this.conversations.find(conv => 
                    (conv.aiCompressed || conv.batchCompressed) &&
                    conv.originalMessages &&
                    conv.originalMessages.some(orig => 
                        orig.speaker === speaker && orig.content === content
                    )
                );
                
                return !!compressedMessage;
            }

            /**
             * è·å–æ¶ˆæ¯çš„å‹ç¼©ä¿¡æ¯ï¼ˆåŸºäºåŸå§‹æ¶ˆæ¯æŸ¥æ‰¾å¯¹åº”çš„å‹ç¼©æ¶ˆæ¯ï¼‰
             * @param {string} speaker - å‘è¨€è€…
             * @param {string} content - æ¶ˆæ¯å†…å®¹
             * @param {Object} messageData - æ¶ˆæ¯æ•°æ®
             * @returns {Object} å‹ç¼©ä¿¡æ¯
             */
            getCompressionInfoForMessage(speaker, content, messageData) {
                // æŸ¥æ‰¾åŒ…å«è¿™æ¡åŸå§‹æ¶ˆæ¯çš„å‹ç¼©æ¶ˆæ¯
                const compressedMessage = this.conversations.find(conv => 
                    (conv.aiCompressed || conv.batchCompressed) &&
                    conv.originalMessages &&
                    conv.originalMessages.some(orig => 
                        orig.speaker === speaker && orig.content === content
                    )
                );
                
                if (!compressedMessage) {
                    return { ratio: '0%', originalLength: 0, compressedLength: 0 };
                }
                
                const originalLength = compressedMessage.originalLength || 0;
                const compressedLength = compressedMessage.compressedLength || 0;
                const savedLength = originalLength - compressedLength;
                const ratio = originalLength > 0 ? Math.round((savedLength / originalLength) * 100) : 0;
                
                return {
                    originalLength,
                    compressedLength,
                    savedLength,
                    ratio: `${ratio}%`,
                    batchSize: compressedMessage.batchSize || 1,
                    compressionLevel: compressedMessage.compressionLevel || 0.5,
                    compressedContent: compressedMessage.compressedContent || compressedMessage.content
                };
            }

            /**
             * è·å–å‹ç¼©åçš„å†…å®¹ï¼ˆåŸºäºåŸå§‹æ¶ˆæ¯æŸ¥æ‰¾ï¼‰
             * @param {string} speaker - å‘è¨€è€…
             * @param {string} content - æ¶ˆæ¯å†…å®¹
             * @param {Object} messageData - æ¶ˆæ¯æ•°æ®
             * @returns {string} å‹ç¼©åçš„å†…å®¹
             */
            getCompressedContentForMessage(speaker, content, messageData) {
                // æŸ¥æ‰¾åŒ…å«è¿™æ¡åŸå§‹æ¶ˆæ¯çš„å‹ç¼©æ¶ˆæ¯
                const compressedMessage = this.conversations.find(conv => 
                    (conv.aiCompressed || conv.batchCompressed) &&
                    conv.originalMessages &&
                    conv.originalMessages.some(orig => 
                        orig.speaker === speaker && orig.content === content
                    )
                );
                
                return compressedMessage?.compressedContent || compressedMessage?.content || null;
            }

            /**
             * æ˜¾ç¤ºå‹ç¼©åçš„å†…å®¹
             * @param {string} messageId - æ¶ˆæ¯ID
             */
            showCompressedContent(messageId) {
                const messageElement = document.getElementById(messageId);
                if (!messageElement) return;

                const compressedContent = messageElement.getAttribute('data-compressed-content');
                const compressionStatsData = messageElement.getAttribute('data-compression-stats');
                
                if (!compressedContent) {
                    this.showMessage('æœªæ‰¾åˆ°å‹ç¼©å†…å®¹', 'error');
                    return;
                }

                try {
                    const compressionStats = JSON.parse(compressionStatsData || '{}');
                    
                    // è·å–åŸå§‹æ¶ˆæ¯å†…å®¹
                    const originalContent = messageElement.querySelector('.message-content').textContent;
                    
                    this.createCompressedContentPopup(originalContent, compressedContent, compressionStats);
                } catch (error) {
                    console.error('è§£æå‹ç¼©æ•°æ®å¤±è´¥:', error);
                    this.showMessage('å‹ç¼©æ•°æ®æ ¼å¼é”™è¯¯', 'error');
                }
            }

            /**
             * åˆ›å»ºå‹ç¼©å†…å®¹å¯¹æ¯”å¼¹çª—
             * @param {string} originalContent - åŸå§‹å†…å®¹
             * @param {string} compressedContent - å‹ç¼©å†…å®¹
             * @param {Object} compressionStats - å‹ç¼©ç»Ÿè®¡
             */
            createCompressedContentPopup(originalContent, compressedContent, compressionStats) {
                // ç§»é™¤ç°æœ‰å¼¹çª—
                this.closeOriginalMessagesPopup();

                // åˆ›å»ºé®ç½©å±‚
                const overlay = document.createElement('div');
                overlay.className = 'popup-overlay';
                overlay.onclick = () => this.closeOriginalMessagesPopup();

                // åˆ›å»ºå¼¹çª—
                const popup = document.createElement('div');
                popup.className = 'original-content-popup';
                popup.id = 'originalMessagesPopup';
                popup.style.maxWidth = '90%';

                // å¼¹çª—å¤´éƒ¨
                const header = document.createElement('div');
                header.className = 'popup-header';
                header.innerHTML = `
                    <h3 class="popup-title">å‹ç¼©å†…å®¹å¯¹æ¯”</h3>
                    <button class="popup-close" onclick="window.aiDialogue.closeOriginalMessagesPopup()">Ã—</button>
                `;

                // å¼¹çª—å†…å®¹
                const content = document.createElement('div');
                content.className = 'popup-content';
                content.innerHTML = `
                    <div style="display: flex; gap: 20px; margin-bottom: 15px;">
                        <div style="flex: 1;">
                            <h4 style="color: #2c3e50; margin-bottom: 10px;">ğŸ“„ åŸå§‹å†…å®¹</h4>
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; border-left: 4px solid #3498db; max-height: 300px; overflow-y: auto;">
                                ${marked.parse(originalContent)}
                            </div>
                        </div>
                        <div style="flex: 1;">
                            <h4 style="color: #e67e22; margin-bottom: 10px;">ğŸ—œï¸ å‹ç¼©å†…å®¹</h4>
                            <div style="background: #fff3cd; padding: 15px; border-radius: 6px; border-left: 4px solid #f39c12; max-height: 300px; overflow-y: auto;">
                                ${marked.parse(compressedContent)}
                            </div>
                        </div>
                    </div>
                `;

                // æ˜¾ç¤ºå‹ç¼©ç»Ÿè®¡
                if (compressionStats.originalLength) {
                    const statsDiv = document.createElement('div');
                    statsDiv.className = 'compression-stats';
                    statsDiv.innerHTML = `
                        <strong>ğŸ“Š å‹ç¼©ç»Ÿè®¡ï¼š</strong><br>
                        åŸå§‹é•¿åº¦: ${compressionStats.originalLength} tokens<br>
                        å‹ç¼©åé•¿åº¦: ${compressionStats.compressedLength} tokens<br>
                        èŠ‚çœç©ºé—´: ${compressionStats.savedLength} tokens (${compressionStats.ratio})<br>
                        <em>æ³¨ï¼šUIä¸­æ˜¾ç¤ºå®Œæ•´å†…å®¹ï¼ŒAPIè°ƒç”¨æ—¶ä½¿ç”¨å‹ç¼©å†…å®¹</em>
                    `;
                    content.appendChild(statsDiv);
                }

                popup.appendChild(header);
                popup.appendChild(content);

                document.body.appendChild(overlay);
                document.body.appendChild(popup);

                // æ˜¾ç¤ºå¼¹çª—
                setTimeout(() => {
                    overlay.style.display = 'block';
                    popup.style.display = 'block';
                }, 10);

                // ESCé”®å…³é—­
                const handleEsc = (e) => {
                    if (e.key === 'Escape') {
                        this.closeOriginalMessagesPopup();
                        document.removeEventListener('keydown', handleEsc);
                    }
                };
                document.addEventListener('keydown', handleEsc);
            }

            /**
             * æ˜¾ç¤ºåŸå§‹æ¶ˆæ¯å¼¹çª—
             * @param {string} messageId - æ¶ˆæ¯ID
             */
            showOriginalMessages(messageId) {
                const messageElement = document.getElementById(messageId);
                if (!messageElement) return;

                const originalMessagesData = messageElement.getAttribute('data-original-messages');
                const compressionStatsData = messageElement.getAttribute('data-compression-stats');
                const contextMessagesData = messageElement.getAttribute('data-context-messages');
                
                if (!originalMessagesData) {
                    this.showMessage('æœªæ‰¾åˆ°åŸå§‹æ¶ˆæ¯æ•°æ®', 'error');
                    return;
                }

                try {
                    const originalMessages = JSON.parse(originalMessagesData);
                    const compressionStats = JSON.parse(compressionStatsData || '{}');
                    const contextMessages = contextMessagesData ? JSON.parse(contextMessagesData) : null;
                    
                    this.createOriginalMessagesPopup(originalMessages, compressionStats, contextMessages);
                } catch (error) {
                    console.error('è§£æåŸå§‹æ¶ˆæ¯æ•°æ®å¤±è´¥:', error);
                    this.showMessage('åŸå§‹æ¶ˆæ¯æ•°æ®æ ¼å¼é”™è¯¯', 'error');
                }
            }

            /**
             * åˆ›å»ºåŸå§‹æ¶ˆæ¯å¼¹çª—
             * @param {Array} originalMessages - åŸå§‹æ¶ˆæ¯æ•°ç»„
             * @param {Object} compressionStats - å‹ç¼©ç»Ÿè®¡
             * @param {Array} contextMessages - ä¸Šä¸‹æ–‡æ¶ˆæ¯æ•°ç»„ï¼ˆå¯é€‰ï¼‰
             */
            createOriginalMessagesPopup(originalMessages, compressionStats, contextMessages = null) {
                // ç§»é™¤ç°æœ‰å¼¹çª—
                this.closeOriginalMessagesPopup();

                // åˆ›å»ºé®ç½©å±‚
                const overlay = document.createElement('div');
                overlay.className = 'popup-overlay';
                overlay.onclick = () => this.closeOriginalMessagesPopup();

                // åˆ›å»ºå¼¹çª—
                const popup = document.createElement('div');
                popup.className = 'original-content-popup';
                popup.id = 'originalMessagesPopup';

                // å¼¹çª—å¤´éƒ¨
                const header = document.createElement('div');
                header.className = 'popup-header';
                const totalMessages = originalMessages.length + (contextMessages ? contextMessages.length : 0);
                header.innerHTML = `
                    <h3 class="popup-title">å‹ç¼©ç›¸å…³æ¶ˆæ¯ (${totalMessages}æ¡${contextMessages ? 'ï¼Œå«' + contextMessages.length + 'æ¡ä¸Šä¸‹æ–‡' : ''})</h3>
                    <button class="popup-close" onclick="window.aiDialogue.closeOriginalMessagesPopup()">Ã—</button>
                `;

                // å¼¹çª—å†…å®¹
                const content = document.createElement('div');
                content.className = 'popup-content';

                // æ˜¾ç¤ºä¸Šä¸‹æ–‡æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                if (contextMessages && contextMessages.length > 0) {
                    const contextTitle = document.createElement('div');
                    contextTitle.innerHTML = '<h4 style="color: #666; margin: 15px 0 10px 0;">ğŸ“– ä¸Šä¸‹æ–‡æ¶ˆæ¯ï¼ˆç”¨äºç†è§£è¯­å¢ƒï¼‰</h4>';
                    content.appendChild(contextTitle);
                    
                    contextMessages.forEach((msg, index) => {
                        const msgDiv = document.createElement('div');
                        msgDiv.className = 'original-message';
                        msgDiv.style.opacity = '0.7';
                        msgDiv.innerHTML = `
                            <div class="original-message-header">${msg.speaker} (ä¸Šä¸‹æ–‡ ${index + 1})</div>
                            <div class="original-message-content">${marked.parse(msg.content)}</div>
                        `;
                        content.appendChild(msgDiv);
                    });
                }

                // æ˜¾ç¤ºåŸå§‹æ¶ˆæ¯ï¼ˆè¢«å‹ç¼©çš„ç›®æ ‡æ¶ˆæ¯ï¼‰
                if (contextMessages && contextMessages.length > 0) {
                    const originalTitle = document.createElement('div');
                    originalTitle.innerHTML = '<h4 style="color: #e74c3c; margin: 15px 0 10px 0;">ğŸ¯ è¢«å‹ç¼©çš„ç›®æ ‡æ¶ˆæ¯</h4>';
                    content.appendChild(originalTitle);
                }

                originalMessages.forEach((msg, index) => {
                    const msgDiv = document.createElement('div');
                    msgDiv.className = 'original-message';
                    if (contextMessages && contextMessages.length > 0) {
                        msgDiv.style.borderLeft = '4px solid #e74c3c';
                    }
                    msgDiv.innerHTML = `
                        <div class="original-message-header">${msg.speaker} ${contextMessages ? '(ç›®æ ‡æ¶ˆæ¯)' : '(ç¬¬' + (index + 1) + 'æ¡)'}</div>
                        <div class="original-message-content">${marked.parse(msg.content)}</div>
                    `;
                    content.appendChild(msgDiv);
                });

                // æ˜¾ç¤ºå‹ç¼©ç»Ÿè®¡
                if (compressionStats.originalLength) {
                    const statsDiv = document.createElement('div');
                    statsDiv.className = 'compression-stats';
                    const compressionType = compressionStats.batchSize > 1 ? 'æ‰¹é‡å‹ç¼©' : 'å•æ¡å‹ç¼©';
                    statsDiv.innerHTML = `
                        <strong>ğŸ“Š å‹ç¼©ç»Ÿè®¡ï¼š</strong><br>
                        å‹ç¼©æ–¹å¼: ${compressionType}<br>
                        åŸå§‹é•¿åº¦: ${compressionStats.originalLength} å­—ç¬¦<br>
                        å‹ç¼©åé•¿åº¦: ${compressionStats.compressedLength} å­—ç¬¦<br>
                        èŠ‚çœç©ºé—´: ${compressionStats.savedLength} å­—ç¬¦ (${compressionStats.ratio})<br>
                        ${compressionStats.batchSize > 1 ? 'åˆå¹¶æ¶ˆæ¯æ•°: ' + compressionStats.batchSize + ' æ¡' : ''}
                    `;
                    content.appendChild(statsDiv);
                }

                popup.appendChild(header);
                popup.appendChild(content);

                document.body.appendChild(overlay);
                document.body.appendChild(popup);

                // æ˜¾ç¤ºå¼¹çª—
                setTimeout(() => {
                    overlay.style.display = 'block';
                    popup.style.display = 'block';
                }, 10);

                // ESCé”®å…³é—­
                const handleEsc = (e) => {
                    if (e.key === 'Escape') {
                        this.closeOriginalMessagesPopup();
                        document.removeEventListener('keydown', handleEsc);
                    }
                };
                document.addEventListener('keydown', handleEsc);
            }

            /**
             * å…³é—­åŸå§‹æ¶ˆæ¯å¼¹çª—
             */
            closeOriginalMessagesPopup() {
                const overlay = document.querySelector('.popup-overlay');
                const popup = document.getElementById('originalMessagesPopup');
                
                if (overlay) overlay.remove();
                if (popup) popup.remove();
            }

            /**
             * é‡æ–°æ¸²æŸ“æ‰€æœ‰æ¶ˆæ¯ï¼ˆåŒ…æ‹¬å‹ç¼©æ¶ˆæ¯çš„å¯è§†åŒ–ï¼‰
             */
            rerenderAllMessages() {
                const messagesContainer = this.elements.chatMessages;
                messagesContainer.innerHTML = '';

                this.conversations.forEach((conv, index) => {
                    // å§‹ç»ˆæ˜¾ç¤ºå®Œæ•´æ¶ˆæ¯å†…å®¹ï¼Œä½†ä¼ é€’å‹ç¼©ä¿¡æ¯ç”¨äºæ˜¾ç¤ºå›¾æ ‡
                    const messageId = this.addMessageToUI(conv.speaker, conv.content, false, null, conv);
                });

                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            /**
             * æ›´æ–°æ¶ˆæ¯çš„å‹ç¼©å›¾æ ‡æ˜¾ç¤º
             * @param {number} messageIndex - æ¶ˆæ¯åœ¨conversationsæ•°ç»„ä¸­çš„ç´¢å¼•
             */
            updateMessageCompressionIcon(messageIndex) {
                if (messageIndex < 0 || messageIndex >= this.conversations.length) return;
                
                const conv = this.conversations[messageIndex];
                if (!conv.isCompressed || !conv.compressedContent) return;
                
                console.log(`ğŸ” å°è¯•ä¸ºæ¶ˆæ¯ ${messageIndex} æ·»åŠ å‹ç¼©å›¾æ ‡:`, conv.speaker);
                
                // æŸ¥æ‰¾å¯¹åº”çš„æ¶ˆæ¯å…ƒç´ ï¼ˆé€šè¿‡ä½ç½®å’Œå‘è¨€è€…åŒ¹é…ï¼‰
                const messageElements = document.querySelectorAll('.message');
                let targetElement = null;
                let matchCount = 0;
                
                // å…ˆæŒ‰å‘è¨€è€…ç­›é€‰ï¼Œç„¶åæŒ‰ä½ç½®åŒ¹é…
                for (let i = 0; i < messageElements.length; i++) {
                    const element = messageElements[i];
                    const headerElement = element.querySelector('.message-header');
                    
                    if (headerElement) {
                        const headerText = headerElement.textContent.trim();
                        
                        // æ£€æŸ¥å‘è¨€è€…æ˜¯å¦åŒ¹é…
                        if (headerText.includes(conv.speaker)) {
                            // å¦‚æœè¿™æ˜¯ç¬¬messageIndexä¸ªåŒ¹é…çš„å…ƒç´ ï¼Œå°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„
                            let speakerMatchIndex = 0;
                            for (let j = 0; j < this.conversations.length; j++) {
                                if (this.conversations[j].speaker === conv.speaker) {
                                    if (j === messageIndex) {
                                        break;
                                    }
                                    speakerMatchIndex++;
                                }
                            }
                            
                            if (matchCount === speakerMatchIndex) {
                                targetElement = element;
                                break;
                            }
                            matchCount++;
                        }
                    }
                }
                
                if (targetElement) {
                    const headerElement = targetElement.querySelector('.message-header');
                    
                    // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰å‹ç¼©å›¾æ ‡
                    if (!headerElement.querySelector('.compression-indicator')) {
                        console.log(`âœ… ä¸ºæ¶ˆæ¯ ${messageIndex} æ·»åŠ å‹ç¼©å›¾æ ‡`);
                        
                        // æ·»åŠ å‹ç¼©å›¾æ ‡
                        const originalLength = this.estimateTokens(conv.content);
                        const compressedLength = this.estimateTokens(conv.compressedContent);
                        const ratio = originalLength > 0 ? 
                            Math.round(((originalLength - compressedLength) / originalLength) * 100) : 0;
                        
                        const compressionIndicator = document.createElement('span');
                        compressionIndicator.className = 'compression-indicator';
                        compressionIndicator.onclick = () => this.showCompressedContent(targetElement.id);
                        compressionIndicator.title = 'ç‚¹å‡»æŸ¥çœ‹å‹ç¼©åçš„å†…å®¹';
                        compressionIndicator.innerHTML = `
                            <span class="compression-icon">ğŸ—œï¸</span>
                            <span>å·²å‹ç¼© ${ratio}%</span>
                        `;
                        
                        headerElement.appendChild(compressionIndicator);
                        
                        // å­˜å‚¨å‹ç¼©ç›¸å…³æ•°æ®
                        targetElement.setAttribute('data-compressed-content', conv.compressedContent);
                        targetElement.setAttribute('data-compression-stats', JSON.stringify({
                            originalLength: originalLength,
                            compressedLength: compressedLength,
                            savedLength: originalLength - compressedLength,
                            ratio: `${ratio}%`,
                            compressionIndex: conv.compressionIndex
                        }));
                    } else {
                        console.log(`âš ï¸ æ¶ˆæ¯ ${messageIndex} å·²æœ‰å‹ç¼©å›¾æ ‡ï¼Œè·³è¿‡`);
                    }
                } else {
                    console.warn(`âŒ æœªæ‰¾åˆ°æ¶ˆæ¯ ${messageIndex} å¯¹åº”çš„DOMå…ƒç´ :`, conv.speaker);
                }
            }

            // ====== ä¸Šä¸‹æ–‡å‹ç¼©åŠŸèƒ½æ ¸å¿ƒæ–¹æ³• ======

            /**
             * è·å–é»˜è®¤çš„å‹ç¼©æç¤ºè¯æ¨¡æ¿
             * @returns {string} é»˜è®¤æç¤ºè¯æ¨¡æ¿
             */
            getDefaultCompressionPromptTemplate() {
                return `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å¯¹è¯å‹ç¼©åŠ©æ‰‹ã€‚ä½ çš„ä»»åŠ¡æ˜¯å°†AIå¯¹è¯å†å²è¿›è¡Œæ™ºèƒ½å‹ç¼©ï¼Œå‡å°‘çº¦{compressionRatio}%çš„å†…å®¹é•¿åº¦ï¼ŒåŒæ—¶æœ€å¤§ç¨‹åº¦ä¿ç•™å…³é”®ä¿¡æ¯ã€‚

## å‹ç¼©åŸåˆ™ï¼š
1. **ä¿ç•™æ ¸å¿ƒä¿¡æ¯**ï¼šä¿æŒå¯¹è¯çš„ä¸»è¦è§‚ç‚¹ã€ç»“è®ºå’Œé‡è¦ç»†èŠ‚
2. **ç»´æŒé€»è¾‘è¿è´¯**ï¼šç¡®ä¿å‹ç¼©åçš„å¯¹è¯é€»è¾‘æ¸…æ™°ï¼Œä¸Šä¸‹æ–‡è¿è´¯
3. **åˆ é™¤å†—ä½™**ï¼šå»é™¤é‡å¤ã€å•°å—¦ã€æ— å…³ç´§è¦çš„å†…å®¹
4. **ä¿æŒè¯­æ°”**ï¼šå°½é‡ä¿æŒåŸæœ‰çš„å¯¹è¯è¯­æ°”å’Œé£æ ¼
5. **å…³é”®è¯ä¿ç•™**ï¼šä¿ç•™ä¸“ä¸šæœ¯è¯­ã€é‡è¦æ¦‚å¿µå’Œå…³é”®è¯æ±‡

## å‹ç¼©ç­–ç•¥ï¼š
- åˆå¹¶ç›¸ä¼¼è§‚ç‚¹
- ç®€åŒ–å†—é•¿è¡¨è¿°
- åˆ é™¤å®¢å¥—è¯å’Œè¿‡æ¸¡è¯
- ä¿ç•™æ•°å­—ã€æ—¶é—´ã€ä¸“æœ‰åè¯ç­‰å…³é”®æ•°æ®
- å¯¹äºè¾ƒæ–°çš„æ¶ˆæ¯ï¼ˆæœ€è¿‘3-5æ¡ï¼‰ï¼Œå‹ç¼©ç¨‹åº¦è¦è½»ä¸€äº›

## è¾“å‡ºæ ¼å¼ï¼š
è¯·æŒ‰ä»¥ä¸‹JSONæ ¼å¼è¾“å‡ºå‹ç¼©ç»“æœï¼š
\`\`\`json
{
  "compressed_messages": [
    {
      "speaker": "AI A",
      "content": "å‹ç¼©åçš„æ¶ˆæ¯å†…å®¹"
    },
    {
      "speaker": "AI B", 
      "content": "å‹ç¼©åçš„æ¶ˆæ¯å†…å®¹"
    }
  ],
  "compression_summary": {
    "original_count": åŸå§‹æ¶ˆæ¯æ•°é‡,
    "compressed_count": å‹ç¼©åæ¶ˆæ¯æ•°é‡,
    "key_points": ["ä¿ç•™çš„å…³é”®ä¿¡æ¯ç‚¹1", "å…³é”®ä¿¡æ¯ç‚¹2"],
    "removed_elements": ["åˆ é™¤çš„å†…å®¹ç±»å‹1", "åˆ é™¤çš„å†…å®¹ç±»å‹2"]
  }
}
\`\`\`

ç°åœ¨è¯·å‹ç¼©ä»¥ä¸‹å¯¹è¯å†å²ï¼š`;
            }

            /**
             * è·å–AIå‹ç¼©çš„ç³»ç»Ÿæç¤ºè¯
             * @param {number} compressionRatio - å‹ç¼©æ¯”ç‡
             * @returns {string} å‹ç¼©æç¤ºè¯
             */
            getCompressionPrompt(compressionRatio) {
                const targetReduction = Math.round(compressionRatio * 100);
                let template = this.elements.promptSystem.value.trim();
                
                // å¦‚æœç”¨æˆ·æ²¡æœ‰è®¾ç½®è‡ªå®šä¹‰æ¨¡æ¿ï¼Œä½¿ç”¨é»˜è®¤æ¨¡æ¿
                if (!template) {
                    template = this.getDefaultCompressionPromptTemplate();
                }
                
                // æ›¿æ¢å˜é‡
                return template.replace(/\{compressionRatio\}/g, targetReduction);
            }

            /**
             * ä¼°ç®—æ–‡æœ¬çš„Tokenæ•°é‡ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
             * @param {string} text - è¦ä¼°ç®—çš„æ–‡æœ¬
             * @returns {number} ä¼°ç®—çš„Tokenæ•°é‡
             */
            estimateTokens(text) {
                if (!text) return 0;
                // ç®€åŒ–çš„Tokenä¼°ç®—ï¼šä¸­æ–‡å­—ç¬¦çº¦1.5ä¸ªtokenï¼Œè‹±æ–‡å•è¯çº¦1ä¸ªtoken
                const chineseChars = (text.match(/[\u4e00-\u9fff]/g) || []).length;
                const englishWords = (text.match(/[a-zA-Z]+/g) || []).length;
                const otherChars = text.length - chineseChars - englishWords;
                return Math.ceil(chineseChars * 1.5 + englishWords + otherChars * 0.5);
            }



            /**
             * AIæ™ºèƒ½å‹ç¼©å¯¹è¯å†å²ï¼ˆå•æ¡æ¶ˆæ¯å‹ç¼©æœºåˆ¶ï¼‰
             * @param {Array} conversations - å¯¹è¯å†å²æ•°ç»„
             * @returns {Array} ç”¨äºAPIçš„å¯¹è¯æ•°ç»„ï¼ˆåŒ…å«å‹ç¼©å†…å®¹ï¼‰
             */
            async compressConversations(conversations) {
                if (!this.enableCompression || conversations.length <= this.keepRecentCount) {
                    return conversations;
                }
                
                const totalCount = conversations.length;
                
                // è®¡ç®—éœ€è¦å‹ç¼©çš„æ¶ˆæ¯ä½ç½®ï¼ˆä»åå¾€å‰æ•°ç¬¬keepRecentCount+1æ¡ï¼‰
                const targetCompressIndex = totalCount - this.keepRecentCount - 1;
                
                // å¦‚æœç›®æ ‡å‹ç¼©ä½ç½®æ— æ•ˆæˆ–å·²ç»å‹ç¼©è¿‡ï¼Œæ„å»ºAPIç”¨çš„å¯¹è¯æ•°ç»„
                if (targetCompressIndex < 0) {
                    return conversations;
                }
                
                // æ£€æŸ¥æ˜¯å¦éœ€è¦å‹ç¼©æ–°æ¶ˆæ¯
                if (targetCompressIndex >= this.lastCompressionIndex) {
                    // éœ€è¦å‹ç¼©æ–°æ¶ˆæ¯
                    const targetMessage = conversations[targetCompressIndex];
                    const cacheKey = this.getMessageCacheKey(targetMessage, targetCompressIndex);
                    
                    if (!this.compressionCache.has(cacheKey)) {
                        // ç¡®å®šå‹ç¼©æ—¶çš„ä¸Šä¸‹æ–‡èŒƒå›´ï¼ˆåŒ…å«ç›®æ ‡æ¶ˆæ¯åœ¨å†…çš„æœ€è¿‘3æ¡ï¼Œä½¿ç”¨å®Œæ•´æ¶ˆæ¯ï¼‰
                        const contextSize = 3;
                        const contextStart = Math.max(0, targetCompressIndex - contextSize + 1);
                        const contextMessages = conversations.slice(contextStart, targetCompressIndex + 1);
                        
                        console.log(`ğŸ—œï¸ å‹ç¼©æ¶ˆæ¯ä½ç½® ${targetCompressIndex}ï¼Œä¸Šä¸‹æ–‡èŒƒå›´ ${contextStart}-${targetCompressIndex} (${contextMessages.length}æ¡)`);
                        
                        try {
                            // å‹ç¼©ç›®æ ‡æ¶ˆæ¯ï¼Œæºå¸¦ä¸Šä¸‹æ–‡ï¼ˆä½¿ç”¨å®Œæ•´æ¶ˆæ¯ï¼‰
                            const compressedContent = await this.compressTargetMessage(
                                targetMessage, 
                                contextMessages, 
                                targetCompressIndex
                            );
                            
                            // å­˜å…¥å‹ç¼©ç¼“å­˜ï¼ˆåªå­˜å‚¨å‹ç¼©åçš„å†…å®¹ï¼Œä¸æ˜¯å®Œæ•´æ¶ˆæ¯å¯¹è±¡ï¼‰
                            this.compressionCache.set(cacheKey, compressedContent);
                            
                            // æ›´æ–°å‹ç¼©ç´¢å¼•
                            this.lastCompressionIndex = targetCompressIndex + 1;
                            
                            // æ ‡è®°åŸæ¶ˆæ¯å·²è¢«å‹ç¼©ï¼ˆç”¨äºUIæ˜¾ç¤ºï¼‰
                            conversations[targetCompressIndex].isCompressed = true;
                            conversations[targetCompressIndex].compressedContent = compressedContent;
                            conversations[targetCompressIndex].compressionIndex = targetCompressIndex;
                            
                            // ç«‹å³æ›´æ–°UIæ˜¾ç¤ºå‹ç¼©å›¾æ ‡ï¼ˆå»¶è¿Ÿæ‰§è¡Œç¡®ä¿DOMå·²æ›´æ–°ï¼‰
                            setTimeout(() => {
                                this.updateMessageCompressionIcon(targetCompressIndex);
                            }, 200);
                            
                        } catch (error) {
                            console.error('å‹ç¼©å¤±è´¥:', error);
                            this.showCompressionError(error, 1);
                        }
                    } else {
                        // ä½¿ç”¨ç¼“å­˜çš„å‹ç¼©ç»“æœ
                        const cachedCompressed = this.compressionCache.get(cacheKey);
                        conversations[targetCompressIndex].isCompressed = true;
                        conversations[targetCompressIndex].compressedContent = cachedCompressed;
                        conversations[targetCompressIndex].compressionIndex = targetCompressIndex;
                        
                        // ç«‹å³æ›´æ–°UIæ˜¾ç¤ºå‹ç¼©å›¾æ ‡ï¼ˆå»¶è¿Ÿæ‰§è¡Œç¡®ä¿DOMå·²æ›´æ–°ï¼‰
                        setTimeout(() => {
                            this.updateMessageCompressionIcon(targetCompressIndex);
                        }, 200);
                        
                        console.log(`âœ… ä½¿ç”¨ç¼“å­˜ï¼Œè·³è¿‡å‹ç¼©ä½ç½® ${targetCompressIndex}`);
                    }
                }
                
                // æ„å»ºç”¨äºAPIçš„å¯¹è¯æ•°ç»„ï¼ˆä½¿ç”¨å‹ç¼©å†…å®¹ï¼‰
                return this.buildAPIConversations(conversations);
            }

            /**
             * æ„å»ºç”¨äºAPIçš„å¯¹è¯æ•°ç»„ï¼ˆä½¿ç”¨å‹ç¼©å†…å®¹ï¼‰
             * @param {Array} conversations - åŸå§‹å¯¹è¯æ•°ç»„
             * @returns {Array} ç”¨äºAPIçš„å¯¹è¯æ•°ç»„
             */
            buildAPIConversations(conversations) {
                const totalCount = conversations.length;
                const result = [];
                
                for (let i = 0; i < totalCount; i++) {
                    const conv = conversations[i];
                    
                    // åˆ¤æ–­æ˜¯å¦åº”è¯¥ä½¿ç”¨å‹ç¼©å†…å®¹
                    const shouldUseCompressed = conv.isCompressed && 
                                               i < (totalCount - this.keepRecentCount) && // ä¸åœ¨ä¿æŠ¤èŒƒå›´å†…
                                               conv.compressedContent; // æœ‰å‹ç¼©å†…å®¹
                    
                    if (shouldUseCompressed) {
                        // ä½¿ç”¨å‹ç¼©å†…å®¹
                        result.push({
                            role: conv.role,
                            content: conv.compressedContent,
                            speaker: conv.speaker,
                            isFromCompression: true
                        });
                    } else {
                        // ä½¿ç”¨å®Œæ•´å†…å®¹
                        result.push({
                            role: conv.role,
                            content: conv.content,
                            speaker: conv.speaker
                        });
                    }
                }
                
                return result;
            }

            /**
             * å‹ç¼©ç›®æ ‡æ¶ˆæ¯ï¼ˆæºå¸¦ä¸Šä¸‹æ–‡ï¼‰
             * @param {Object} targetMessage - ç›®æ ‡æ¶ˆæ¯
             * @param {Array} contextMessages - ä¸Šä¸‹æ–‡æ¶ˆæ¯æ•°ç»„ï¼ˆåŒ…å«ç›®æ ‡æ¶ˆæ¯ï¼‰
             * @param {number} targetIndex - ç›®æ ‡æ¶ˆæ¯åœ¨åŸæ•°ç»„ä¸­çš„ç´¢å¼•
             * @returns {string} å‹ç¼©åçš„å†…å®¹
             */
            async compressTargetMessage(targetMessage, contextMessages, targetIndex) {
                try {
                    // è®¡ç®—åŸå§‹Tokenæ•°é‡
                    const originalTokenCount = this.estimateTokens(targetMessage.content);
                    
                    // æ„å»ºå‹ç¼©è¯·æ±‚
                    const compressionPrompt = this.getCompressionPrompt(this.compressionRatio);
                    
                    // æ„å»ºä¸Šä¸‹æ–‡æ–‡æœ¬ï¼ˆç”¨äºAIç†è§£ä¸Šä¸‹æ–‡ï¼Œä½¿ç”¨å®Œæ•´æ¶ˆæ¯ï¼‰
                    const contextText = contextMessages.map((msg, idx) => {
                        const isTarget = msg === targetMessage;
                        const prefix = isTarget ? 'ã€ç›®æ ‡æ¶ˆæ¯ã€‘' : 'ã€ä¸Šä¸‹æ–‡ã€‘';
                        // å§‹ç»ˆä½¿ç”¨å®Œæ•´å†…å®¹ä½œä¸ºå‹ç¼©ä¸Šä¸‹æ–‡
                        return `${prefix}${msg.speaker}: ${msg.content}`;
                    }).join('\n\n');
                    
                    const messages = [
                        { role: 'system', content: compressionPrompt },
                        { 
                            role: 'user', 
                            content: `è¯·å‹ç¼©ä¸‹é¢æ ‡è®°ä¸ºã€ç›®æ ‡æ¶ˆæ¯ã€‘çš„å†…å®¹ï¼Œå…¶ä»–ã€ä¸Šä¸‹æ–‡ã€‘æ¶ˆæ¯ä»…ç”¨äºç†è§£è¯­å¢ƒï¼Œä¸éœ€è¦å‹ç¼©ï¼š\n\n${contextText}\n\nè¯·åªè¿”å›ç›®æ ‡æ¶ˆæ¯çš„å‹ç¼©ç‰ˆæœ¬ã€‚` 
                        }
                    ];
                    
                    // æ˜¾ç¤ºå‹ç¼©è¿›è¡Œä¸­çš„æç¤º
                    this.addSystemMessage(`ğŸ¤– AIæ­£åœ¨å‹ç¼©ç¬¬${targetIndex + 1}æ¡æ¶ˆæ¯ (æºå¸¦${contextMessages.length}æ¡ä¸Šä¸‹æ–‡)...`, 'info');
                    
                    // ä½¿ç”¨ç»Ÿä¸€çš„AIè°ƒç”¨é€»è¾‘ï¼ˆå¸¦é‡è¯•ï¼‰
                    const systemConfig = this.getAIConfig('System');
                    const response = await this.callAIWithRetry('System', systemConfig, messages);
                    
                    if (!response || !response.content) {
                        throw new Error('AIå‹ç¼©å“åº”ä¸ºç©º');
                    }
                    
                    // è§£æAIè¿”å›çš„å‹ç¼©ç»“æœ
                    const compressedResult = this.parseCompressionResult(response.content);
                    
                    if (!compressedResult || !compressedResult.compressed_messages || compressedResult.compressed_messages.length === 0) {
                        throw new Error('AIå‹ç¼©ç»“æœè§£æå¤±è´¥');
                    }
                    
                    // è·å–å‹ç¼©åçš„å†…å®¹
                    const compressedContent = compressedResult.compressed_messages[0].content;
                    
                    // è®¡ç®—å‹ç¼©ç»Ÿè®¡
                    const compressedTokenCount = this.estimateTokens(compressedContent);
                    const aiCompressionCost = this.estimateTokens(compressionPrompt) + 
                                            this.estimateTokens(contextText) + 
                                            this.estimateTokens(response.content);
                    
                    // æ›´æ–°å‹ç¼©ç»Ÿè®¡
                    this.compressionStats.originalTokens += originalTokenCount;
                    this.compressionStats.compressedTokens += compressedTokenCount;
                    this.compressionStats.aiCompressionTokens += aiCompressionCost;
                    this.compressionStats.compressionCount++;
                    
                    const savedTokens = originalTokenCount - compressedTokenCount;
                    const savedPercentage = ((savedTokens / originalTokenCount) * 100).toFixed(1);
                    
                    // æ˜¾ç¤ºå‹ç¼©ç»Ÿè®¡ä¿¡æ¯
                    this.addSystemMessage(
                        `ğŸ¤– å‹ç¼©å®Œæˆï¼šç¬¬${targetIndex + 1}æ¡æ¶ˆæ¯ï¼ŒèŠ‚çœ ${savedTokens} tokens (${savedPercentage}%)`, 
                        'info'
                    );
                    
                    // å¼ºåˆ¶æ›´æ–°å‹ç¼©å›¾æ ‡ï¼ˆå»¶è¿Ÿæ‰§è¡Œï¼‰
                    setTimeout(() => {
                        console.log(`ğŸ”§ å¼ºåˆ¶æ›´æ–°æ¶ˆæ¯ ${targetIndex} çš„å‹ç¼©å›¾æ ‡`);
                        this.updateMessageCompressionIcon(targetIndex);
                    }, 1000);
                    
                    // æ›´æ–°å‹ç¼©ç»Ÿè®¡UI
                    this.updateCompressionStatsUI();
                    
                    // è¿”å›å‹ç¼©åçš„å†…å®¹å­—ç¬¦ä¸²
                    return compressedContent;
                    
                } catch (error) {
                    console.error('ç›®æ ‡æ¶ˆæ¯å‹ç¼©å¤±è´¥:', error);
                    throw error;
                }
            }

            /**
             * æ‰¹é‡å‹ç¼©ä¸€ç»„æ¶ˆæ¯ï¼ˆå¤šæ¡æ¶ˆæ¯å‹ç¼©ä¸ºä¸€æ¡ï¼‰- ä¿ç•™ç”¨äºå‘åå…¼å®¹
             * @param {Array} messageBatch - æ¶ˆæ¯æ‰¹æ¬¡ï¼ˆå¤šæ¡æ¶ˆæ¯ï¼‰
             * @returns {Array} å‹ç¼©åçš„æ¶ˆæ¯æ•°ç»„ï¼ˆåªæœ‰ä¸€æ¡æ¶ˆæ¯ï¼‰
             */
            async compressMessageBatch(messageBatch) {
                if (!messageBatch || messageBatch.length === 0) {
                    return [];
                }
                
                // ç”Ÿæˆæ‰¹æ¬¡ç¼“å­˜keyï¼ˆåŸºäºæ‰€æœ‰æ¶ˆæ¯çš„ç»„åˆå†…å®¹ï¼‰
                const batchCacheKey = this.getBatchCacheKey(messageBatch);
                
                // æ£€æŸ¥æ‰¹æ¬¡ç¼“å­˜
                if (this.compressionCache.has(batchCacheKey)) {
                    console.log(`âœ… ä½¿ç”¨æ‰¹æ¬¡ç¼“å­˜ï¼Œè·³è¿‡å‹ç¼© (${messageBatch.length}æ¡æ¶ˆæ¯)`);
                    return this.compressionCache.get(batchCacheKey);
                }
                
                try {
                    // è®¡ç®—åŸå§‹Tokenæ•°é‡
                    const originalTokenCount = messageBatch.reduce((sum, conv) => 
                        sum + this.estimateTokens(conv.content), 0);
                    
                    // æ„å»ºå‹ç¼©è¯·æ±‚
                    const compressionPrompt = this.getCompressionPrompt(this.compressionRatio);
                    const conversationText = messageBatch.map(conv => 
                        `${conv.speaker}: ${conv.content}`
                    ).join('\n\n');
                    
                    const messages = [
                        { role: 'system', content: compressionPrompt },
                        { 
                            role: 'user', 
                            content: `è¯·å°†ä»¥ä¸‹${messageBatch.length}æ¡è¿ç»­å¯¹è¯å‹ç¼©ä¸ºä¸€æ¡æ‘˜è¦æ¶ˆæ¯ï¼Œä¿æŒå¯¹è¯çš„æ ¸å¿ƒå†…å®¹å’Œé€»è¾‘ï¼š\n\n${conversationText}` 
                        }
                    ];
                    
                    // æ˜¾ç¤ºå‹ç¼©è¿›è¡Œä¸­çš„æç¤º
                    this.addSystemMessage(`ğŸ¤– AIæ­£åœ¨å°†${messageBatch.length}æ¡å¯¹è¯å‹ç¼©ä¸º1æ¡æ‘˜è¦...`, 'info');
                    
                    // ä½¿ç”¨ç»Ÿä¸€çš„AIè°ƒç”¨é€»è¾‘ï¼ˆå¸¦é‡è¯•ï¼‰
                    const systemConfig = this.getAIConfig('System');
                    const response = await this.callAIWithRetry('System', systemConfig, messages);
                    
                    if (!response || !response.content) {
                        throw new Error('AIæ‰¹é‡å‹ç¼©å“åº”ä¸ºç©º');
                    }
                    
                    // è§£æAIè¿”å›çš„å‹ç¼©ç»“æœ
                    const compressedResult = this.parseCompressionResult(response.content);
                    
                    if (!compressedResult || !compressedResult.compressed_messages || compressedResult.compressed_messages.length === 0) {
                        throw new Error('AIæ‰¹é‡å‹ç¼©ç»“æœè§£æå¤±è´¥');
                    }
                    
                    // åˆ›å»ºä¸€æ¡å‹ç¼©æ‘˜è¦æ¶ˆæ¯ï¼ˆåˆå¹¶å¤šæ¡æ¶ˆæ¯ä¸ºä¸€æ¡ï¼‰
                    const firstMessage = compressedResult.compressed_messages[0];
                    const compressedMessage = {
                        role: 'assistant',
                        content: firstMessage.content, // è¿™æ˜¯å‹ç¼©åçš„å†…å®¹ï¼Œä¼šæ˜¾ç¤ºåœ¨ç•Œé¢ä¸Š
                        speaker: `å‹ç¼©æ‘˜è¦ (${messageBatch.length}æ¡æ¶ˆæ¯)`,
                        originalLength: originalTokenCount,
                        compressedLength: this.estimateTokens(firstMessage.content),
                        compressionLevel: this.compressionRatio,
                        aiCompressed: true,
                        batchCompressed: true,
                        batchSize: messageBatch.length,
                        originalMessages: messageBatch.map(m => ({
                            speaker: m.speaker,
                            content: m.content,
                            originalLength: m.content.length
                        })),
                        compressedContent: firstMessage.content // å­˜å‚¨å‹ç¼©åçš„å†…å®¹
                    };
                    
                    // å­˜å…¥æ‰¹æ¬¡ç¼“å­˜
                    this.compressionCache.set(batchCacheKey, [compressedMessage]);
                    
                    // è®¡ç®—å‹ç¼©ç»Ÿè®¡
                    const compressedTokenCount = this.estimateTokens(firstMessage.content);
                    const aiCompressionCost = this.estimateTokens(compressionPrompt) + 
                                            this.estimateTokens(conversationText) + 
                                            this.estimateTokens(response.content);
                    
                    // æ›´æ–°å‹ç¼©ç»Ÿè®¡
                    this.compressionStats.originalTokens += originalTokenCount;
                    this.compressionStats.compressedTokens += compressedTokenCount;
                    this.compressionStats.aiCompressionTokens += aiCompressionCost;
                    this.compressionStats.compressionCount++;
                    
                    const savedTokens = originalTokenCount - compressedTokenCount;
                    const netSavedTokens = savedTokens - aiCompressionCost;
                    const savedPercentage = ((savedTokens / originalTokenCount) * 100).toFixed(1);
                    
                    // æ˜¾ç¤ºæ‰¹é‡å‹ç¼©ç»Ÿè®¡ä¿¡æ¯
                    this.addSystemMessage(
                        `ğŸ¤– å‹ç¼©å®Œæˆï¼š${messageBatch.length}æ¡æ¶ˆæ¯â†’1æ¡æ‘˜è¦ï¼ŒèŠ‚çœ ${savedTokens} tokens (${savedPercentage}%)`, 
                        'info'
                    );
                    
                    // æ›´æ–°å‹ç¼©ç»Ÿè®¡UI
                    this.updateCompressionStatsUI();
                    
                    return [compressedMessage];
                    
                } catch (error) {
                    console.error('æ‰¹é‡å‹ç¼©å¤±è´¥:', error);
                    
                    // æ˜¾ç¤ºè¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
                    this.showCompressionError(error, messageBatch.length);
                    
                    // æ‰¹é‡å‹ç¼©å¤±è´¥ï¼Œè¿”å›åŸå§‹æ¶ˆæ¯
                    this.addSystemMessage(`âŒ æ‰¹é‡å‹ç¼©å¤±è´¥ï¼Œä¿æŒåŸå§‹${messageBatch.length}æ¡æ¶ˆæ¯ä¸å‹ç¼©`, 'error');
                    return messageBatch;
                }
            }

            /**
             * ç”Ÿæˆæ‰¹æ¬¡ç¼“å­˜key
             * @param {Array} messageBatch - æ¶ˆæ¯æ‰¹æ¬¡
             * @returns {string} æ‰¹æ¬¡ç¼“å­˜key
             */
            getBatchCacheKey(messageBatch) {
                // å°†æ‰¹æ¬¡ä¸­æ‰€æœ‰æ¶ˆæ¯çš„å†…å®¹ç»„åˆç”Ÿæˆhash
                const batchContent = messageBatch.map(msg => `${msg.speaker}:${msg.content}`).join('|');
                const hash = batchContent.split('').reduce((a, b) => {
                    a = ((a << 5) - a) + b.charCodeAt(0);
                    return a & a;
                }, 0);
                return `batch_${messageBatch.length}_${hash.toString()}`;
            }

            /**
             * è·å–ç¼“å­˜çš„å‹ç¼©å¯¹è¯
             * @param {Array} conversations - å¯¹è¯å†å²æ•°ç»„
             * @returns {Array} ç¼“å­˜çš„å‹ç¼©ç»“æœ
             */
            getCachedCompressedConversations(conversations) {
                // å¦‚æœæ²¡æœ‰ç¼“å­˜ï¼Œåˆ™è¿”å›åŸå§‹å¯¹è¯
                if (this.compressionCache.size === 0) {
                    return conversations;
                }
                
                return conversations.map(conv => {
                    const cacheKey = this.getMessageCacheKey(conv);
                    return this.compressionCache.get(cacheKey) || conv;
                });
            }

            /**
             * ç”Ÿæˆæ¶ˆæ¯çš„ç¼“å­˜key
             * @param {Object} message - æ¶ˆæ¯å¯¹è±¡
             * @param {number} index - æ¶ˆæ¯åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•ï¼ˆå¯é€‰ï¼‰
             * @returns {string} ç¼“å­˜key
             */
            getMessageCacheKey(message, index = null) {
                // ä½¿ç”¨æ¶ˆæ¯å†…å®¹ã€å‘è¨€è€…å’Œä½ç½®ç”Ÿæˆhash
                const content = `${message.speaker}:${message.content}${index !== null ? ':' + index : ''}`;
                const hash = content.split('').reduce((a, b) => {
                    a = ((a << 5) - a) + b.charCodeAt(0);
                    return a & a;
                }, 0);
                return hash.toString();
            }





            /**
             * è§£æAIå‹ç¼©ç»“æœ
             * @param {string} content - AIè¿”å›çš„å†…å®¹
             * @returns {Object} è§£æåçš„å‹ç¼©ç»“æœ
             */
            parseCompressionResult(content) {
                if (!content || typeof content !== 'string') {
                    throw new Error('AIå“åº”å†…å®¹ä¸ºç©ºæˆ–æ ¼å¼ä¸æ­£ç¡®');
                }

                try {
                    // å°è¯•æå–JSONå†…å®¹ï¼ˆä¼˜å…ˆçº§ä»é«˜åˆ°ä½ï¼‰
                    let jsonStr = null;
                    
                    // 1. æ ‡å‡†çš„```json```æ ¼å¼
                    const jsonCodeBlock = content.match(/```json\s*([\s\S]*?)\s*```/);
                    if (jsonCodeBlock) {
                        jsonStr = jsonCodeBlock[1];
                    }
                    
                    // 2. æ™®é€šçš„```ä»£ç å—æ ¼å¼  
                    if (!jsonStr) {
                        const codeBlock = content.match(/```\s*([\s\S]*?)\s*```/);
                        if (codeBlock && codeBlock[1].trim().startsWith('{')) {
                            jsonStr = codeBlock[1];
                        }
                    }
                    
                    // 3. ç›´æ¥çš„JSONå¯¹è±¡
                    if (!jsonStr) {
                        const jsonObject = content.match(/\{[\s\S]*\}/);
                        if (jsonObject) {
                            jsonStr = jsonObject[0];
                        }
                    }
                    
                    // 4. å¦‚æœéƒ½æ²¡æ‰¾åˆ°ï¼Œå°è¯•æ•´ä¸ªå†…å®¹
                    if (!jsonStr) {
                        jsonStr = content.trim();
                    }
                    
                    // è§£æJSON
                    const parsed = JSON.parse(jsonStr);
                    
                    // éªŒè¯å¿…éœ€çš„å­—æ®µ
                    if (!parsed.compressed_messages || !Array.isArray(parsed.compressed_messages)) {
                        throw new Error('AIå“åº”ç¼ºå°‘compressed_messageså­—æ®µæˆ–æ ¼å¼ä¸æ­£ç¡®');
                    }
                    
                    if (parsed.compressed_messages.length === 0) {
                        throw new Error('AIè¿”å›çš„å‹ç¼©æ¶ˆæ¯æ•°ç»„ä¸ºç©º');
                    }
                    
                    // éªŒè¯æ¯ä¸ªæ¶ˆæ¯çš„æ ¼å¼
                    for (let i = 0; i < parsed.compressed_messages.length; i++) {
                        const msg = parsed.compressed_messages[i];
                        if (!msg.speaker || !msg.content) {
                            throw new Error(`ç¬¬${i+1}æ¡å‹ç¼©æ¶ˆæ¯ç¼ºå°‘speakeræˆ–contentå­—æ®µ`);
                        }
                    }
                    
                    return parsed;
                    
                } catch (error) {
                    console.error('è§£æAIå‹ç¼©ç»“æœå¤±è´¥:', error);
                    console.error('åŸå§‹å†…å®¹:', content);
                    
                    if (error.message.includes('Unexpected token') || error.message.includes('JSON')) {
                        throw new Error(`AIè¿”å›çš„JSONæ ¼å¼ä¸æ­£ç¡®: ${error.message}`);
                    } else {
                        throw new Error(`è§£æAIå‹ç¼©ç»“æœå¤±è´¥: ${error.message}`);
                    }
                }
            }

            /**
             * æ˜¾ç¤ºå‹ç¼©é”™è¯¯çš„è¯¦ç»†ä¿¡æ¯
             * @param {Error} error - é”™è¯¯å¯¹è±¡
             * @param {number} messageCount - æ¶ˆæ¯æ•°é‡
             */
            showCompressionError(error, messageCount) {
                let errorType = 'æœªçŸ¥é”™è¯¯';
                let suggestion = '';
                
                if (error.message.includes('HTTP 401') || error.message.includes('Unauthorized')) {
                    errorType = 'APIå¯†é’¥é”™è¯¯';
                    suggestion = 'è¯·æ£€æŸ¥ç³»ç»ŸAIçš„APIå¯†é’¥æ˜¯å¦æ­£ç¡®';
                } else if (error.message.includes('HTTP 429') || error.message.includes('Rate limit')) {
                    errorType = 'APIè°ƒç”¨é¢‘ç‡é™åˆ¶';
                    suggestion = 'è¯·ç¨åé‡è¯•æˆ–æ£€æŸ¥APIé…é¢';
                } else if (error.message.includes('HTTP 400') || error.message.includes('Bad Request')) {
                    errorType = 'APIè¯·æ±‚æ ¼å¼é”™è¯¯';
                    suggestion = 'è¯·æ£€æŸ¥ç³»ç»ŸAIæ¨¡å‹åç§°æ˜¯å¦æ­£ç¡®';
                } else if (error.message.includes('HTTP 404')) {
                    errorType = 'APIç«¯ç‚¹ä¸å­˜åœ¨';
                    suggestion = 'è¯·æ£€æŸ¥ç³»ç»ŸAIçš„APIåœ°å€æ˜¯å¦æ­£ç¡®';
                } else if (error.message.includes('HTTP 500') || error.message.includes('Internal Server Error')) {
                    errorType = 'APIæœåŠ¡å™¨å†…éƒ¨é”™è¯¯';
                    suggestion = 'æœåŠ¡å™¨æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åé‡è¯•';
                } else if (error.message.includes('ç½‘ç»œé”™è¯¯') || error.message.includes('Failed to fetch')) {
                    errorType = 'ç½‘ç»œè¿æ¥é”™è¯¯';
                    suggestion = 'è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–APIåœ°å€';
                } else if (error.message.includes('è§£æå¤±è´¥') || error.message.includes('JSON')) {
                    errorType = 'AIå“åº”è§£æå¤±è´¥';
                    suggestion = 'å¯èƒ½æ˜¯æ¨¡å‹è¿”å›æ ¼å¼ä¸æ­£ç¡®ï¼Œå»ºè®®è°ƒæ•´æç¤ºè¯';
                } else if (error.message.includes('å“åº”ä¸ºç©º')) {
                    errorType = 'AIæ— å“åº”';
                    suggestion = 'æ¨¡å‹å¯èƒ½é‡åˆ°é—®é¢˜ï¼Œè¯·æ£€æŸ¥é…ç½®æˆ–ç¨åé‡è¯•';
                }
                
                const errorMessage = `
âŒ AIå‹ç¼©å¤±è´¥è¯¦æƒ…ï¼š
â€¢ é”™è¯¯ç±»å‹: ${errorType}
â€¢ å¤„ç†æ¶ˆæ¯: ${messageCount}æ¡
â€¢ å»ºè®®æ“ä½œ: ${suggestion}
â€¢ æŠ€æœ¯è¯¦æƒ…: ${error.message}
                `.trim();
                
                this.addSystemMessage(errorMessage, 'error');
            }

            /**
             * ç»Ÿä¸€çš„AIè°ƒç”¨æ–¹æ³•ï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
             * @param {string} aiType - AIç±»å‹
             * @param {Object} config - AIé…ç½®
             * @param {Array} messages - æ¶ˆæ¯æ•°ç»„
             * @returns {Object} APIå“åº”
             */
            async callAIWithRetry(aiType, config, messages) {
                let currentRetries = 0;
                
                while (currentRetries <= this.retryCount) {
                    try {
                        if (currentRetries > 0) {
                            this.addSystemMessage(`ğŸ”„ ${aiType === 'System' ? 'ç³»ç»ŸAI' : 'AI ' + aiType} é‡è¯•ä¸­ (${currentRetries}/${this.retryCount})...`, 'info');
                            await this.sleep(this.retryDelay);
                        }
                        
                        // æ ¹æ®AIç±»å‹è°ƒç”¨ç›¸åº”çš„API
                        if (config.endpointType === 'openai') {
                            if (aiType === 'System') {
                                return await this.callOpenAIForCompression(config, messages);
                            } else {
                                // å¯¹è¯AIä½¿ç”¨æµå¼è°ƒç”¨ï¼ˆè¿™é‡Œç®€åŒ–ä¸ºéæµå¼ï¼‰
                                return await this.callOpenAIForCompression(config, messages);
                            }
                        } else if (config.endpointType === 'gemini') {
                            if (aiType === 'System') {
                                return await this.callGeminiForCompression(config, messages);
                            } else {
                                // å¯¹è¯AIä½¿ç”¨æµå¼è°ƒç”¨ï¼ˆè¿™é‡Œç®€åŒ–ä¸ºéæµå¼ï¼‰
                                return await this.callGeminiForCompression(config, messages);
                            }
                        } else {
                            throw new Error(`ä¸æ”¯æŒçš„AIç±»å‹: ${config.endpointType}`);
                        }
                        
                    } catch (error) {
                        console.warn(`AI ${aiType} å°è¯• ${currentRetries + 1} å¤±è´¥:`, error.message);
                        currentRetries++;
                        
                        // å¦‚æœæ˜¯é…ç½®é”™è¯¯ï¼Œä¸éœ€è¦é‡è¯•
                        if (error.message.includes('HTTP 401') || 
                            error.message.includes('HTTP 404') || 
                            error.message.includes('ä¸æ”¯æŒçš„')) {
                            break;
                        }
                        
                        if (currentRetries <= this.retryCount) {
                            this.addSystemMessage(`âŒ AI ${aiType} è°ƒç”¨å¤±è´¥ï¼Œ${this.retryDelay/1000}ç§’åé‡è¯• (${currentRetries}/${this.retryCount})`, 'error');
                        }
                    }
                }
                
                // é‡è¯•æ¬¡æ•°ç”¨å®Œï¼Œæš‚åœå¯¹è¯
                this.addSystemMessage(`âŒ AI ${aiType} è°ƒç”¨å¤±è´¥ï¼Œå·²è¾¾é‡è¯•ä¸Šé™ï¼Œå¯¹è¯å·²æš‚åœ`, 'error');
                this.isPaused = true;
                this.updateUI();
                
                throw new Error(`AI ${aiType} è°ƒç”¨å¤±è´¥ï¼Œå·²è¾¾é‡è¯•ä¸Šé™`);
            }

            /**
             * è°ƒç”¨OpenAIè¿›è¡Œå‹ç¼©ï¼ˆéæµå¼ï¼‰
             */
            async callOpenAIForCompression(config, messages) {
                // ä¿®å¤ï¼šå¦‚æœURLä»¥#ç»“å°¾ï¼Œå¼ºåˆ¶ä½¿ç”¨è¾“å…¥åœ°å€ï¼›å¦åˆ™è‡ªåŠ¨è¡¥å…¨
                let url;
                if (config.apiUrl.endsWith('#')) {
                    url = config.apiUrl.slice(0, -1); // å»æ‰æœ«å°¾çš„#
                } else if (config.apiUrl.endsWith('/v1/chat/completions')) {
                    url = config.apiUrl;
                } else {
                    url = `${config.apiUrl}/v1/chat/completions`;
                }

                let response;
                try {
                    response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${config.apiKey}`
                        },
                        body: JSON.stringify({
                            model: config.model,
                            messages: messages,
                            temperature: 0.7
                        })
                    });
                } catch (error) {
                    throw new Error(`ç½‘ç»œé”™è¯¯: ${error.message}`);
                }

                if (!response.ok) {
                    let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        if (errorData.error && errorData.error.message) {
                            errorMessage += ` - ${errorData.error.message}`;
                        }
                    } catch (e) {
                        // å¿½ç•¥JSONè§£æé”™è¯¯
                    }
                    throw new Error(errorMessage);
                }

                let data;
                try {
                    data = await response.json();
                } catch (error) {
                    throw new Error(`å“åº”è§£æå¤±è´¥: ${error.message}`);
                }

                const content = data.choices?.[0]?.message?.content;
                if (!content) {
                    throw new Error('OpenAI APIå“åº”ä¸ºç©ºæˆ–æ ¼å¼ä¸æ­£ç¡®');
                }

                return { content };
            }

            /**
             * è°ƒç”¨Geminiè¿›è¡Œå‹ç¼©ï¼ˆéæµå¼ï¼‰
             */
            async callGeminiForCompression(config, messages) {
                const url = `${config.apiUrl}/v1beta/models/${config.model}:generateContent?key=${config.apiKey}`;

                // è½¬æ¢æ¶ˆæ¯æ ¼å¼
                const contents = messages.filter(m => m.role !== 'system').map(m => ({
                    role: m.role === 'assistant' ? 'model' : 'user',
                    parts: [{ text: m.content }]
                }));

                const systemInstruction = messages.find(m => m.role === 'system');
                const requestBody = {
                    contents: contents,
                    generationConfig: {
                        temperature: 0.7
                    }
                };

                if (systemInstruction) {
                    requestBody.systemInstruction = {
                        parts: [{ text: systemInstruction.content }]
                    };
                }

                let response;
                try {
                    response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });
                } catch (error) {
                    throw new Error(`ç½‘ç»œé”™è¯¯: ${error.message}`);
                }

                if (!response.ok) {
                    let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        if (errorData.error && errorData.error.message) {
                            errorMessage += ` - ${errorData.error.message}`;
                        }
                    } catch (e) {
                        // å¿½ç•¥JSONè§£æé”™è¯¯
                    }
                    throw new Error(errorMessage);
                }

                let data;
                try {
                    data = await response.json();
                } catch (error) {
                    throw new Error(`å“åº”è§£æå¤±è´¥: ${error.message}`);
                }

                // æ£€æŸ¥Geminiç‰¹æœ‰çš„é”™è¯¯æ ¼å¼
                if (data.error) {
                    throw new Error(`Gemini APIé”™è¯¯: ${data.error.message || 'æœªçŸ¥é”™è¯¯'}`);
                }

                const content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!content) {
                    // æ£€æŸ¥æ˜¯å¦è¢«å®‰å…¨è¿‡æ»¤å™¨é˜»æ­¢
                    if (data.candidates?.[0]?.finishReason === 'SAFETY') {
                        throw new Error('å†…å®¹è¢«Geminiå®‰å…¨è¿‡æ»¤å™¨é˜»æ­¢ï¼Œè¯·è°ƒæ•´æç¤ºè¯');
                    }
                    throw new Error('Gemini APIå“åº”ä¸ºç©ºæˆ–æ ¼å¼ä¸æ­£ç¡®');
                }

                return { content };
            }

            /**
             * è·å–å‹ç¼©ç»Ÿè®¡ä¿¡æ¯
             */
            getCompressionStats() {
                const stats = this.compressionStats;
                if (stats.compressionCount === 0) {
                    return 'æš‚æ— å‹ç¼©ç»Ÿè®¡';
                }
                
                const totalSaved = stats.originalTokens - stats.compressedTokens;
                const avgSavedPercentage = ((totalSaved / stats.originalTokens) * 100).toFixed(1);
                
                return `æ€»è®¡å‹ç¼© ${stats.compressionCount} æ¬¡ï¼ŒèŠ‚çœ ${totalSaved} tokens (${avgSavedPercentage}%)`;
            }

            /**
             * æ›´æ–°å‹ç¼©ç»Ÿè®¡UIæ˜¾ç¤º
             */
            updateCompressionStatsUI() {
                const statsSection = document.getElementById('compressionStatsSection');
                const statsDiv = document.getElementById('compressionStats');
                
                if (this.enableCompression && this.compressionStats.compressionCount > 0) {
                    const stats = this.compressionStats;
                    const totalSaved = stats.originalTokens - stats.compressedTokens;
                    const netSaved = totalSaved - (stats.aiCompressionTokens || 0);
                    const avgSavedPercentage = ((totalSaved / stats.originalTokens) * 100).toFixed(1);
                    
                    let statsHtml = `
                        ğŸ“Š å‹ç¼©æ¬¡æ•°: ${stats.compressionCount}<br>
                        ğŸ’¾ èŠ‚çœToken: ${totalSaved} (${avgSavedPercentage}%)<br>
                        ğŸ“ˆ åŸå§‹Token: ${stats.originalTokens}<br>
                        ğŸ“‰ å‹ç¼©åToken: ${stats.compressedTokens}<br>
                        ğŸ¤– AIå‹ç¼©æˆæœ¬: ${stats.aiCompressionTokens} tokens<br>
                        ğŸ’° å‡€èŠ‚çœ: ${netSaved} tokens
                    `;
                    
                    statsDiv.innerHTML = statsHtml;
                    statsSection.style.display = 'block';
                } else if (this.enableCompression) {
                    statsDiv.innerHTML = `
                        ğŸ¤– å‹ç¼©æ¨¡å¼: AIæ™ºèƒ½å‹ç¼©<br>
                        ğŸ“ å‹ç¼©å¼ºåº¦: ${(this.compressionRatio * 100).toFixed(0)}%<br>
                        ğŸ”’ ä¿æŠ¤æœ€è¿‘: ${this.keepRecentCount}æ¡æ¶ˆæ¯<br>
                        ğŸ“Š ç­‰å¾…å‹ç¼©æ•°æ®...
                    `;
                    statsSection.style.display = 'block';
                } else {
                    statsSection.style.display = 'none';
                }
            }
        }

        // åˆå§‹åŒ–ç³»ç»Ÿ
        document.addEventListener('DOMContentLoaded', () => {
            new AIDialogueSystem();
        });
    </script>
</body>
</html>