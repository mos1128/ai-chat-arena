<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIåŒäººå¯¹è¯ç³»ç»Ÿ</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
        }

        .container {
            display: flex;
            width: 100%;
            height: 100vh;
            background: white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        /* å·¦ä¾§é…ç½®æ  */
        .config-panel {
            width: 350px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            padding: 20px;
            overflow-y: auto;
        }

        .config-section {
            margin-bottom: 25px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .config-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
            font-size: 13px;
        }

        .form-input, .form-select, .form-textarea {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            transition: border-color 0.3s;
        }

        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: #3498db;
        }

        .form-textarea {
            height: 60px;
            resize: vertical;
        }

        .api-hint {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
            font-style: italic;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #219a52;
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .btn-warning:hover {
            background: #e67e22;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* å³ä¾§å¯¹è¯æ  */
        .chat-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .chat-header {
            background: #2c3e50;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-title {
            font-size: 18px;
            font-weight: 600;
        }

        .status-indicator {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-ready {
            background: #27ae60;
        }

        .status-running {
            background: #f39c12;
        }

        .status-stopped {
            background: #e74c3c;
        }

        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f8f9fa;
        }

        .message {
            margin-bottom: 15px;
            padding: 12px 15px;
            border-radius: 8px;
            max-width: 80%;
        }

        .message-a {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
        }

        .message-b {
            background: #f3e5f5;
            border-left: 4px solid #9c27b0;
            margin-left: auto;
        }

        /* æ–°å¢ï¼šloadingæ¶ˆæ¯æ ·å¼ */
        .message-loading {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            opacity: 0.8;
        }

        .message-header {
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .message-content {
            line-height: 1.6;
            color: #333;
        }

        .message-content h1, .message-content h2, .message-content h3 {
            margin-top: 15px;
            margin-bottom: 10px;
        }

        .message-content h1 {
            font-size: 20px;
        }

        .message-content h2 {
            font-size: 18px;
        }

        .message-content h3 {
            font-size: 16px;
        }

        .message-content p {
            margin-bottom: 10px;
        }

        .message-content code {
            background: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        .message-content pre {
            background: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 10px 0;
        }

        .chat-input {
            padding: 20px;
            border-top: 1px solid #e9ecef;
            background: white;
        }

        .input-group {
            display: flex;
            gap: 10px;
        }

        .input-field {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        /* æ”¹è¿›çš„loadingåŠ¨ç”» */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* æ–°å¢ï¼šæ‰“å­—æœºæ•ˆæœçš„loading */
        .typing-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .typing-dot {
            width: 6px;
            height: 6px;
            background: #999;
            border-radius: 50%;
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: scale(1);
                opacity: 0.5;
            }
            30% {
                transform: scale(1.2);
                opacity: 1;
            }
        }

        .error-message {
            color: #e74c3c;
            font-size: 12px;
            margin-top: 5px;
        }

        .round-counter {
            background: rgba(255,255,255,0.2);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
    </style>
</head>
<body>    <div class="container">
        <!-- å·¦ä¾§é…ç½®æ  -->
        <div class="config-panel">
            <!-- AI A é…ç½® -->
            <div class="config-section">
                <div class="config-title">AI A é…ç½®</div>
                <div class="form-group">
                    <label class="form-label">ç«¯ç‚¹ç±»å‹</label>
                    <select class="form-select" id="endpointTypeA">
                        <option value="openai">OpenAI</option>
                        <option value="gemini">Gemini</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">APIåœ°å€</label>
                    <input type="text" class="form-input" id="apiUrlA" placeholder="APIåœ°å€">
                    <div class="api-hint">OpenAI: ç³»ç»Ÿä¼šè‡ªåŠ¨è¡¥å…¨ /v1/chat/completions</div>
                </div>
                <div class="form-group">
                    <label class="form-label">APIå¯†é’¥</label>
                    <input type="text" class="form-input" id="apiKeyA" placeholder="APIå¯†é’¥">
                </div>
                <div class="form-group">
                    <label class="form-label">æ¨¡å‹åç§°</label>
                    <input type="text" class="form-input" id="modelA" placeholder="æ¨¡å‹åç§°">
                </div>
                <div class="form-group">
                    <label class="form-label">æç¤ºè¯</label>
                    <textarea class="form-textarea" id="promptA" placeholder="AI Açš„ç³»ç»Ÿæç¤ºè¯"></textarea>
                </div>
            </div>

            <!-- AI B é…ç½® -->
            <div class="config-section">
                <div class="config-title">AI B é…ç½®</div>
                <div class="form-group">
                    <label class="form-label">ç«¯ç‚¹ç±»å‹</label>
                    <select class="form-select" id="endpointTypeB">
                        <option value="openai">OpenAI</option>
                        <option value="gemini">Gemini</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">APIåœ°å€</label>
                    <input type="text" class="form-input" id="apiUrlB" placeholder="APIåœ°å€">
                    <div class="api-hint">OpenAI: ç³»ç»Ÿä¼šè‡ªåŠ¨è¡¥å…¨ /v1/chat/completions</div>
                </div>
                <div class="form-group">
                    <label class="form-label">APIå¯†é’¥</label>
                    <input type="text" class="form-input" id="apiKeyB" placeholder="APIå¯†é’¥">
                </div>
                <div class="form-group">
                    <label class="form-label">æ¨¡å‹åç§°</label>
                    <input type="text" class="form-input" id="modelB" placeholder="æ¨¡å‹åç§°">
                </div>
                <div class="form-group">
                    <label class="form-label">æç¤ºè¯</label>
                    <textarea class="form-textarea" id="promptB" placeholder="AI Bçš„ç³»ç»Ÿæç¤ºè¯"></textarea>
                </div>
            </div>

            <!-- å¯¹è¯æ§åˆ¶ -->
            <div class="config-section">
                <div class="config-title">å¯¹è¯æ§åˆ¶</div>
                <div class="form-group">
                    <label class="form-label">æœ€å¤§è½®æ¬¡ (0=æ— é™åˆ¶)</label>
                    <input type="number" class="form-input" id="maxRounds" value="0" min="0">
                </div>
                <div class="form-group">
                    <label class="form-label">ä¸Šä¸‹æ–‡æ¶ˆæ¯æ•°é‡ (0=å…¨éƒ¨)</label>
                    <input type="number" class="form-input" id="contextLimit" value="0" min="0">
                    <div class="api-hint">é™åˆ¶æ¯æ¬¡APIè°ƒç”¨æ—¶å‘é€çš„å†å²æ¶ˆæ¯æ•°é‡ï¼Œå¯ä»¥å‡å°‘Tokenæ¶ˆè€—</div>
                </div>
                <div class="form-group">
                    <label class="form-label">é‡è¯•æ¬¡æ•°</label>
                    <input type="number" class="form-input" id="retryCount" value="3" min="0">
                </div>
                <div class="form-group">
                    <label class="form-label">é‡è¯•é—´éš” (ç§’)</label>
                    <input type="number" class="form-input" id="retryDelay" value="2" min="1">
                </div>
            </div>

            <!-- æ“ä½œæŒ‰é’® -->
            <div class="config-section">
                <div class="config-title">æ“ä½œ</div>
                <button class="btn btn-primary" id="saveConfig">ä¿å­˜é…ç½®</button>
                <button class="btn btn-success" id="startChat">å¼€å§‹å¯¹è¯</button>
                <button class="btn btn-warning" id="pauseChat">æš‚åœ</button>
                <button class="btn btn-success" id="resumeChat" style="display:none;">ç»§ç»­</button>
                <button class="btn btn-danger" id="stopChat">åœæ­¢</button>
                <button class="btn btn-primary" id="exportChat">å¯¼å‡ºå¯¹è¯</button>
                <button class="btn btn-danger" id="clearChat">æ¸…é™¤å¯¹è¯</button>
                <button class="btn btn-warning" id="retryChat" style="display:none;">é‡è¯•</button>
            </div>
        </div>

        <!-- å³ä¾§å¯¹è¯æ  -->
        <div class="chat-panel">
            <div class="chat-header">
                <div class="chat-title">AIåŒäººå¯¹è¯</div>
                <div style="display: flex; align-items: center; gap: 15px;">
                    <div class="round-counter">è½®æ¬¡: <span id="roundCounter">0</span></div>
                    <div class="status-indicator status-ready" id="statusIndicator">å°±ç»ª</div>
                </div>
            </div>

            <div class="chat-messages" id="chatMessages">
                <div style="text-align: center; color: #666; margin-top: 50px;">
                    <h3>æ¬¢è¿ä½¿ç”¨AIåŒäººå¯¹è¯ç³»ç»Ÿ</h3>
                    <p>è¯·å…ˆé…ç½®AIå‚æ•°ï¼Œç„¶åè¾“å…¥å¼€åœºç™½å¼€å§‹å¯¹è¯</p>
                </div>
            </div>

            <div class="chat-input">
                <div class="input-group">
                    <input type="text" class="input-field" id="openingMessage" placeholder="è¾“å…¥å¼€åœºç™½ï¼Œç”±AI Aå‘èµ·å¯¹è¯...">
                    <button class="btn btn-primary" id="sendOpening">å‘èµ·å¯¹è¯</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        class AIDialogueSystem {
            constructor() {
                this.conversations = [];
                this.currentRound = 0;
                this.maxRounds = 0;
                this.contextLimit = 0; // æ–°å¢ï¼šä¸Šä¸‹æ–‡é™åˆ¶
                this.isRunning = false;
                this.isPaused = false;
                this.retryCount = 3;
                this.retryDelay = 2000;
                this.currentRetries = 0;
                this.needsReset = false;
                this.openingMessage = '';
                this.nextSpeaker = 'B';
                // æ–°å¢ï¼šç”¨äºè·Ÿè¸ªå½“å‰æ­£åœ¨æµå¼æ˜¾ç¤ºçš„æ¶ˆæ¯
                this.currentStreamingMessageId = null;

                this.initializeElements();
                this.loadConfiguration();
                this.setupEventListeners();
                this.updateUI();
            }

            initializeElements() {
                // é…ç½®å…ƒç´ 
                this.elements = {
                    endpointTypeA: document.getElementById('endpointTypeA'),
                    apiUrlA: document.getElementById('apiUrlA'),
                    apiKeyA: document.getElementById('apiKeyA'),
                    modelA: document.getElementById('modelA'),
                    promptA: document.getElementById('promptA'),

                    endpointTypeB: document.getElementById('endpointTypeB'),
                    apiUrlB: document.getElementById('apiUrlB'),
                    apiKeyB: document.getElementById('apiKeyB'),
                    modelB: document.getElementById('modelB'),
                    promptB: document.getElementById('promptB'),

                    maxRounds: document.getElementById('maxRounds'),
                    contextLimit: document.getElementById('contextLimit'), // æ–°å¢
                    retryCount: document.getElementById('retryCount'),
                    retryDelay: document.getElementById('retryDelay'),

                    chatMessages: document.getElementById('chatMessages'),
                    openingMessage: document.getElementById('openingMessage'),
                    statusIndicator: document.getElementById('statusIndicator'),
                    roundCounter: document.getElementById('roundCounter'),

                    saveConfig: document.getElementById('saveConfig'),
                    startChat: document.getElementById('startChat'),
                    pauseChat: document.getElementById('pauseChat'),
                    resumeChat: document.getElementById('resumeChat'),
                    stopChat: document.getElementById('stopChat'),
                    exportChat: document.getElementById('exportChat'),
                    clearChat: document.getElementById('clearChat'),
                    retryChat: document.getElementById('retryChat'),
                    sendOpening: document.getElementById('sendOpening')
                };
            }

            setupEventListeners() {
                // ç«¯ç‚¹ç±»å‹å˜åŒ–æ—¶æ›´æ–°é»˜è®¤å€¼
                this.elements.endpointTypeA.addEventListener('change', () => this.updateDefaults('A'));
                this.elements.endpointTypeB.addEventListener('change', () => this.updateDefaults('B'));

                // æŒ‰é’®äº‹ä»¶
                this.elements.saveConfig.addEventListener('click', () => this.saveConfiguration());
                this.elements.startChat.addEventListener('click', () => this.startDialogue());
                this.elements.pauseChat.addEventListener('click', () => this.pauseDialogue());
                this.elements.resumeChat.addEventListener('click', () => this.resumeDialogue());
                this.elements.stopChat.addEventListener('click', () => this.stopDialogue());
                this.elements.exportChat.addEventListener('click', () => this.exportDialogue());
                this.elements.clearChat.addEventListener('click', () => this.clearDialogue());
                this.elements.retryChat.addEventListener('click', () => this.retryLastRequest());
                this.elements.sendOpening.addEventListener('click', () => this.sendOpeningMessage());

                // å›è½¦å‘é€
                this.elements.openingMessage.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendOpeningMessage();
                });
            }

            updateDefaults(aiType) {
                const endpointType = this.elements[`endpointType${aiType}`].value;

                if (endpointType === 'openai') {
                    this.elements[`apiUrl${aiType}`].value = 'https://xxx.com';
                    this.elements[`apiKey${aiType}`].value = 'sk-xxx';
                    this.elements[`model${aiType}`].value = 'gpt-4';
                } else if (endpointType === 'gemini') {
                    this.elements[`apiUrl${aiType}`].value = 'https://generativelanguage.googleapis.com';
                    this.elements[`apiKey${aiType}`].value = 'akxxx';
                    this.elements[`model${aiType}`].value = 'gemini-2.5-pro';
                }
            }

            loadConfiguration() {
                const saved = localStorage.getItem('aiDialogueConfig');
                if (saved) {
                    const config = JSON.parse(saved);
                    Object.keys(config).forEach(key => {
                        if (this.elements[key]) {
                            this.elements[key].value = config[key];
                        }
                    });
                } else {
                    // è®¾ç½®é»˜è®¤å€¼
                    this.updateDefaults('A');
                    this.updateDefaults('B');
                }
            }

            saveConfiguration() {
                const config = {};
                Object.keys(this.elements).forEach(key => {
                    if (this.elements[key].value !== undefined) {
                        config[key] = this.elements[key].value;
                    }
                });
                localStorage.setItem('aiDialogueConfig', JSON.stringify(config));
                this.showMessage('é…ç½®å·²ä¿å­˜', 'success');
            }

            /**
             * æ·»åŠ æˆ–æ›´æ–°æ¶ˆæ¯åˆ°UIï¼Œæ”¯æŒæµå¼æ›´æ–°
             * @param {string} speaker - å‘è¨€è€…
             * @param {string} content - æ¶ˆæ¯å†…å®¹
             * @param {boolean} isStreaming - æ˜¯å¦ä¸ºæµå¼æ›´æ–°
             * @param {string|null} messageId - æ¶ˆæ¯IDï¼Œç”¨äºæ›´æ–°ç°æœ‰æ¶ˆæ¯
             */
            addMessageToUI(speaker, content, isStreaming = false, messageId = null) {
                const messagesContainer = this.elements.chatMessages;

                if (messageId) {
                    // æ›´æ–°ç°æœ‰æ¶ˆæ¯
                    const existingMessage = document.getElementById(messageId);
                    if (existingMessage) {
                        const contentElement = existingMessage.querySelector('.message-content');
                        if (contentElement) {
                            // å¯¹äºæµå¼æ›´æ–°ï¼Œç›´æ¥è®¾ç½®æ–‡æœ¬ï¼Œé¿å…é‡å¤è§£æMarkdown
                            if (isStreaming) {
                                contentElement.textContent = content;
                            } else {
                                // æœ€ç»ˆå®Œæˆæ—¶è§£æMarkdown
                                contentElement.innerHTML = marked.parse(content);
                            }
                        }
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        return messageId;
                    }
                }

                // åˆ›å»ºæ–°æ¶ˆæ¯
                const newMessageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                const messageDiv = document.createElement('div');

                const isAIB = speaker === 'AI B';
                messageDiv.className = `message ${isAIB ? 'message-b' : 'message-a'}`;
                messageDiv.id = newMessageId;

                // å¦‚æœæ˜¯loadingçŠ¶æ€ï¼Œä½¿ç”¨ç‰¹æ®Šæ ·å¼
                if (content === '[æ€è€ƒä¸­...]' || content.includes('æ­£åœ¨')) {
                    messageDiv.classList.add('message-loading');
                }

                messageDiv.innerHTML = `<div class="message-header">${speaker}</div><div class="message-content">${isStreaming ? content : marked.parse(content)}</div>`;

                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;

                return newMessageId;
            }

            /**
             * æ·»åŠ loadingå ä½æ¶ˆæ¯
             * @param {string} speaker - å‘è¨€è€…
             * @return {string} æ¶ˆæ¯ID
             */
            addLoadingMessage(speaker) {
                const loadingContent = `
                    <div class="typing-indicator">
                        æ­£åœ¨æ€è€ƒä¸­
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                `;

                const messageId = this.addMessageToUI(speaker, '', true);

                // ç›´æ¥è®¾ç½®loadingå†…å®¹åˆ°contentåŒºåŸŸ
                const messageElement = document.getElementById(messageId);
                if (messageElement) {
                    const contentElement = messageElement.querySelector('.message-content');
                    if (contentElement) {
                        contentElement.innerHTML = loadingContent;
                    }
                }

                return messageId;
            }

            async startDialogue() {
                if (!this.validateConfiguration()) return;

                this.maxRounds = parseInt(this.elements.maxRounds.value) || 0;
                this.contextLimit = parseInt(this.elements.contextLimit.value) || 0; // æ–°å¢
                this.retryCount = parseInt(this.elements.retryCount.value) || 3;
                this.retryDelay = parseInt(this.elements.retryDelay.value) * 1000 || 2000;

                this.isRunning = true;
                this.isPaused = false;
                this.needsReset = false;
                this.updateUI();

                await this.runDialogue();
            }

            pauseDialogue() {
                this.isPaused = true;
                this.updateUI();
            }

            resumeDialogue() {
                this.isPaused = false;
                if (this.needsReset) {
                    this.currentRound = 0;
                    this.needsReset = false;
                }

                this.updateNextSpeaker();
                this.updateUI();
                this.runDialogue();
            }

            updateNextSpeaker() {
                if (this.conversations.length === 0) {
                    this.nextSpeaker = 'B';
                    return;
                }

                const lastSpeaker = this.conversations[this.conversations.length - 1].speaker;

                if (lastSpeaker === 'AI A') {
                    this.nextSpeaker = 'B';
                } else {
                    this.nextSpeaker = 'A';
                }
            }

            stopDialogue() {
                this.isRunning = false;
                this.isPaused = false;
                // æ¸…é™¤å½“å‰æµå¼æ¶ˆæ¯ID
                this.currentStreamingMessageId = null;
                this.updateUI();
            }

            async sendOpeningMessage() {
                const message = this.elements.openingMessage.value.trim();
                if (!message) {
                    this.showMessage('è¯·è¾“å…¥å¼€åœºç™½', 'error');
                    return;
                }

                if (!this.validateConfiguration()) return;

                // æ¸…ç©ºä¹‹å‰çš„å¯¹è¯
                this.conversations = [];
                this.currentRound = 0;
                this.openingMessage = message;
                this.nextSpeaker = 'B';
                this.currentStreamingMessageId = null;

                this.elements.chatMessages.innerHTML = '';
                this.elements.openingMessage.value = '';

                // AI A æœ¬åœ°å‘å‡ºå¼€åœºç™½ï¼ˆä¸è°ƒç”¨APIï¼‰
                this.addMessageToUI('AI A', message);
                this.conversations.push({
                    role: 'assistant',
                    content: message,
                    speaker: 'AI A'
                });

                // è®¾ç½®å¯¹è¯å‚æ•°
                this.maxRounds = parseInt(this.elements.maxRounds.value) || 0;
                this.contextLimit = parseInt(this.elements.contextLimit.value) || 0; // æ–°å¢
                this.retryCount = parseInt(this.elements.retryCount.value) || 3;
                this.retryDelay = parseInt(this.elements.retryDelay.value) * 1000 || 2000;

                // ç›´æ¥å¼€å§‹å¯¹è¯ï¼ŒAI B å“åº”
                this.isRunning = true;
                this.isPaused = false;
                this.needsReset = false;
                this.updateUI();

                await this.runDialogue();
            }

            async runDialogue() {
                while (this.isRunning && !this.isPaused) {
                    if (this.maxRounds > 0 && this.currentRound >= this.maxRounds) {
                        this.isPaused = true;
                        this.needsReset = true;
                        this.updateUI();
                        break;
                    }

                    const currentAI = this.nextSpeaker;
                    const success = await this.callAI(currentAI);

                    if (!success) {
                        this.isPaused = true;
                        this.updateUI();
                        break;
                    }

                    this.currentRound++;
                    this.updateRoundCounter();

                    // åˆ‡æ¢ä¸‹ä¸€ä¸ªå‘è¨€è€…
                    this.nextSpeaker = this.nextSpeaker === 'A' ? 'B' : 'A';

                    // æ·»åŠ å»¶è¿Ÿé¿å…è¿‡å¿«è¯·æ±‚
                    await this.sleep(1000);
                }
            }
            // ====== ä¿®å¤åçš„APIè°ƒç”¨æ–¹æ³• ======

            async callAI(aiType) {
                const config = this.getAIConfig(aiType);
                const messages = this.buildMessages(aiType);

                this.currentRetries = 0;

                // æ·»åŠ loadingæ¶ˆæ¯
                const loadingMessageId = this.addLoadingMessage(`AI ${aiType}`);
                this.currentStreamingMessageId = loadingMessageId;

                while (this.currentRetries <= this.retryCount) {
                    try {
                        this.setStatus('è¿è¡Œä¸­', 'running');
                        const response = await this.makeAPIRequest(config, messages, `AI ${aiType}`, loadingMessageId);

                        if (response && response.content) {
                            // æµå¼å“åº”åœ¨makeAPIRequestä¸­å·²ç»å®æ—¶æ›´æ–°äº†UI
                            // è¿™é‡Œåªéœ€è¦æ·»åŠ åˆ°å¯¹è¯å†å²ä¸­
                            this.conversations.push({
                                role: 'assistant',
                                content: response.content,
                                speaker: `AI ${aiType}`
                            });

                            this.setStatus('å°±ç»ª', 'ready');
                            this.currentStreamingMessageId = null;
                            return true;
                        }

                        throw new Error('å“åº”å†…å®¹ä¸ºç©º');

                    } catch (error) {
                        console.error(`AI ${aiType} è°ƒç”¨å¤±è´¥:`, error);
                        this.currentRetries++;

                        if (this.currentRetries <= this.retryCount) {
                            // æ›´æ–°loadingæ¶ˆæ¯æ˜¾ç¤ºé‡è¯•ä¿¡æ¯
                            this.addMessageToUI(`AI ${aiType}`, `è°ƒç”¨å¤±è´¥ï¼Œ${this.retryDelay/1000}ç§’åé‡è¯• (${this.currentRetries}/${this.retryCount})`, true, loadingMessageId);
                            this.showMessage(`AI ${aiType} è°ƒç”¨å¤±è´¥ï¼Œ${this.retryDelay/1000}ç§’åé‡è¯• (${this.currentRetries}/${this.retryCount})`, 'error');
                            await this.sleep(this.retryDelay);
                        } else {
                            // é‡è¯•æ¬¡æ•°ç”¨å®Œï¼Œæ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
                            this.addMessageToUI(`AI ${aiType}`, `âŒ è°ƒç”¨å¤±è´¥ï¼Œå·²è¾¾é‡è¯•ä¸Šé™: ${error.message}`, false, loadingMessageId);
                            this.showMessage(`AI ${aiType} è°ƒç”¨å¤±è´¥ï¼Œå·²è¾¾é‡è¯•ä¸Šé™`, 'error');
                            this.setStatus('é”™è¯¯', 'stopped');
                            this.currentStreamingMessageId = null;
                            return false;
                        }
                    }
                }

                return false;
            }

            async makeAPIRequest(config, messages, speaker, messageId) {
                if (config.endpointType === 'openai') {
                    return await this.callOpenAI(config, messages, speaker, messageId);
                } else if (config.endpointType === 'gemini') {
                    return await this.callGemini(config, messages, speaker, messageId);
                }
            }

            async callOpenAI(config, messages, speaker, messageId) {
                const url = config.apiUrl.endsWith('/v1/chat/completions') ? 
                    config.apiUrl : `${config.apiUrl}/v1/chat/completions`;

                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apiKey}`
                    },
                    body: JSON.stringify({
                        model: config.model,
                        messages: messages,
                        stream: true,
                        temperature: 0.7
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                return await this.handleOpenAIStreamResponse(response, speaker, messageId);
            }

            async callGemini(config, messages, speaker, messageId) {
                const url = `${config.apiUrl}/v1beta/models/${config.model}:streamGenerateContent?alt=sse&key=${config.apiKey}`;

                // è½¬æ¢æ¶ˆæ¯æ ¼å¼ä¸ºGeminiæ ¼å¼
                const contents = messages.filter(m => m.role !== 'system').map(m => ({
                    role: m.role === 'assistant' ? 'model' : 'user',
                    parts: [{ text: m.content }]
                }));

                const systemInstruction = messages.find(m => m.role === 'system');
                const requestBody = {
                    contents: contents,
                    generationConfig: {
                        temperature: 0.7
                    }
                };

                if (systemInstruction) {
                    requestBody.systemInstruction = {
                        parts: [{ text: systemInstruction.content }]
                    };
                }

                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorText}`);
                }

                return await this.handleGeminiStreamResponse(response, speaker, messageId);
            }

            // ä¿®å¤åçš„OpenAIæµå¼å“åº”å¤„ç†
            async handleOpenAIStreamResponse(response, speaker, messageId) {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let content = '';
                let isFirstChunk = true;

                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6).trim();
                                if (data === '[DONE]') continue;
                                if (!data) continue;

                                try {
                                    const parsed = JSON.parse(data);
                                    const delta = parsed.choices?.[0]?.delta?.content;
                                    if (delta) {
                                        content += delta;

                                        // å®æ—¶æ›´æ–°UI - ç¬¬ä¸€æ¬¡æ›´æ–°æ—¶æ¸…é™¤loadingçŠ¶æ€
                                        if (isFirstChunk) {
                                            // ç§»é™¤loadingæ ·å¼
                                            const messageElement = document.getElementById(messageId);
                                            if (messageElement) {
                                                messageElement.classList.remove('message-loading');
                                            }
                                            isFirstChunk = false;
                                        }

                                        // å®æ—¶æ›´æ–°æ¶ˆæ¯å†…å®¹
                                        this.addMessageToUI(speaker, content, true, messageId);
                                    }
                                } catch (e) {
                                    console.warn('è§£æOpenAIæµå¼å“åº”å¤±è´¥:', e, 'data:', data);
                                }
                            }
                        }
                    }
                } finally {
                    reader.releaseLock();
                }

                // æœ€ç»ˆå¤„ç†Markdown
                if (content) {
                    this.addMessageToUI(speaker, content, false, messageId);
                }

                return { content: content.trim() };
            }

            // ä¿®å¤åçš„Geminiæµå¼å“åº”å¤„ç† - è¿™æ˜¯å…³é”®ä¿®å¤
            async handleGeminiStreamResponse(response, speaker, messageId) {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let content = '';
                let buffer = '';
                let isFirstChunk = true;

                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value, { stream: true });
                        buffer += chunk;

                        // æŒ‰è¡Œåˆ†å‰²å¤„ç†
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || ''; // ä¿ç•™æœ€åä¸€ä¸ªå¯èƒ½ä¸å®Œæ•´çš„è¡Œ

                        for (const line of lines) {
                            if (line.trim() === '') continue;

                            // Geminiçš„æµå¼å“åº”æ ¼å¼é€šå¸¸æ˜¯ç›´æ¥çš„JSONï¼Œä¸éœ€è¦data:å‰ç¼€
                            try {
                                let jsonStr = line.trim();

                                // å¦‚æœè¡Œä»¥data:å¼€å¤´ï¼Œå»æ‰è¿™ä¸ªå‰ç¼€
                                if (jsonStr.startsWith('data: ')) {
                                    jsonStr = jsonStr.substring(6);
                                }

                                if (!jsonStr || jsonStr === '[DONE]') continue;

                                const parsed = JSON.parse(jsonStr);

                                // Gemini APIçš„æ ‡å‡†å“åº”ç»“æ„
                                const text = parsed.candidates?.[0]?.content?.parts?.[0]?.text;

                                if (text) {
                                    content += text;

                                    // å®æ—¶æ›´æ–°UI - ç¬¬ä¸€æ¬¡æ›´æ–°æ—¶æ¸…é™¤loadingçŠ¶æ€
                                    if (isFirstChunk) {
                                        const messageElement = document.getElementById(messageId);
                                        if (messageElement) {
                                            messageElement.classList.remove('message-loading');
                                        }
                                        isFirstChunk = false;
                                    }

                                    // å®æ—¶æ›´æ–°æ¶ˆæ¯å†…å®¹
                                    this.addMessageToUI(speaker, content, true, messageId);
                                }
                            } catch (e) {
                                // å¿½ç•¥JSONè§£æé”™è¯¯ï¼Œç»§ç»­å¤„ç†ä¸‹ä¸€è¡Œ
                                console.warn('è§£æGeminiæµå¼å“åº”å¤±è´¥:', e, 'line:', line);
                            }
                        }
                    }

                    // å¤„ç†bufferä¸­å‰©ä½™çš„å†…å®¹
                    if (buffer.trim()) {
                        try {
                            let jsonStr = buffer.trim();
                            if (jsonStr.startsWith('data: ')) {
                                jsonStr = jsonStr.substring(6);
                            }

                            if (jsonStr && jsonStr !== '[DONE]') {
                                const parsed = JSON.parse(jsonStr);
                                const text = parsed.candidates?.[0]?.content?.parts?.[0]?.text;
                                if (text) {
                                    content += text;
                                    this.addMessageToUI(speaker, content, true, messageId);
                                }
                            }
                        } catch (e) {
                            console.warn('è§£æGeminiæµå¼å“åº”å‰©ä½™å†…å®¹å¤±è´¥:', e);
                        }
                    }

                } finally {
                    reader.releaseLock();
                }

                // æœ€ç»ˆå¤„ç†Markdown
                if (content) {
                    this.addMessageToUI(speaker, content, false, messageId);
                } else {
                    // å¦‚æœæ²¡æœ‰æ”¶åˆ°ä»»ä½•å†…å®¹ï¼Œæ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                    this.addMessageToUI(speaker, 'âŒ æœªæ”¶åˆ°å“åº”å†…å®¹', false, messageId);
                    throw new Error('Gemini APIæœªè¿”å›ä»»ä½•å†…å®¹');
                }

                return { content: content.trim() };
            }
            // ====== è¾…åŠ©æ–¹æ³•å’Œäº‹ä»¶å¤„ç† ======

            getAIConfig(aiType) {
                return {
                    endpointType: this.elements[`endpointType${aiType}`].value,
                    apiUrl: this.elements[`apiUrl${aiType}`].value,
                    apiKey: this.elements[`apiKey${aiType}`].value,
                    model: this.elements[`model${aiType}`].value,
                    prompt: this.elements[`prompt${aiType}`].value
                };
            }

            /**
             * æ„å»ºAPIè¯·æ±‚çš„æ¶ˆæ¯æ•°ç»„ï¼Œæ”¯æŒä¸Šä¸‹æ–‡é™åˆ¶
             * @param {string} aiType - AIç±»å‹ ('A' æˆ– 'B')
             * @returns {Array} æ¶ˆæ¯æ•°ç»„
             */
            buildMessages(aiType) {
                const config = this.getAIConfig(aiType);
                const messages = [];

                // æ·»åŠ ç³»ç»Ÿæç¤ºè¯
                if (config.prompt) {
                    messages.push({
                        role: 'system',
                        content: config.prompt
                    });
                }

                // è·å–éœ€è¦å‘é€çš„å¯¹è¯å†å²
                let conversationsToSend = this.conversations;

                // åº”ç”¨ä¸Šä¸‹æ–‡é™åˆ¶
                if (this.contextLimit > 0 && this.conversations.length > this.contextLimit) {
                    // å–æœ€è¿‘çš„ contextLimit æ¡æ¶ˆæ¯
                    conversationsToSend = this.conversations.slice(-this.contextLimit);
                    
                    // åœ¨UIä¸­æ˜¾ç¤ºä¸Šä¸‹æ–‡æˆªæ–­ä¿¡æ¯ï¼ˆä»…åœ¨ç¬¬ä¸€æ¬¡æˆªæ–­æ—¶ï¼‰
                    if (this.conversations.length === this.contextLimit + 1) {
                        this.addSystemMessage(`ğŸ“‹ å¯ç”¨ä¸Šä¸‹æ–‡é™åˆ¶ï¼šä»…ä½¿ç”¨æœ€è¿‘ ${this.contextLimit} æ¡æ¶ˆæ¯`, 'info');
                    }
                }

                // æ„å»ºäº¤æ›¿çš„ç”¨æˆ·/åŠ©æ‰‹å¯¹è¯
                // ä»å½“å‰AIçš„è§’åº¦çœ‹ï¼Œå¯¹æ–¹éƒ½æ˜¯userï¼Œè‡ªå·±æ˜¯assistant
                for (let i = 0; i < conversationsToSend.length; i++) {
                    const conv = conversationsToSend[i];
                    const speakerType = conv.speaker === `AI ${aiType}` ? 'assistant' : 'user';

                    messages.push({
                        role: speakerType,
                        content: conv.content
                    });
                }

                // åœ¨æ§åˆ¶å°è¾“å‡ºdebugä¿¡æ¯
                console.log(`AI ${aiType} å‘é€æ¶ˆæ¯æ•°é‡: ${messages.length}`, {
                    ç³»ç»Ÿæ¶ˆæ¯: messages.filter(m => m.role === 'system').length,
                    å¯¹è¯æ¶ˆæ¯: messages.filter(m => m.role !== 'system').length,
                    æ€»å¯¹è¯æ¡æ•°: this.conversations.length,
                    å‘é€å¯¹è¯æ¡æ•°: conversationsToSend.length,
                    ä¸Šä¸‹æ–‡é™åˆ¶: this.contextLimit || 'æ— é™åˆ¶'
                });

                return messages;
            }

            validateConfiguration() {
                const requiredFields = ['apiUrlA', 'apiKeyA', 'modelA', 'apiUrlB', 'apiKeyB', 'modelB'];

                for (const field of requiredFields) {
                    if (!this.elements[field].value.trim()) {
                        this.showMessage(`è¯·å¡«å†™å®Œæ•´çš„é…ç½®ä¿¡æ¯: ${field}`, 'error');
                        return false;
                    }
                }

                return true;
            }

            setStatus(text, type) {
                this.elements.statusIndicator.textContent = text;
                this.elements.statusIndicator.className = `status-indicator status-${type}`;
            }

            updateRoundCounter() {
                this.elements.roundCounter.textContent = this.currentRound;
            }

            updateUI() {
                const isRunning = this.isRunning && !this.isPaused;
                const isStopped = !this.isRunning;
                const isPaused = this.isPaused;

                this.elements.startChat.style.display = isStopped ? 'inline-block' : 'none';
                this.elements.pauseChat.style.display = isRunning ? 'inline-block' : 'none';
                this.elements.resumeChat.style.display = isPaused ? 'inline-block' : 'none';
                this.elements.retryChat.style.display = isPaused ? 'inline-block' : 'none';

                // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
                if (isRunning) {
                    this.setStatus('è¿è¡Œä¸­', 'running');
                } else if (isPaused) {
                    this.setStatus('æš‚åœ', 'stopped');
                } else {
                    this.setStatus('å°±ç»ª', 'ready');
                }
            }

            async retryLastRequest() {
                if (this.isPaused) {
                    // é‡è¯•æ—¶ä¹Ÿéœ€è¦æ›´æ–°ä¸‹ä¸€ä¸ªå‘è¨€è€…
                    this.updateNextSpeaker();
                    this.resumeDialogue();
                }
            }

            exportDialogue() {
                let exportText = '# AIåŒäººå¯¹è¯è®°å½•\n\n';
                exportText += `å¯¼å‡ºæ—¶é—´: ${new Date().toLocaleString()}\n`;
                exportText += `æ€»è½®æ¬¡: ${this.currentRound}\n`;
                exportText += `ä¸Šä¸‹æ–‡é™åˆ¶: ${this.contextLimit || 'æ— é™åˆ¶'}\n\n`;

                this.conversations.forEach((conv, index) => {
                    exportText += `## ${conv.speaker}\n\n${conv.content}\n\n`;
                });

                const blob = new Blob([exportText], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ai_dialogue_${new Date().getTime()}.txt`;
                a.click();
                URL.revokeObjectURL(url);
            }

            clearDialogue() {
                if (confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰å¯¹è¯è®°å½•å—ï¼Ÿ')) {
                    this.conversations = [];
                    this.currentRound = 0;
                    this.isRunning = false;
                    this.isPaused = false;
                    this.openingMessage = '';
                    this.nextSpeaker = 'B';
                    this.currentStreamingMessageId = null;

                    this.elements.chatMessages.innerHTML = `
                        <div style="text-align: center; color: #666; margin-top: 50px;">
                            <h3>æ¬¢è¿ä½¿ç”¨AIåŒäººå¯¹è¯ç³»ç»Ÿ</h3>
                            <p>è¯·å…ˆé…ç½®AIå‚æ•°ï¼Œç„¶åè¾“å…¥å¼€åœºç™½å¼€å§‹å¯¹è¯</p>
                        </div>
                    `;

                    this.updateRoundCounter();
                    this.updateUI();
                }
            }

            // æ”¹è¿›çš„æ¶ˆæ¯æ˜¾ç¤ºæ–¹æ³•
            showMessage(message, type) {
                // åœ¨èŠå¤©ç•Œé¢æ˜¾ç¤ºæ¶ˆæ¯è€Œä¸æ˜¯å¼¹å‡ºæ¡†
                if (type === 'error') {
                    this.addSystemMessage(`âŒ ${message}`, 'error');
                } else if (type === 'success') {
                    this.addSystemMessage(`âœ… ${message}`, 'success');
                } else {
                    this.addSystemMessage(`â„¹ï¸ ${message}`, 'info');
                }
            }

            // æ–°å¢ç³»ç»Ÿæ¶ˆæ¯æ˜¾ç¤ºæ–¹æ³•
            addSystemMessage(message, type = 'info') {
                const messagesContainer = this.elements.chatMessages;
                const messageDiv = document.createElement('div');

                const colorMap = {
                    'error': '#e74c3c',
                    'success': '#27ae60',
                    'info': '#3498db'
                };

                messageDiv.style.cssText = `
                    margin: 10px 0;
                    padding: 8px 12px;
                    border-radius: 4px;
                    background: rgba(${type === 'error' ? '231, 76, 60' : type === 'success' ? '39, 174, 96' : '52, 152, 219'}, 0.1);
                    border-left: 3px solid ${colorMap[type]};
                    color: ${colorMap[type]};
                    font-size: 13px;
                    text-align: center;
                `;

                messageDiv.textContent = message;
                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;

                // 5ç§’åè‡ªåŠ¨ç§»é™¤ç³»ç»Ÿæ¶ˆæ¯
                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        messageDiv.parentNode.removeChild(messageDiv);
                    }
                }, 5000);
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // åˆå§‹åŒ–ç³»ç»Ÿ
        document.addEventListener('DOMContentLoaded', () => {
            new AIDialogueSystem();
        });
    </script>
</body>
</html>