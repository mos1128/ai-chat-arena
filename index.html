<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIåŒäººå¯¹è¯ç³»ç»Ÿ</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
        }

        .container {
            display: flex;
            width: 100%;
            height: 100vh;
            background: white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        /* å·¦ä¾§é…ç½®æ  */
        .config-panel {
            width: 350px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            padding: 20px;
            overflow-y: auto;
        }

        .config-section {
            margin-bottom: 25px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .config-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
            font-size: 13px;
        }

        .form-input, .form-select, .form-textarea {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            transition: border-color 0.3s;
        }

        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: #3498db;
        }

        .form-textarea {
            height: 60px;
            resize: vertical;
        }

        .api-hint {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
            font-style: italic;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #219a52;
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .btn-warning:hover {
            background: #e67e22;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* å³ä¾§å¯¹è¯æ  */
        .chat-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            min-width: 0;
        }

        .chat-header {
            background: #2c3e50;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-title {
            font-size: 18px;
            font-weight: 600;
        }

        .status-indicator {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-ready {
            background: #27ae60;
        }

        .status-running {
            background: #f39c12;
        }

        .status-stopped {
            background: #e74c3c;
        }

        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            background: #f8f9fa;
            min-width: 0;
        }

        .message {
            margin-bottom: 15px;
            padding: 12px 15px;
            border-radius: 8px;
            max-width: 80%;
            overflow: hidden;
            word-wrap: break-word;
            min-width: 0;
        }

        .message-a {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
        }

        .message-b {
            background: #f3e5f5;
            border-left: 4px solid #9c27b0;
            margin-left: auto;
        }

        /* æ–°å¢ï¼šloadingæ¶ˆæ¯æ ·å¼ */
        .message-loading {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            opacity: 0.8;
        }

        .message-header {
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .message-content {
            line-height: 1.6;
            color: #333;
            max-width: 100%;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        .message-content h1, .message-content h2, .message-content h3 {
            margin-top: 15px;
            margin-bottom: 10px;
        }

        .message-content h1 {
            font-size: 20px;
        }

        .message-content h2 {
            font-size: 18px;
        }

        .message-content h3 {
            font-size: 16px;
        }

        .message-content p {
            margin-bottom: 10px;
        }

        .message-content code {
            background: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            word-break: break-word;
        }

        .message-content pre {
            background: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            overflow-y: hidden;
            margin: 10px 0;
            max-width: 100%;
            white-space: pre;
        }

        .message-content pre code {
            background: transparent;
            padding: 0;
            white-space: pre;
            word-break: normal;
            display: block;
        }

        .chat-input {
            padding: 20px;
            border-top: 1px solid #e9ecef;
            background: white;
        }

        .input-group {
            display: flex;
            gap: 10px;
        }

        .input-field {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        /* æ”¹è¿›çš„loadingåŠ¨ç”» */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* æ–°å¢ï¼šæ‰“å­—æœºæ•ˆæœçš„loading */
        .typing-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .typing-dot {
            width: 6px;
            height: 6px;
            background: #999;
            border-radius: 50%;
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: scale(1);
                opacity: 0.5;
            }
            30% {
                transform: scale(1.2);
                opacity: 1;
            }
        }

        .error-message {
            color: #e74c3c;
            font-size: 12px;
            margin-top: 5px;
        }

        .round-counter {
            background: rgba(255,255,255,0.2);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        /* å‹ç¼©æ¶ˆæ¯æ ·å¼ */
        .message-compressed {
            border-left-color: #f39c12 !important;
            background: linear-gradient(90deg, #fff3cd 0%, #f8f9fa 100%) !important;
        }

        .compression-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            margin-left: 8px;
            font-size: 11px;
            color: #f39c12;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 10px;
            background: rgba(243, 156, 18, 0.1);
            border: 1px solid rgba(243, 156, 18, 0.3);
            transition: all 0.2s;
        }

        .compression-indicator:hover {
            background: rgba(243, 156, 18, 0.2);
            transform: scale(1.05);
        }

        .compression-icon {
            font-size: 12px;
        }

        /* åŸå§‹å†…å®¹å¼¹çª— */
        .original-content-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 80%;
            max-height: 80%;
            z-index: 1000;
            display: none;
        }

        .popup-header {
            padding: 15px 20px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f8f9fa;
            border-radius: 8px 8px 0 0;
        }

        .popup-title {
            font-weight: 600;
            color: #2c3e50;
            margin: 0;
        }

        .popup-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #6c757d;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .popup-close:hover {
            background: #e9ecef;
            color: #495057;
        }

        .popup-content {
            padding: 20px;
            overflow-y: auto;
            max-height: 60vh;
        }

        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            display: none;
        }

        .original-message {
            margin-bottom: 15px;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #3498db;
            background: #f8f9fa;
        }

        .original-message-header {
            font-weight: 600;
            margin-bottom: 8px;
            color: #2c3e50;
            font-size: 14px;
        }

        .original-message-content {
            line-height: 1.6;
            color: #333;
        }

        .compression-stats {
            margin-top: 15px;
            padding: 10px;
            background: #e3f2fd;
            border-radius: 4px;
            font-size: 12px;
            color: #1976d2;
        }

        /* æ¶ˆæ¯æ“ä½œæŒ‰é’®æ ·å¼ */
        .message-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .message-action-btn {
            padding: 4px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .message-action-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .message-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-retry {
            background: #f39c12;
            color: white;
        }

        .btn-retry:hover:not(:disabled) {
            background: #e67e22;
        }

        .btn-copy {
            background: #3498db;
            color: white;
        }

        .btn-copy:hover:not(:disabled) {
            background: #2980b9;
        }

        /* Tabå¯¼èˆªæ ·å¼ */
        .config-tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }

        .tab-button {
            flex: 1;
            padding: 10px 15px;
            border: none;
            background: transparent;
            color: #666;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 2px solid transparent;
        }

        .tab-button:hover {
            color: #3498db;
            background: rgba(52, 152, 219, 0.1);
        }

        .tab-button.active {
            color: #3498db;
            border-bottom-color: #3498db;
            background: rgba(52, 152, 219, 0.1);
        }

        /* Tabå†…å®¹å®¹å™¨ */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* ä»£ç†é…ç½®é¡¹æ ·å¼ */
        .proxy-item {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            margin-bottom: 15px;
            padding: 15px;
            position: relative;
        }

        .proxy-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #f0f0f0;
        }

        .proxy-item-title {
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
        }

        .proxy-item-actions {
            display: flex;
            gap: 8px;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 3px;
        }

        .proxy-form-row {
            display: flex;
            gap: 10px;
            margin-bottom: 12px;
        }

        .proxy-form-row .form-group {
            flex: 1;
            margin-bottom: 0;
        }


    </style>
</head>
<body>    <div class="container">
        <!-- å·¦ä¾§é…ç½®æ  -->
        <div class="config-panel">
            <!-- Tabåˆ‡æ¢å¯¼èˆª -->
            <div class="config-tabs">
                <button class="tab-button active" data-tab="ai-config">AIé…ç½®</button>
                <button class="tab-button" data-tab="proxy-config">ä»£ç†é…ç½®</button>
            </div>

            <!-- Tabå†…å®¹å®¹å™¨ -->
            <div class="tab-content" id="ai-config" style="display: block;">
                <!-- æ“ä½œæŒ‰é’® -->
                <div class="config-section">
                    <div class="config-title">æ“ä½œ</div>
                    <button class="btn btn-warning" id="pauseResumeChat">æš‚åœ</button>
                    <button class="btn btn-primary" id="exportChat">å¯¼å‡ºå¯¹è¯</button>
                    <button class="btn btn-danger" id="clearChat">æ¸…é™¤å¯¹è¯</button>
                    <button class="btn btn-warning" id="retryChat" style="display:none;">é‡è¯•</button>
                </div>

                <!-- é…ç½®ç®¡ç† -->
                <div class="config-section">
                    <div class="config-title">é…ç½®ç®¡ç†</div>
                    <button class="btn btn-primary" id="saveConfig">ä¿å­˜é…ç½®</button>
                    <button class="btn btn-primary" id="exportConfig">å¯¼å‡º</button>
                    <button class="btn btn-success" id="importConfig">å¯¼å…¥</button>
                    <input type="file" id="importConfigFile" accept=".json" style="display: none;">
                </div>

                <!-- AI A é…ç½® -->
                <div class="config-section">
                    <div class="config-title">AI A é…ç½®</div>
                    <div class="form-group">
                        <label class="form-label">é€‰æ‹©ä»£ç†</label>
                        <select class="form-select" id="proxySelectA">
                            <option value="">è¯·é€‰æ‹©ä»£ç†é…ç½®</option>
                        </select>
                        <div class="api-hint">ä»ä»£ç†é…ç½®é¡µé¢ä¸­é€‰æ‹©ä¸€ä¸ªå·²é…ç½®çš„ä»£ç†</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">æç¤ºè¯</label>
                        <textarea class="form-textarea" id="promptA" placeholder="AI Açš„ç³»ç»Ÿæç¤ºè¯"></textarea>
                    </div>
                </div>

                <!-- AI B é…ç½® -->
                <div class="config-section">
                    <div class="config-title">AI B é…ç½®</div>
                    <div class="form-group">
                        <label class="form-label">é€‰æ‹©ä»£ç†</label>
                        <select class="form-select" id="proxySelectB">
                            <option value="">è¯·é€‰æ‹©ä»£ç†é…ç½®</option>
                        </select>
                        <div class="api-hint">ä»ä»£ç†é…ç½®é¡µé¢ä¸­é€‰æ‹©ä¸€ä¸ªå·²é…ç½®çš„ä»£ç†</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">æç¤ºè¯</label>
                        <textarea class="form-textarea" id="promptB" placeholder="AI Bçš„ç³»ç»Ÿæç¤ºè¯"></textarea>
                    </div>
                </div>

                <!-- ç³»ç»ŸAIé…ç½® -->
                <div class="config-section">
                    <div class="config-title">ç³»ç»ŸAIé…ç½® (ç”¨äºå‹ç¼©ç­‰åŠŸèƒ½)</div>
                    <div class="form-group">
                        <label class="form-label">é€‰æ‹©ä»£ç†</label>
                        <select class="form-select" id="proxySelectSystem">
                            <option value="">è¯·é€‰æ‹©ä»£ç†é…ç½®</option>
                        </select>
                        <div class="api-hint">ä»ä»£ç†é…ç½®é¡µé¢ä¸­é€‰æ‹©ä¸€ä¸ªå·²é…ç½®çš„ä»£ç†</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">æç¤ºè¯</label>
                        <textarea class="form-textarea" id="promptSystem" placeholder="ç³»ç»ŸAIçš„å‹ç¼©æç¤ºè¯"></textarea>
                    </div>
                </div>

            <!-- å¯¹è¯æ§åˆ¶ -->
            <div class="config-section">
                <div class="config-title">å¯¹è¯æ§åˆ¶</div>
                <div class="form-group">
                    <label class="form-label">æœ€å¤§è½®æ¬¡ (0=æ— é™åˆ¶)</label>
                    <input type="number" class="form-input" id="maxRounds" value="0" min="0">
                </div>
                <div class="form-group">
                    <label class="form-label">ä¸Šä¸‹æ–‡æ¶ˆæ¯æ•°é‡ (0=å…¨éƒ¨)</label>
                    <input type="number" class="form-input" id="contextLimit" value="0" min="0">
                    <div class="api-hint">é™åˆ¶æ¯æ¬¡APIè°ƒç”¨æ—¶å‘é€çš„å†å²æ¶ˆæ¯æ•°é‡ï¼Œå¯ä»¥å‡å°‘Tokenæ¶ˆè€—</div>
                </div>
                <div class="form-group">
                    <label class="form-label">
                        <input type="checkbox" id="enableCompression" style="margin-right: 8px;">
                        å¯ç”¨AIæ™ºèƒ½ä¸Šä¸‹æ–‡å‹ç¼©
                    </label>
                    <div class="api-hint">ä½¿ç”¨ç³»ç»ŸAIè‡ªåŠ¨å‹ç¼©å†å²å¯¹è¯ä»¥å‡å°‘Tokenæ¶ˆè€—ï¼Œä¿ç•™å…³é”®ä¿¡æ¯</div>
                </div>
                <div class="form-group">
                    <label class="form-label">å‹ç¼©å¼ºåº¦</label>
                    <select class="form-select" id="compressionRatio">
                        <option value="0.3">è½»åº¦å‹ç¼© (ä¿ç•™70%å†…å®¹)</option>
                        <option value="0.5" selected>ä¸­åº¦å‹ç¼© (ä¿ç•™50%å†…å®¹)</option>
                        <option value="0.7">é‡åº¦å‹ç¼© (ä¿ç•™30%å†…å®¹)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">ä¸å‹ç¼©æ¡æ•°</label>
                    <input type="number" class="form-input" id="keepRecentCount" value="5" min="0" max="20">
                    <div class="api-hint">æœ€è¿‘çš„Xæ¡æ¶ˆæ¯ä¸å‚ä¸å‹ç¼©ï¼Œä¿æŒå®Œæ•´ä¸Šä¸‹æ–‡</div>
                </div>
                <div class="form-group">
                    <label class="form-label">é‡è¯•æ¬¡æ•°</label>
                    <input type="number" class="form-input" id="retryCount" value="3" min="0">
                </div>
                <div class="form-group">
                    <label class="form-label">é‡è¯•é—´éš” (ç§’)</label>
                    <input type="number" class="form-input" id="retryDelay" value="2" min="1">
                </div>
            </div>

                <!-- å‹ç¼©ç»Ÿè®¡ -->
                <div class="config-section" id="compressionStatsSection" style="display:none;">
                    <div class="config-title">å‹ç¼©ç»Ÿè®¡</div>
                    <div id="compressionStats" style="font-size: 12px; color: #666; line-height: 1.5;">
                        æš‚æ— å‹ç¼©æ•°æ®
                    </div>
                </div>
            </div>

            <!-- ä»£ç†é…ç½®Tabå†…å®¹ -->
            <div class="tab-content" id="proxy-config" style="display: none;">
                <!-- ä»£ç†ç®¡ç†æ“ä½œ -->
                <div class="config-section">
                    <div class="config-title">ä»£ç†ç®¡ç†</div>
                    <button class="btn btn-primary" id="addProxy">æ–°å¢ä»£ç†</button>
                    <button class="btn btn-primary" id="saveProxyConfig">ä¿å­˜ä»£ç†é…ç½®</button>
                </div>

                <!-- ä»£ç†åˆ—è¡¨å®¹å™¨ -->
                <div id="proxyListContainer">
                    <!-- ä»£ç†é…ç½®é¡¹å°†åŠ¨æ€æ’å…¥è¿™é‡Œ -->
                </div>
            </div>
        </div>

        <!-- å³ä¾§å¯¹è¯æ  -->
        <div class="chat-panel">
            <div class="chat-header">
                <div class="chat-title">AIåŒäººå¯¹è¯</div>
                <div style="display: flex; align-items: center; gap: 15px;">
                    <div class="round-counter">è½®æ¬¡: <span id="roundCounter">0</span></div>
                    <div class="status-indicator status-ready" id="statusIndicator">å°±ç»ª</div>
                </div>
            </div>

            <div class="chat-messages" id="chatMessages">
                <div style="text-align: center; color: #666; margin-top: 50px;">
                    <h3>æ¬¢è¿ä½¿ç”¨AIåŒäººå¯¹è¯ç³»ç»Ÿ</h3>
                    <p>è¯·å…ˆé…ç½®AIå‚æ•°ï¼Œç„¶åè¾“å…¥å¼€åœºç™½å¼€å§‹å¯¹è¯</p>
                </div>
            </div>

            <div class="chat-input">
                <div class="input-group">
                    <input type="text" class="input-field" id="openingMessage" placeholder="è¾“å…¥å¼€åœºç™½ï¼Œç”±AI Aå‘èµ·å¯¹è¯...">
                    <button class="btn btn-primary" id="sendOpening">å‘èµ·å¯¹è¯</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        /**
         * æ¶ˆæ¯å¯¹è±¡æ¨¡å‹
         */
        class Message {
            constructor({ id, speaker, role, content, status = 'completed', timestamp = Date.now() }) {
                this.id = id || `msg_${timestamp}_${Math.random().toString(36).substr(2, 9)}`;
                this.speaker = speaker;
                this.role = role;
                this.content = content;
                this.status = status; // 'loading', 'streaming', 'completed', 'error'
                this.timestamp = timestamp;
                this.isCompressed = false;
                this.compressedContent = null;
                this.compressionIndex = null;
            }

            // æ ‡è®°ä¸ºå‹ç¼©æ¶ˆæ¯
            markAsCompressed(compressedContent, compressionIndex) {
                this.isCompressed = true;
                this.compressedContent = compressedContent;
                this.compressionIndex = compressionIndex;
            }

            // æ›´æ–°æ¶ˆæ¯å†…å®¹
            updateContent(content) {
                this.content = content;
            }

            // æ›´æ–°æ¶ˆæ¯çŠ¶æ€
            updateStatus(status) {
                this.status = status;
            }

            // è·å–ç”¨äºAPIçš„å†…å®¹ï¼ˆå‹ç¼©åçš„å†…å®¹æˆ–åŸå§‹å†…å®¹ï¼‰
            getAPIContent() {
                return this.isCompressed ? this.compressedContent : this.content;
            }

            // è½¬æ¢ä¸ºæ—§æ ¼å¼ï¼ˆç”¨äºå‘åå…¼å®¹ï¼‰
            toLegacyFormat() {
                return {
                    role: this.role,
                    content: this.content,
                    speaker: this.speaker,
                    isCompressed: this.isCompressed,
                    compressedContent: this.compressedContent,
                    compressionIndex: this.compressionIndex
                };
            }

            // ä»æ—§æ ¼å¼åˆ›å»ºæ¶ˆæ¯å¯¹è±¡
            static fromLegacyFormat(legacy) {
                const msg = new Message({
                    speaker: legacy.speaker,
                    role: legacy.role,
                    content: legacy.content,
                    status: 'completed'
                });
                if (legacy.isCompressed) {
                    msg.markAsCompressed(legacy.compressedContent, legacy.compressionIndex);
                }
                return msg;
            }
        }

        class AIDialogueSystem {
            constructor() {
                this.conversations = [];
                this.currentRound = 0;
                this.maxRounds = 0;
                this.contextLimit = 0; // æ–°å¢ï¼šä¸Šä¸‹æ–‡é™åˆ¶
                this.isRunning = false;
                this.isPaused = false;
                this.isPausedManually = false; // æ–°å¢ï¼šæ ‡è®°æ˜¯å¦æ‰‹åŠ¨æš‚åœ
                this.retryCount = 3;
                this.retryDelay = 2000;
                this.currentRetries = 0;
                this.needsReset = false;
                this.openingMessage = '';
                this.nextSpeaker = 'B';
                // æ–°å¢ï¼šç”¨äºè·Ÿè¸ªå½“å‰æ­£åœ¨æµå¼æ˜¾ç¤ºçš„æ¶ˆæ¯
                this.currentStreamingMessageId = null;
                // æ–°å¢ï¼šç”¨äºè·Ÿè¸ªå½“å‰æ˜¯å¦æœ‰AIæ­£åœ¨å·¥ä½œï¼ˆé˜²æ­¢å¹¶å‘ï¼‰
                this.isAIWorking = false;

                // ä»£ç†é…ç½®ç›¸å…³
                this.proxies = new Map(); // å­˜å‚¨æ‰€æœ‰ä»£ç†é…ç½®
                this.currentTab = 'ai-config'; // å½“å‰æ¿€æ´»çš„Tab
                
                // æ–°å¢ï¼šè·Ÿè¸ªæ¯ä¸ªAIå½“å‰çš„ç«¯ç‚¹ç±»å‹
                this.currentEndpointTypes = {
                    'A': 'openai',
                    'B': 'openai', 
                    'System': 'openai'
                };
                
                // æ–°å¢ï¼šè·Ÿè¸ªå…¨å±€é…ç½®å½“å‰çš„ç«¯ç‚¹ç±»å‹
                this.currentGlobalEndpointType = 'openai';
                
                // ====== ä¸Šä¸‹æ–‡å‹ç¼©åŠŸèƒ½ç›¸å…³å±æ€§ ======
                this.enableCompression = false; // æ˜¯å¦å¯ç”¨å‹ç¼©
                this.compressionRatio = 0.5; // å‹ç¼©æ¯”ç‡ (0.1-0.9)
                this.keepRecentCount = 5; // æœ€è¿‘Xæ¡æ¶ˆæ¯ä¸å‹ç¼©
                this.compressedMessages = []; // å­˜å‚¨å‹ç¼©åçš„æ¶ˆæ¯æ‘˜è¦
                this.compressionCache = new Map(); // å‹ç¼©ç¼“å­˜ï¼Œkeyä¸ºæ¶ˆæ¯å†…å®¹hashï¼Œvalueä¸ºå‹ç¼©ç»“æœ
                this.lastCompressionIndex = 0; // ä¸Šæ¬¡å‹ç¼©åˆ°çš„æ¶ˆæ¯ç´¢å¼•
                this.compressionStats = { // å‹ç¼©ç»Ÿè®¡ä¿¡æ¯
                    originalTokens: 0,
                    compressedTokens: 0,
                    compressionCount: 0,
                    aiCompressionTokens: 0 // AIå‹ç¼©æ¶ˆè€—çš„Token
                };

                this.initializeElements();
                this.loadProxyConfiguration(); // å…ˆåŠ è½½ä»£ç†é…ç½®
                this.updateProxySelectors(); // æ›´æ–°ä»£ç†ä¸‹æ‹‰é€‰æ‹©å™¨
                this.loadConfiguration();
                this.setupEventListeners();
                this.updateUI();
                
                // è®¾ç½®å…¨å±€å¼•ç”¨ä»¥ä¾¿åœ¨onclickä¸­è®¿é—®
                window.aiDialogue = this;
            }

            initializeElements() {
                // é…ç½®å…ƒç´ 
                this.elements = {
                    // AIé…ç½®ï¼ˆä½¿ç”¨ä»£ç†é€‰æ‹©ï¼‰
                    proxySelectA: document.getElementById('proxySelectA'),
                    promptA: document.getElementById('promptA'),

                    proxySelectB: document.getElementById('proxySelectB'),
                    promptB: document.getElementById('promptB'),

                    proxySelectSystem: document.getElementById('proxySelectSystem'),
                    promptSystem: document.getElementById('promptSystem'),

                    maxRounds: document.getElementById('maxRounds'),
                    contextLimit: document.getElementById('contextLimit'), // æ–°å¢
                    enableCompression: document.getElementById('enableCompression'),
                    compressionRatio: document.getElementById('compressionRatio'),
                    keepRecentCount: document.getElementById('keepRecentCount'),
                    retryCount: document.getElementById('retryCount'),
                    retryDelay: document.getElementById('retryDelay'),

                    chatMessages: document.getElementById('chatMessages'),
                    openingMessage: document.getElementById('openingMessage'),
                    statusIndicator: document.getElementById('statusIndicator'),
                    roundCounter: document.getElementById('roundCounter'),

                    saveConfig: document.getElementById('saveConfig'),
                    pauseResumeChat: document.getElementById('pauseResumeChat'),
                    exportChat: document.getElementById('exportChat'),
                    clearChat: document.getElementById('clearChat'),
                    retryChat: document.getElementById('retryChat'),
                    sendOpening: document.getElementById('sendOpening'),

                    // Tabå’Œä»£ç†ç›¸å…³å…ƒç´ 
                    addProxy: document.getElementById('addProxy'),
                    saveProxyConfig: document.getElementById('saveProxyConfig'),
                    proxyListContainer: document.getElementById('proxyListContainer'),

                    // é…ç½®å¯¼å…¥å¯¼å‡º
                    exportConfig: document.getElementById('exportConfig'),
                    importConfig: document.getElementById('importConfig'),
                    importConfigFile: document.getElementById('importConfigFile')
                };
            }

            setupEventListeners() {
                // ä»£ç†é€‰æ‹©å™¨å˜åŒ–äº‹ä»¶
                this.elements.proxySelectA.addEventListener('change', () => this.updateProxySelectors());
                this.elements.proxySelectB.addEventListener('change', () => this.updateProxySelectors());
                this.elements.proxySelectSystem.addEventListener('change', () => this.updateProxySelectors());

                // å‹ç¼©åŠŸèƒ½ç›¸å…³äº‹ä»¶
                this.elements.enableCompression.addEventListener('change', () => this.updateCompressionStatsUI());

                // æŒ‰é’®äº‹ä»¶
                this.elements.saveConfig.addEventListener('click', () => this.saveConfiguration());
                this.elements.pauseResumeChat.addEventListener('click', () => this.togglePauseResume());
                this.elements.exportChat.addEventListener('click', () => this.exportDialogue());
                this.elements.clearChat.addEventListener('click', () => this.clearDialogue());
                this.elements.retryChat.addEventListener('click', () => this.retryLastRequest());
                this.elements.sendOpening.addEventListener('click', () => this.sendOpeningMessage());

                // Tabåˆ‡æ¢äº‹ä»¶
                document.querySelectorAll('.tab-button').forEach(button => {
                    button.addEventListener('click', (e) => this.switchTab(e.target.dataset.tab));
                });

                // ä»£ç†ç®¡ç†äº‹ä»¶
                this.elements.addProxy.addEventListener('click', () => this.addNewProxy());
                this.elements.saveProxyConfig.addEventListener('click', () => this.saveProxyConfiguration());

                // é…ç½®å¯¼å…¥å¯¼å‡ºäº‹ä»¶
                this.elements.exportConfig.addEventListener('click', () => this.exportConfiguration());
                this.elements.importConfig.addEventListener('click', () => this.elements.importConfigFile.click());
                this.elements.importConfigFile.addEventListener('change', (e) => this.importConfiguration(e));

                // å›è½¦å‘é€
                this.elements.openingMessage.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendOpeningMessage();
                });
            }

            /**
             * æ›´æ–°ä»£ç†é€‰æ‹©å™¨
             */
            updateProxySelectors() {
                const selectors = [
                    this.elements.proxySelectA,
                    this.elements.proxySelectB,
                    this.elements.proxySelectSystem
                ];

                selectors.forEach(selector => {
                    if (!selector) return;

                    const currentValue = selector.value;

                    // æ¸…ç©ºç°æœ‰é€‰é¡¹ï¼Œä¿ç•™é»˜è®¤é€‰é¡¹
                    selector.innerHTML = '<option value="">è¯·é€‰æ‹©ä»£ç†é…ç½®</option>';

                    // æ·»åŠ ä»£ç†é€‰é¡¹
                    for (const [id, proxy] of this.proxies) {
                        const option = document.createElement('option');
                        option.value = id;
                        option.textContent = `${proxy.name} (${proxy.modelName})`;
                        selector.appendChild(option);
                    }

                    // æ¢å¤ä¹‹å‰é€‰æ‹©çš„å€¼
                    if (currentValue) {
                        selector.value = currentValue;
                    }
                });
            }



            loadConfiguration() {
                const saved = localStorage.getItem('aiDialogueConfig');
                if (saved) {
                    const config = JSON.parse(saved);
                    Object.keys(config).forEach(key => {
                        if (this.elements[key]) {
                            if (this.elements[key].type === 'checkbox') {
                                this.elements[key].checked = config[key];
                            } else {
                                this.elements[key].value = config[key];
                            }
                        }
                    });

                    // æ¢å¤AIé€‰æ‹©çš„ä»£ç†
                    if (config.selectedProxyA && this.proxies.has(config.selectedProxyA)) {
                        this.elements.proxySelectA.value = config.selectedProxyA;
                    }
                    if (config.selectedProxyB && this.proxies.has(config.selectedProxyB)) {
                        this.elements.proxySelectB.value = config.selectedProxyB;
                    }
                    if (config.selectedProxySystem && this.proxies.has(config.selectedProxySystem)) {
                        this.elements.proxySelectSystem.value = config.selectedProxySystem;
                    }

                    // ç¡®ä¿ç³»ç»ŸAIæç¤ºè¯æœ‰é»˜è®¤å€¼ï¼ˆå¦‚æœä¸ºç©ºçš„è¯ï¼‰
                    if (!this.elements.promptSystem.value.trim()) {
                        this.elements.promptSystem.value = this.getDefaultCompressionPromptTemplate();
                    }
                } else {
                    // è®¾ç½®é»˜è®¤çš„ç³»ç»ŸAIæç¤ºè¯
                    this.elements.promptSystem.value = this.getDefaultCompressionPromptTemplate();
                }

                // æ›´æ–°å‹ç¼©ç»Ÿè®¡UI
                this.updateCompressionStatsUI();
            }

            saveConfiguration() {
                // ä¿å­˜AIé…ç½®
                const config = {};
                Object.keys(this.elements).forEach(key => {
                    if (this.elements[key]) {
                        if (this.elements[key].type === 'checkbox') {
                            config[key] = this.elements[key].checked;
                        } else if (this.elements[key].value !== undefined) {
                            config[key] = this.elements[key].value;
                        }
                    }
                });

                // é¢å¤–ä¿å­˜AIé€‰æ‹©çš„ä»£ç†ID
                config.selectedProxyA = this.elements.proxySelectA.value;
                config.selectedProxyB = this.elements.proxySelectB.value;
                config.selectedProxySystem = this.elements.proxySelectSystem.value;

                localStorage.setItem('aiDialogueConfig', JSON.stringify(config));
                this.showMessage('AIé…ç½®å·²ä¿å­˜', 'success');
            }

            /**
             * æ·»åŠ æˆ–æ›´æ–°æ¶ˆæ¯åˆ°UIï¼Œæ”¯æŒæµå¼æ›´æ–°å’Œå‹ç¼©æ¶ˆæ¯æ˜¾ç¤º
             * @param {string} speaker - å‘è¨€è€…
             * @param {string} content - æ¶ˆæ¯å†…å®¹
             * @param {boolean} isStreaming - æ˜¯å¦ä¸ºæµå¼æ›´æ–°
             * @param {string|null} messageId - æ¶ˆæ¯IDï¼Œç”¨äºæ›´æ–°ç°æœ‰æ¶ˆæ¯
             * @param {Object|null} messageData - å®Œæ•´çš„æ¶ˆæ¯æ•°æ®ï¼ˆåŒ…å«å‹ç¼©ä¿¡æ¯ï¼‰
             */
            addMessageToUI(speaker, content, isStreaming = false, messageId = null, messageData = null) {
                const messagesContainer = this.elements.chatMessages;

                if (messageId) {
                    // æ›´æ–°ç°æœ‰æ¶ˆæ¯
                    const existingMessage = document.getElementById(messageId);
                    if (existingMessage) {
                        const contentElement = existingMessage.querySelector('.message-content');
                        if (contentElement) {
                            // å¯¹äºæµå¼æ›´æ–°ï¼Œç›´æ¥è®¾ç½®æ–‡æœ¬ï¼Œé¿å…é‡å¤è§£æMarkdown
                            if (isStreaming) {
                                contentElement.textContent = content;
                            } else {
                                // æœ€ç»ˆå®Œæˆæ—¶è§£æMarkdown
                                contentElement.innerHTML = marked.parse(content);
                            }
                        }
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        return messageId;
                    }
                }

                // åˆ›å»ºæ–°æ¶ˆæ¯
                const newMessageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                const messageDiv = document.createElement('div');

                const isAIB = speaker === 'AI B';
                messageDiv.className = `message ${isAIB ? 'message-b' : 'message-a'}`;
                messageDiv.id = newMessageId;

                // å¦‚æœæ˜¯loadingçŠ¶æ€ï¼Œä½¿ç”¨ç‰¹æ®Šæ ·å¼
                if (content === '[æ€è€ƒä¸­...]' || content.includes('æ­£åœ¨')) {
                    messageDiv.classList.add('message-loading');
                }

                // æ£€æŸ¥æ˜¯å¦åº”è¯¥è·³è¿‡æ˜¾ç¤ºï¼ˆå¦‚æœè¿™æ¡æ¶ˆæ¯å·²ç»è¢«å‹ç¼©åˆ°æ‘˜è¦ä¸­ï¼‰
                if (this.shouldSkipMessage(speaker, content)) {
                    // ä¸æ˜¾ç¤ºè¿™æ¡æ¶ˆæ¯ï¼Œå› ä¸ºå®ƒå·²ç»è¢«åŒ…å«åœ¨å‹ç¼©æ‘˜è¦ä¸­
                    return null;
                }

                // æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦è¢«å‹ç¼©ï¼ˆä»conversationsæ•°ç»„ä¸­æŸ¥æ‰¾ï¼‰
                const isCompressedMessage = messageData && messageData.isCompressed && messageData.compressedContent;
                
                // æ„å»ºæ¶ˆæ¯å¤´éƒ¨ï¼ˆåŒ…å«å‹ç¼©æŒ‡ç¤ºå™¨ï¼‰
                let headerHTML = `<div class="message-header">${speaker}`;
                if (isCompressedMessage) {
                    // ä¸ºå‹ç¼©æ¶ˆæ¯æ·»åŠ å‹ç¼©å›¾æ ‡ï¼ˆä½†æ¶ˆæ¯å†…å®¹ä»æ˜¾ç¤ºå®Œæ•´ç‰ˆæœ¬ï¼‰
                    const originalLength = this.estimateTokens(messageData.content);
                    const compressedLength = this.estimateTokens(messageData.compressedContent);
                    const ratio = originalLength > 0 ? 
                        Math.round(((originalLength - compressedLength) / originalLength) * 100) : 0;
                    
                    headerHTML += `<span class="compression-indicator" onclick="window.aiDialogue.showCompressedContent('${newMessageId}')" title="ç‚¹å‡»æŸ¥çœ‹å‹ç¼©åçš„å†…å®¹">
                        <span class="compression-icon">ğŸ—œï¸</span>
                        <span>å·²å‹ç¼© ${ratio}%</span>
                    </span>`;
                }
                headerHTML += `</div>`;

                // æ„å»ºæ¶ˆæ¯å†…å®¹
                const contentHTML = `<div class="message-content">${isStreaming ? content : marked.parse(content)}</div>`;
                
                // æ„å»ºæ¶ˆæ¯æ“ä½œæŒ‰é’®ï¼ˆä»…å¯¹AIæ¶ˆæ¯æ˜¾ç¤ºï¼‰
                let actionsHTML = '';
                if (speaker.startsWith('AI')) {
                    actionsHTML = `
                        <div class="message-actions" style="display: none;">
                            <button class="message-action-btn btn-retry" onclick="window.aiDialogue.retryMessage('${newMessageId}')" title="é‡è¯•æ­¤æ¶ˆæ¯">
                                ğŸ”„ é‡è¯•
                            </button>
                            <button class="message-action-btn btn-copy" onclick="window.aiDialogue.copyMessage('${newMessageId}')" title="å¤åˆ¶æ¶ˆæ¯å†…å®¹">
                                ğŸ“‹ å¤åˆ¶
                            </button>
                        </div>
                    `;
                }
                
                messageDiv.innerHTML = headerHTML + contentHTML + actionsHTML;

                // å¦‚æœæ˜¯å‹ç¼©æ¶ˆæ¯ï¼Œå­˜å‚¨å‹ç¼©ç›¸å…³æ•°æ®
                if (isCompressedMessage && messageData.compressedContent) {
                    const originalLength = this.estimateTokens(messageData.content);
                    const compressedLength = this.estimateTokens(messageData.compressedContent);
                    
                    messageDiv.setAttribute('data-compressed-content', messageData.compressedContent);
                    messageDiv.setAttribute('data-compression-stats', JSON.stringify({
                        originalLength: originalLength,
                        compressedLength: compressedLength,
                        savedLength: originalLength - compressedLength,
                        ratio: `${Math.round(((originalLength - compressedLength) / originalLength) * 100)}%`,
                        compressionIndex: messageData.compressionIndex
                    }));
                }

                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;

                return newMessageId;
            }

            /**
             * æ·»åŠ loadingå ä½æ¶ˆæ¯
             * @param {string} speaker - å‘è¨€è€…
             * @return {string} æ¶ˆæ¯ID
             */
            addLoadingMessage(speaker) {
                const loadingContent = `
                    <div class="typing-indicator">
                        æ­£åœ¨æ€è€ƒä¸­
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                `;

                const messageId = this.addMessageToUI(speaker, '', true);

                // ç›´æ¥è®¾ç½®loadingå†…å®¹åˆ°contentåŒºåŸŸ
                const messageElement = document.getElementById(messageId);
                if (messageElement) {
                    const contentElement = messageElement.querySelector('.message-content');
                    if (contentElement) {
                        contentElement.innerHTML = loadingContent;
                    }
                }

                return messageId;
            }

            togglePauseResume() {
                if (this.isPaused) {
                    // å½“å‰æ˜¯æš‚åœçŠ¶æ€ï¼Œç‚¹å‡»ç»§ç»­
                    this.resumeDialogue();
                } else if (this.isRunning) {
                    // å½“å‰æ˜¯è¿è¡ŒçŠ¶æ€ï¼Œç‚¹å‡»æš‚åœ
                    this.pauseDialogue();
                }
            }

            pauseDialogue() {
                this.isPaused = true;
                this.isPausedManually = true; // æ ‡è®°ä¸ºæ‰‹åŠ¨æš‚åœ
                this.updateUI();
                this.addSystemMessage('â¸ï¸ å¯¹è¯å·²æ‰‹åŠ¨æš‚åœ', 'info');
            }

            resumeDialogue() {
                // æ£€æŸ¥æ˜¯å¦æœ‰AIæ­£åœ¨å·¥ä½œ
                if (this.isAIWorking) {
                    this.showMessage('è¯·ç­‰å¾…å½“å‰AIå®Œæˆå·¥ä½œåå†ç»§ç»­', 'error');
                    return;
                }
                
                const wasManuallyPaused = this.isPausedManually;
                
                this.isPaused = false;
                this.isPausedManually = false; // æ¸…é™¤æ‰‹åŠ¨æš‚åœæ ‡è®°
                
                // å¦‚æœè¾¾åˆ°æœ€å¤§ä¼šè¯æ•°ï¼Œå¼€å¯æ–°ä¸€è½®
                if (this.needsReset) {
                    this.currentRound = 0;
                    this.needsReset = false;
                    this.addSystemMessage('ğŸ”„ å¼€å¯æ–°ä¸€è½®å¯¹è¯', 'success');
                } else {
                    this.addSystemMessage('â–¶ï¸ ç»§ç»­å¯¹è¯', 'success');
                }

                // é‡æ–°è¯»å–æœ€æ–°çš„é…ç½®
                this.maxRounds = parseInt(this.elements.maxRounds.value) || 0;
                this.contextLimit = parseInt(this.elements.contextLimit.value) || 0;
                this.enableCompression = this.elements.enableCompression.checked;
                this.compressionRatio = parseFloat(this.elements.compressionRatio.value) || 0.5;
                this.keepRecentCount = parseInt(this.elements.keepRecentCount.value) || 5;
                this.retryCount = parseInt(this.elements.retryCount.value);
                if (isNaN(this.retryCount) || this.retryCount < 0) this.retryCount = 0;
                this.retryDelay = parseInt(this.elements.retryDelay.value) * 1000 || 2000;

                // æ— è®ºæ˜¯è‡ªåŠ¨æš‚åœè¿˜æ˜¯æ‰‹åŠ¨æš‚åœï¼Œéƒ½ä¸ä¿®æ”¹nextSpeaker
                // å› ä¸ºnextSpeakerå§‹ç»ˆæŒ‡å‘ä¸‹ä¸€ä¸ªåº”è¯¥å‘è¨€çš„AI
                // å¦‚æœæ˜¯è‡ªåŠ¨æš‚åœ(å¤±è´¥å¯¼è‡´)ï¼ŒnextSpeakeræŒ‡å‘å¤±è´¥çš„AIï¼Œåº”è¯¥è®©å®ƒé‡è¯•
                // å¦‚æœæ˜¯æ‰‹åŠ¨æš‚åœï¼ŒnextSpeakeræŒ‡å‘ä¸‹ä¸€ä¸ªåº”è¯¥å‘è¨€çš„AIï¼Œä¿æŒä¸å˜
                
                this.updateUI();
                this.runDialogue();
            }

            updateNextSpeaker() {
                if (this.conversations.length === 0) {
                    this.nextSpeaker = 'B';
                    return;
                }

                const lastSpeaker = this.conversations[this.conversations.length - 1].speaker;

                if (lastSpeaker === 'AI A') {
                    this.nextSpeaker = 'B';
                } else {
                    this.nextSpeaker = 'A';
                }
            }

            async sendOpeningMessage() {
                const message = this.elements.openingMessage.value.trim();
                if (!message) {
                    this.showMessage('è¯·è¾“å…¥å¼€åœºç™½', 'error');
                    return;
                }

                if (!this.validateConfiguration()) return;

                // æ¸…ç©ºä¹‹å‰çš„å¯¹è¯
                this.conversations = [];
                this.currentRound = 0;
                this.openingMessage = message;
                this.nextSpeaker = 'B';
                this.currentStreamingMessageId = null;

                this.elements.chatMessages.innerHTML = '';
                this.elements.openingMessage.value = '';

                // AI A æœ¬åœ°å‘å‡ºå¼€åœºç™½ï¼ˆä¸è°ƒç”¨APIï¼‰
                const openingMsg = new Message({
                    speaker: 'AI A',
                    role: 'assistant',
                    content: message,
                    status: 'completed'
                });
                this.addMessageToUI('AI A', message);
                this.conversations.push(openingMsg);

                // è®¾ç½®å¯¹è¯å‚æ•°
                this.maxRounds = parseInt(this.elements.maxRounds.value) || 0;
                this.contextLimit = parseInt(this.elements.contextLimit.value) || 0; // æ–°å¢
                this.enableCompression = this.elements.enableCompression.checked;
                this.compressionRatio = parseFloat(this.elements.compressionRatio.value) || 0.5;
                this.keepRecentCount = parseInt(this.elements.keepRecentCount.value) || 5;
                this.retryCount = parseInt(this.elements.retryCount.value);
                if (isNaN(this.retryCount) || this.retryCount < 0) this.retryCount = 0;
                this.retryDelay = parseInt(this.elements.retryDelay.value) * 1000 || 2000;

                // ç›´æ¥å¼€å§‹å¯¹è¯ï¼ŒAI B å“åº”
                this.isRunning = true;
                this.isPaused = false;
                this.isPausedManually = false;
                this.needsReset = false;
                this.updateUI();

                await this.runDialogue();
            }

            async runDialogue() {
                while (this.isRunning && !this.isPaused) {
                    if (this.maxRounds > 0 && this.currentRound >= this.maxRounds) {
                        this.isPaused = true;
                        this.needsReset = true;
                        this.updateUI();
                        break;
                    }

                    const currentAI = this.nextSpeaker;
                    const success = await this.callAI(currentAI);

                    if (!success) {
                        this.isPaused = true;
                        this.updateUI();
                        break;
                    }

                    this.currentRound++;
                    this.updateRoundCounter();

                    // åˆ‡æ¢ä¸‹ä¸€ä¸ªå‘è¨€è€…
                    this.nextSpeaker = this.nextSpeaker === 'A' ? 'B' : 'A';

                    // æ·»åŠ å»¶è¿Ÿé¿å…è¿‡å¿«è¯·æ±‚
                    await this.sleep(1000);
                }
                
                // å¯¹è¯ç»“æŸåï¼Œæ›´æ–°æ‰€æœ‰æ¶ˆæ¯çš„å‹ç¼©å›¾æ ‡æ˜¾ç¤º
                this.updateAllCompressionIcons();
            }

            /**
             * æ›´æ–°æ‰€æœ‰æ¶ˆæ¯çš„å‹ç¼©å›¾æ ‡æ˜¾ç¤º
             */
            updateAllCompressionIcons() {
                console.log('ğŸ”„ å¼€å§‹æ›´æ–°æ‰€æœ‰å‹ç¼©å›¾æ ‡...');
                let compressedCount = 0;
                
                this.conversations.forEach((conv, index) => {
                    if (conv.isCompressed && conv.compressedContent) {
                        compressedCount++;
                        console.log(`ğŸ“ å‘ç°å‹ç¼©æ¶ˆæ¯ ${index}: ${conv.speaker}`);
                        setTimeout(() => {
                            this.updateMessageCompressionIcon(index);
                        }, index * 50); // é”™å¼€æ‰§è¡Œæ—¶é—´
                    }
                });
                
                console.log(`ğŸ“Š æ€»å…±æ‰¾åˆ° ${compressedCount} æ¡å‹ç¼©æ¶ˆæ¯`);
            }
            // ====== ä¿®å¤åçš„APIè°ƒç”¨æ–¹æ³• ======

            async callAI(aiType) {
                // è®¾ç½®AIå·¥ä½œæ ‡å¿—
                this.isAIWorking = true;
                this.updateUI();
                
                const config = this.getAIConfig(aiType);
                const messages = await this.buildMessages(aiType);

                this.currentRetries = 0;

                // æ·»åŠ loadingæ¶ˆæ¯
                const loadingMessageId = this.addLoadingMessage(`AI ${aiType}`);
                this.currentStreamingMessageId = loadingMessageId;

                while (this.currentRetries <= this.retryCount) {
                    try {
                        this.setStatus('è¿è¡Œä¸­', 'running');
                        const response = await this.makeAPIRequest(config, messages, `AI ${aiType}`, loadingMessageId);

                        if (response && response.content) {
                            // æµå¼å“åº”åœ¨makeAPIRequestä¸­å·²ç»å®æ—¶æ›´æ–°äº†UI
                            // åˆ›å»ºæ–°çš„æ¶ˆæ¯å¯¹è±¡å¹¶æ·»åŠ åˆ°å¯¹è¯å†å²ä¸­
                            const newMessage = new Message({
                                speaker: `AI ${aiType}`,
                                role: 'assistant',
                                content: response.content,
                                status: 'completed'
                            });
                            this.conversations.push(newMessage);

                            // åœ¨æ–°æ¶ˆæ¯æ·»åŠ åï¼Œæ£€æŸ¥å¹¶æ›´æ–°å‹ç¼©å›¾æ ‡
                            setTimeout(() => {
                                console.log('ğŸ†• æ–°æ¶ˆæ¯æ·»åŠ å®Œæˆï¼Œæ›´æ–°å‹ç¼©å›¾æ ‡');
                                this.updateAllCompressionIcons();
                            }, 500);

                            this.setStatus('å°±ç»ª', 'ready');
                            this.currentStreamingMessageId = null;
                            // æ¸…é™¤AIå·¥ä½œæ ‡å¿—
                            this.isAIWorking = false;
                            this.updateUI();
                            return true;
                        }

                        throw new Error('å“åº”å†…å®¹ä¸ºç©º');

                    } catch (error) {
                        console.error(`AI ${aiType} è°ƒç”¨å¤±è´¥:`, error);
                        this.currentRetries++;

                        if (this.currentRetries <= this.retryCount) {
                            // æ›´æ–°loadingæ¶ˆæ¯æ˜¾ç¤ºé‡è¯•ä¿¡æ¯
                            this.addMessageToUI(`AI ${aiType}`, `è°ƒç”¨å¤±è´¥ï¼Œ${this.retryDelay/1000}ç§’åé‡è¯• (${this.currentRetries}/${this.retryCount})`, true, loadingMessageId);
                            this.showMessage(`AI ${aiType} è°ƒç”¨å¤±è´¥ï¼Œ${this.retryDelay/1000}ç§’åé‡è¯• (${this.currentRetries}/${this.retryCount})`, 'error');
                            await this.sleep(this.retryDelay);
                        } else {
                            // é‡è¯•æ¬¡æ•°ç”¨å®Œï¼Œæ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯ï¼Œå¹¶è‡ªåŠ¨è¿›å…¥æš‚åœçŠ¶æ€
                            this.addMessageToUI(`AI ${aiType}`, `âŒ è°ƒç”¨å¤±è´¥ï¼Œå·²è¾¾é‡è¯•ä¸Šé™: ${error.message}`, false, loadingMessageId);
                            this.showMessage(`AI ${aiType} è°ƒç”¨å¤±è´¥ï¼Œå·²è¾¾é‡è¯•ä¸Šé™ï¼Œç³»ç»Ÿå·²è‡ªåŠ¨æš‚åœ`, 'error');
                            this.setStatus('æš‚åœ', 'stopped');
                            this.currentStreamingMessageId = null;
                            
                            // è‡ªåŠ¨è¿›å…¥æš‚åœçŠ¶æ€ï¼ˆéæ‰‹åŠ¨æš‚åœï¼‰
                            this.isPaused = true;
                            this.isPausedManually = false;
                            // æ¸…é™¤AIå·¥ä½œæ ‡å¿—
                            this.isAIWorking = false;
                            this.updateUI();
                            
                            return false;
                        }
                    }
                }

                // æ¸…é™¤AIå·¥ä½œæ ‡å¿—
                this.isAIWorking = false;
                this.updateUI();
                return false;
            }

            async makeAPIRequest(config, messages, speaker, messageId) {
                if (config.endpointType === 'openai') {
                    return await this.callOpenAI(config, messages, speaker, messageId);
                } else if (config.endpointType === 'gemini') {
                    return await this.callGemini(config, messages, speaker, messageId);
                }
            }

            async callOpenAI(config, messages, speaker, messageId) {
                // ä¿®å¤ï¼šå¦‚æœURLä»¥#ç»“å°¾ï¼Œå¼ºåˆ¶ä½¿ç”¨è¾“å…¥åœ°å€ï¼›å¦åˆ™è‡ªåŠ¨è¡¥å…¨
                let url;
                if (config.apiUrl.endsWith('#')) {
                    url = config.apiUrl.slice(0, -1); // å»æ‰æœ«å°¾çš„#
                } else if (config.apiUrl.endsWith('/v1/chat/completions')) {
                    url = config.apiUrl;
                } else {
                    url = `${config.apiUrl}/v1/chat/completions`;
                }

                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apiKey}`
                    },
                    body: JSON.stringify({
                        model: config.model,
                        messages: messages,
                        stream: true,
                        temperature: 0.7
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                return await this.handleOpenAIStreamResponse(response, speaker, messageId);
            }

            async callGemini(config, messages, speaker, messageId) {
                const url = `${config.apiUrl}/v1beta/models/${config.model}:streamGenerateContent?alt=sse&key=${config.apiKey}`;

                // è½¬æ¢æ¶ˆæ¯æ ¼å¼ä¸ºGeminiæ ¼å¼
                const contents = messages.filter(m => m.role !== 'system').map(m => ({
                    role: m.role === 'assistant' ? 'model' : 'user',
                    parts: [{ text: m.content }]
                }));

                const systemInstruction = messages.find(m => m.role === 'system');
                const requestBody = {
                    contents: contents,
                    generationConfig: {
                        temperature: 0.7
                    }
                };

                if (systemInstruction) {
                    requestBody.systemInstruction = {
                        parts: [{ text: systemInstruction.content }]
                    };
                }

                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorText}`);
                }

                return await this.handleGeminiStreamResponse(response, speaker, messageId);
            }

            // ä¿®å¤åçš„OpenAIæµå¼å“åº”å¤„ç†
            async handleOpenAIStreamResponse(response, speaker, messageId) {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let content = '';
                let isFirstChunk = true;

                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6).trim();
                                if (data === '[DONE]') continue;
                                if (!data) continue;

                                try {
                                    const parsed = JSON.parse(data);
                                    const delta = parsed.choices?.[0]?.delta?.content;
                                    if (delta) {
                                        content += delta;

                                        // å®æ—¶æ›´æ–°UI - ç¬¬ä¸€æ¬¡æ›´æ–°æ—¶æ¸…é™¤loadingçŠ¶æ€
                                        if (isFirstChunk) {
                                            // ç§»é™¤loadingæ ·å¼
                                            const messageElement = document.getElementById(messageId);
                                            if (messageElement) {
                                                messageElement.classList.remove('message-loading');
                                            }
                                            isFirstChunk = false;
                                        }

                                        // å®æ—¶æ›´æ–°æ¶ˆæ¯å†…å®¹
                                        this.addMessageToUI(speaker, content, true, messageId);
                                    }
                                } catch (e) {
                                    console.warn('è§£æOpenAIæµå¼å“åº”å¤±è´¥:', e, 'data:', data);
                                }
                            }
                        }
                    }
                } finally {
                    reader.releaseLock();
                }

                // æœ€ç»ˆå¤„ç†Markdown
                if (content) {
                    this.addMessageToUI(speaker, content, false, messageId);
                }

                return { content: content.trim() };
            }

            // ä¿®å¤åçš„Geminiæµå¼å“åº”å¤„ç† - è¿™æ˜¯å…³é”®ä¿®å¤
            async handleGeminiStreamResponse(response, speaker, messageId) {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let content = '';
                let buffer = '';
                let isFirstChunk = true;

                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value, { stream: true });
                        buffer += chunk;

                        // æŒ‰è¡Œåˆ†å‰²å¤„ç†
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || ''; // ä¿ç•™æœ€åä¸€ä¸ªå¯èƒ½ä¸å®Œæ•´çš„è¡Œ

                        for (const line of lines) {
                            if (line.trim() === '') continue;

                            // Geminiçš„æµå¼å“åº”æ ¼å¼é€šå¸¸æ˜¯ç›´æ¥çš„JSONï¼Œä¸éœ€è¦data:å‰ç¼€
                            try {
                                let jsonStr = line.trim();

                                // å¦‚æœè¡Œä»¥data:å¼€å¤´ï¼Œå»æ‰è¿™ä¸ªå‰ç¼€
                                if (jsonStr.startsWith('data: ')) {
                                    jsonStr = jsonStr.substring(6);
                                }

                                if (!jsonStr || jsonStr === '[DONE]') continue;

                                const parsed = JSON.parse(jsonStr);

                                // Gemini APIçš„æ ‡å‡†å“åº”ç»“æ„
                                const text = parsed.candidates?.[0]?.content?.parts?.[0]?.text;

                                if (text) {
                                    content += text;

                                    // å®æ—¶æ›´æ–°UI - ç¬¬ä¸€æ¬¡æ›´æ–°æ—¶æ¸…é™¤loadingçŠ¶æ€
                                    if (isFirstChunk) {
                                        const messageElement = document.getElementById(messageId);
                                        if (messageElement) {
                                            messageElement.classList.remove('message-loading');
                                        }
                                        isFirstChunk = false;
                                    }

                                    // å®æ—¶æ›´æ–°æ¶ˆæ¯å†…å®¹
                                    this.addMessageToUI(speaker, content, true, messageId);
                                }
                            } catch (e) {
                                // å¿½ç•¥JSONè§£æé”™è¯¯ï¼Œç»§ç»­å¤„ç†ä¸‹ä¸€è¡Œ
                                console.warn('è§£æGeminiæµå¼å“åº”å¤±è´¥:', e, 'line:', line);
                            }
                        }
                    }

                    // å¤„ç†bufferä¸­å‰©ä½™çš„å†…å®¹
                    if (buffer.trim()) {
                        try {
                            let jsonStr = buffer.trim();
                            if (jsonStr.startsWith('data: ')) {
                                jsonStr = jsonStr.substring(6);
                            }

                            if (jsonStr && jsonStr !== '[DONE]') {
                                const parsed = JSON.parse(jsonStr);
                                const text = parsed.candidates?.[0]?.content?.parts?.[0]?.text;
                                if (text) {
                                    content += text;
                                    this.addMessageToUI(speaker, content, true, messageId);
                                }
                            }
                        } catch (e) {
                            console.warn('è§£æGeminiæµå¼å“åº”å‰©ä½™å†…å®¹å¤±è´¥:', e);
                        }
                    }

                } finally {
                    reader.releaseLock();
                }

                // æœ€ç»ˆå¤„ç†Markdown
                if (content) {
                    this.addMessageToUI(speaker, content, false, messageId);
                } else {
                    // å¦‚æœæ²¡æœ‰æ”¶åˆ°ä»»ä½•å†…å®¹ï¼Œæ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                    this.addMessageToUI(speaker, 'âŒ æœªæ”¶åˆ°å“åº”å†…å®¹', false, messageId);
                    throw new Error('Gemini APIæœªè¿”å›ä»»ä½•å†…å®¹');
                }

                return { content: content.trim() };
            }
            // ====== è¾…åŠ©æ–¹æ³•å’Œäº‹ä»¶å¤„ç† ======

            getAIConfig(aiType) {
                // è·å–é€‰æ‹©çš„ä»£ç†ID
                const proxyId = this.elements[`proxySelect${aiType}`].value;

                if (!proxyId) {
                    throw new Error(`AI ${aiType} æœªé€‰æ‹©ä»£ç†é…ç½®`);
                }

                // ä»ä»£ç†é…ç½®ä¸­è·å–ä¿¡æ¯
                const proxy = this.proxies.get(proxyId);
                if (!proxy) {
                    throw new Error(`AI ${aiType} é€‰æ‹©çš„ä»£ç†é…ç½®ä¸å­˜åœ¨`);
                }

                return {
                    endpointType: proxy.endpoint,
                    apiUrl: proxy.apiUrl,
                    apiKey: proxy.apiKey,
                    model: proxy.modelName,
                    prompt: this.elements[`prompt${aiType}`].value
                };
            }

            /**
             * æ„å»ºAPIè¯·æ±‚çš„æ¶ˆæ¯æ•°ç»„ï¼Œæ”¯æŒä¸Šä¸‹æ–‡é™åˆ¶
             * @param {string} aiType - AIç±»å‹ ('A' æˆ– 'B')
             * @param {boolean} skipCompression - æ˜¯å¦è·³è¿‡å‹ç¼©ï¼ˆé‡è¯•æ—¶ä½¿ç”¨ï¼‰
             * @returns {Array} æ¶ˆæ¯æ•°ç»„
             */
            async buildMessages(aiType, skipCompression = false) {
                const config = this.getAIConfig(aiType);
                const messages = [];

                // æ·»åŠ ç³»ç»Ÿæç¤ºè¯
                if (config.prompt) {
                    messages.push({
                        role: 'system',
                        content: config.prompt
                    });
                }

                // è·å–éœ€è¦å‘é€çš„å¯¹è¯å†å²
                let conversationsToSend = this.conversations;

                // é¦–å…ˆåº”ç”¨æ™ºèƒ½å‹ç¼©ï¼ˆå¦‚æœå¯ç”¨ä¸”æœªè·³è¿‡ï¼‰
                if (!skipCompression && this.enableCompression && conversationsToSend.length > this.keepRecentCount) {
                    conversationsToSend = await this.compressConversations([...conversationsToSend]);
                }

                // ç„¶ååº”ç”¨ä¸Šä¸‹æ–‡é™åˆ¶
                if (this.contextLimit > 0 && conversationsToSend.length > this.contextLimit) {
                    // å–æœ€è¿‘çš„ contextLimit æ¡æ¶ˆæ¯
                    conversationsToSend = conversationsToSend.slice(-this.contextLimit);
                    
                    // åœ¨UIä¸­æ˜¾ç¤ºä¸Šä¸‹æ–‡æˆªæ–­ä¿¡æ¯ï¼ˆä»…åœ¨ç¬¬ä¸€æ¬¡æˆªæ–­æ—¶ï¼‰
                    if (this.conversations.length === this.contextLimit + 1) {
                        this.addSystemMessage(`ğŸ“‹ å¯ç”¨ä¸Šä¸‹æ–‡é™åˆ¶ï¼šä»…ä½¿ç”¨æœ€è¿‘ ${this.contextLimit} æ¡æ¶ˆæ¯`, 'info');
                    }
                }

                // æ„å»ºäº¤æ›¿çš„ç”¨æˆ·/åŠ©æ‰‹å¯¹è¯
                // ä»å½“å‰AIçš„è§’åº¦çœ‹ï¼Œå¯¹æ–¹éƒ½æ˜¯userï¼Œè‡ªå·±æ˜¯assistant
                for (let i = 0; i < conversationsToSend.length; i++) {
                    const conv = conversationsToSend[i];
                    const speakerType = conv.speaker === `AI ${aiType}` ? 'assistant' : 'user';

                    messages.push({
                        role: speakerType,
                        content: conv.content
                    });
                }

                // åœ¨æ§åˆ¶å°è¾“å‡ºdebugä¿¡æ¯
                console.log(`AI ${aiType} å‘é€æ¶ˆæ¯æ•°é‡: ${messages.length}`, {
                    ç³»ç»Ÿæ¶ˆæ¯: messages.filter(m => m.role === 'system').length,
                    å¯¹è¯æ¶ˆæ¯: messages.filter(m => m.role !== 'system').length,
                    æ€»å¯¹è¯æ¡æ•°: this.conversations.length,
                    å‘é€å¯¹è¯æ¡æ•°: conversationsToSend.length,
                    ä¸Šä¸‹æ–‡é™åˆ¶: this.contextLimit || 'æ— é™åˆ¶',
                    AIæ™ºèƒ½å‹ç¼©: this.enableCompression ? 'å·²å¯ç”¨' : 'æœªå¯ç”¨',
                    è·³è¿‡å‹ç¼©: skipCompression ? 'æ˜¯' : 'å¦',
                    ä¿æŠ¤æœ€è¿‘æ¶ˆæ¯: this.keepRecentCount,
                    å‹ç¼©ç»Ÿè®¡: this.compressionStats
                });

                return messages;
            }

            validateConfiguration() {
                // éªŒè¯AI Aé…ç½®
                if (!this.validateAIConfig('A')) {
                    return false;
                }
                
                // éªŒè¯AI Bé…ç½®
                if (!this.validateAIConfig('B')) {
                    return false;
                }

                // å¦‚æœå¯ç”¨AIå‹ç¼©ï¼ŒéªŒè¯ç³»ç»ŸAIé…ç½®
                if (this.enableCompression) {
                    if (!this.validateAIConfig('System')) {
                        return false;
                    }
                }

                return true;
            }

            /**
             * éªŒè¯å•ä¸ªAIçš„é…ç½®
             * @param {string} aiType - AIç±»å‹
             * @returns {boolean} é…ç½®æ˜¯å¦æœ‰æ•ˆ
             */
            validateAIConfig(aiType) {
                // æ£€æŸ¥æ˜¯å¦é€‰æ‹©äº†ä»£ç†
                const proxyId = this.elements[`proxySelect${aiType}`].value;
                if (!proxyId) {
                    this.showMessage(`AI ${aiType} æœªé€‰æ‹©ä»£ç†é…ç½®`, 'error');
                    return false;
                }

                // æ£€æŸ¥ä»£ç†æ˜¯å¦å­˜åœ¨
                const proxy = this.proxies.get(proxyId);
                if (!proxy) {
                    this.showMessage(`AI ${aiType} é€‰æ‹©çš„ä»£ç†é…ç½®ä¸å­˜åœ¨`, 'error');
                    return false;
                }

                // æ£€æŸ¥ä»£ç†é…ç½®æ˜¯å¦å®Œæ•´
                if (!proxy.apiUrl.trim()) {
                    this.showMessage(`ä»£ç†"${proxy.name}"çš„APIåœ°å€æœªå¡«å†™`, 'error');
                    return false;
                }
                if (!proxy.apiKey.trim()) {
                    this.showMessage(`ä»£ç†"${proxy.name}"çš„APIå¯†é’¥æœªå¡«å†™`, 'error');
                    return false;
                }
                if (!proxy.modelName.trim()) {
                    this.showMessage(`ä»£ç†"${proxy.name}"çš„æ¨¡å‹åç§°æœªå¡«å†™`, 'error');
                    return false;
                }

                return true;
            }

            setStatus(text, type) {
                this.elements.statusIndicator.textContent = text;
                this.elements.statusIndicator.className = `status-indicator status-${type}`;
            }

            updateRoundCounter() {
                this.elements.roundCounter.textContent = this.currentRound;
            }

            updateUI() {
                const isRunning = this.isRunning && !this.isPaused;
                const isStopped = !this.isRunning;
                const isPaused = this.isPaused;

                // æ˜¾ç¤º/éšè—æŒ‰é’®
                this.elements.pauseResumeChat.style.display = (isRunning || isPaused) ? 'inline-block' : 'none';
                this.elements.retryChat.style.display = 'none'; // éšè—å…¨å±€é‡è¯•æŒ‰é’®ï¼Œä½¿ç”¨æ¯æ¡æ¶ˆæ¯çš„é‡è¯•æŒ‰é’®

                // æ›´æ–°æš‚åœ/ç»§ç»­æŒ‰é’®çš„æ–‡å­—å’Œæ ·å¼
                if (isPaused) {
                    this.elements.pauseResumeChat.textContent = 'ç»§ç»­';
                    this.elements.pauseResumeChat.className = 'btn btn-success';
                    // å¦‚æœAIæ­£åœ¨å·¥ä½œï¼Œç¦ç”¨ç»§ç»­æŒ‰é’®
                    this.elements.pauseResumeChat.disabled = this.isAIWorking;
                } else if (isRunning) {
                    this.elements.pauseResumeChat.textContent = 'æš‚åœ';
                    this.elements.pauseResumeChat.className = 'btn btn-warning';
                    this.elements.pauseResumeChat.disabled = false;
                }

                // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
                if (isRunning) {
                    this.setStatus('è¿è¡Œä¸­', 'running');
                } else if (isPaused) {
                    this.setStatus('æš‚åœ', 'stopped');
                } else {
                    this.setStatus('å°±ç»ª', 'ready');
                }

                // æ›´æ–°æ‰€æœ‰æ¶ˆæ¯çš„æ“ä½œæŒ‰é’®æ˜¾ç¤º/éšè—
                this.updateMessageActions(isPaused);
            }

            /**
             * æ›´æ–°æ‰€æœ‰æ¶ˆæ¯çš„æ“ä½œæŒ‰é’®æ˜¾ç¤ºçŠ¶æ€
             * @param {boolean} show - æ˜¯å¦æ˜¾ç¤ºæ“ä½œæŒ‰é’®
             */
            updateMessageActions(show) {
                const messageActions = document.querySelectorAll('.message-actions');
                messageActions.forEach(actions => {
                    actions.style.display = show ? 'flex' : 'none';
                });
            }

            /**
             * é‡è¯•æŒ‡å®šæ¶ˆæ¯
             * @param {string} messageId - æ¶ˆæ¯DOMå…ƒç´ çš„ID
             */
            async retryMessage(messageId) {
                if (!this.isPaused) {
                    this.showMessage('åªæœ‰åœ¨æš‚åœçŠ¶æ€æ‰èƒ½é‡è¯•', 'error');
                    return;
                }

                if (this.isAIWorking) {
                    this.showMessage('è¯·ç­‰å¾…å½“å‰AIå®Œæˆå·¥ä½œåå†é‡è¯•', 'error');
                    return;
                }

                // æŸ¥æ‰¾æ¶ˆæ¯åœ¨conversationsæ•°ç»„ä¸­çš„ç´¢å¼•
                const messageElement = document.getElementById(messageId);
                if (!messageElement) {
                    this.showMessage('æœªæ‰¾åˆ°æ¶ˆæ¯å…ƒç´ ', 'error');
                    return;
                }

                // è·å–æ¶ˆæ¯ç´¢å¼•ï¼ˆé€šè¿‡è®¡ç®—DOMä½ç½®ï¼‰
                const allMessages = Array.from(this.elements.chatMessages.querySelectorAll('.message'));
                const messageIndex = allMessages.indexOf(messageElement);
                
                if (messageIndex < 0 || messageIndex >= this.conversations.length) {
                    this.showMessage('æ— æ³•ç¡®å®šæ¶ˆæ¯ä½ç½®', 'error');
                    return;
                }

                // è·å–è¦é‡è¯•çš„æ¶ˆæ¯
                const messageToRetry = this.conversations[messageIndex];
                if (!messageToRetry || !messageToRetry.speaker.startsWith('AI')) {
                    this.showMessage('åªèƒ½é‡è¯•AIæ¶ˆæ¯', 'error');
                    return;
                }

                // ç¡®å®šAIç±»å‹
                const aiType = messageToRetry.speaker === 'AI A' ? 'A' : 'B';

                this.addSystemMessage(`ğŸ”„ é‡è¯• ${messageToRetry.speaker} çš„æ¶ˆæ¯...`, 'info');

                // ä¸´æ—¶ç§»é™¤è¯¥æ¶ˆæ¯åŠä¹‹åçš„æ‰€æœ‰æ¶ˆæ¯
                const messagesAfter = this.conversations.splice(messageIndex);
                
                // æ‰§è¡Œé‡è¯•
                this.isAIWorking = true;
                this.updateUI();

                try {
                    const config = this.getAIConfig(aiType);
                    const messages = await this.buildMessages(aiType, true);

                    // åˆ›å»ºæ–°çš„loadingæ¶ˆæ¯
                    const loadingMessageId = this.addLoadingMessage(`AI ${aiType}`);
                    this.currentStreamingMessageId = loadingMessageId;

                    this.setStatus('é‡è¯•ä¸­', 'running');
                    const response = await this.makeAPIRequest(config, messages, `AI ${aiType}`, loadingMessageId);

                    if (response && response.content) {
                        // åˆ›å»ºæ–°çš„æ¶ˆæ¯å¯¹è±¡
                        const newMessage = new Message({
                            speaker: `AI ${aiType}`,
                            role: 'assistant',
                            content: response.content,
                            status: 'completed'
                        });

                        // æ·»åŠ åˆ°conversationsæ•°ç»„
                        this.conversations.push(newMessage);

                        // ç§»é™¤æ—§çš„DOMå…ƒç´ 
                        messageElement.remove();

                        this.currentStreamingMessageId = null;
                        this.isAIWorking = false;
                        this.addSystemMessage('âœ… é‡è¯•æˆåŠŸ', 'success');
                        this.setStatus('æš‚åœ', 'stopped');
                        this.updateUI();
                    } else {
                        throw new Error('å“åº”å†…å®¹ä¸ºç©º');
                    }
                } catch (error) {
                    console.error(`é‡è¯•å¤±è´¥:`, error);
                    
                    // æ¢å¤åŸæ¶ˆæ¯
                    this.conversations.push(...messagesAfter);
                    
                    this.showMessage(`é‡è¯•å¤±è´¥: ${error.message}`, 'error');
                    this.setStatus('æš‚åœ', 'stopped');
                    this.currentStreamingMessageId = null;
                    this.isAIWorking = false;
                    this.updateUI();
                }
            }

            /**
             * å¤åˆ¶æ¶ˆæ¯å†…å®¹åˆ°å‰ªè´´æ¿
             * @param {string} messageId - æ¶ˆæ¯DOMå…ƒç´ çš„ID
             */
            async copyMessage(messageId) {
                const messageElement = document.getElementById(messageId);
                if (!messageElement) {
                    this.showMessage('æœªæ‰¾åˆ°æ¶ˆæ¯å…ƒç´ ', 'error');
                    return;
                }

                const contentElement = messageElement.querySelector('.message-content');
                if (!contentElement) {
                    this.showMessage('æœªæ‰¾åˆ°æ¶ˆæ¯å†…å®¹', 'error');
                    return;
                }

                // è·å–çº¯æ–‡æœ¬å†…å®¹
                const textContent = contentElement.textContent || contentElement.innerText;

                try {
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        await navigator.clipboard.writeText(textContent);
                        this.showMessage('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
                    } else {
                        // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ä¼ ç»Ÿçš„å¤åˆ¶æ–¹æ³•
                        const textarea = document.createElement('textarea');
                        textarea.value = textContent;
                        textarea.style.position = 'fixed';
                        textarea.style.opacity = '0';
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                        this.showMessage('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
                    }
                } catch (error) {
                    console.error('å¤åˆ¶å¤±è´¥:', error);
                    this.showMessage('å¤åˆ¶å¤±è´¥', 'error');
                }
            }

            async retryLastRequest() {
                if (!this.isPaused) {
                    this.showMessage('åªæœ‰åœ¨æš‚åœçŠ¶æ€æ‰èƒ½é‡è¯•', 'error');
                    return;
                }

                // æ£€æŸ¥æ˜¯å¦æœ‰AIæ­£åœ¨å·¥ä½œ
                if (this.isAIWorking) {
                    this.showMessage('è¯·ç­‰å¾…å½“å‰AIå®Œæˆå·¥ä½œåå†é‡è¯•', 'error');
                    return;
                }

                const wasManuallyPaused = this.isPausedManually;

                // æ£€æŸ¥æ˜¯å¦æœ‰ä¸Šä¸€æ¡æ¶ˆæ¯
                if (this.conversations.length === 0) {
                    this.showMessage('æ²¡æœ‰å¯é‡è¯•çš„æ¶ˆæ¯', 'error');
                    return;
                }

                // ç¡®å®šè¦é‡è¯•çš„AI - åº”è¯¥ä½¿ç”¨nextSpeakerï¼ˆå®ƒæŒ‡å‘äº†åº”è¯¥å‘è¨€çš„AIï¼‰
                const aiToRetry = this.nextSpeaker;

                // ç§»é™¤æœ€åä¸€æ¡å¤±è´¥çš„æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                const lastConv = this.conversations[this.conversations.length - 1];

                // å¦‚æœæœ€åä¸€æ¡æ¶ˆæ¯æ˜¯é”™è¯¯æ¶ˆæ¯ï¼Œåˆ é™¤å®ƒ
                if (lastConv.content.includes('âŒ')) {
                    this.conversations.pop();
                    // åŒæ—¶ä»UIä¸­åˆ é™¤è¿™æ¡æ¶ˆæ¯
                    const messagesContainer = this.elements.chatMessages;
                    const lastMessageElement = messagesContainer.lastElementChild;
                    if (lastMessageElement && lastMessageElement.classList.contains('message')) {
                        lastMessageElement.remove();
                    }
                }

                this.addSystemMessage(`ğŸ”„ é‡è¯•AI ${aiToRetry}çš„æ¶ˆæ¯...`, 'info');

                // æ‰§è¡Œé‡è¯•ï¼ˆä»…ä¸€æ¬¡ï¼Œä¸ä½¿ç”¨è‡ªåŠ¨é‡è¯•æœºåˆ¶ï¼‰
                const loadingMessageId = this.addLoadingMessage(`AI ${aiToRetry}`);
                this.currentStreamingMessageId = loadingMessageId;
                this.isAIWorking = true;
                this.updateUI();

                try {
                    const config = this.getAIConfig(aiToRetry);
                    // é‡è¯•æ—¶è·³è¿‡å‹ç¼©ï¼Œå› ä¸ºç¬¬ä¸€æ¬¡è°ƒç”¨å·²ç»è§¦å‘è¿‡å‹ç¼©äº†
                    const messages = await this.buildMessages(aiToRetry, true);

                    this.setStatus('é‡è¯•ä¸­', 'running');
                    const response = await this.makeAPIRequest(config, messages, `AI ${aiToRetry}`, loadingMessageId);

                    if (response && response.content) {
                        // é‡è¯•æˆåŠŸ - åˆ›å»ºæ–°çš„æ¶ˆæ¯å¯¹è±¡
                        const newMessage = new Message({
                            speaker: `AI ${aiToRetry}`,
                            role: 'assistant',
                            content: response.content,
                            status: 'completed'
                        });
                        this.conversations.push(newMessage);

                        this.currentStreamingMessageId = null;
                        this.isAIWorking = false;
                        this.addSystemMessage('âœ… é‡è¯•æˆåŠŸ', 'success');

                        // æ ¹æ®æš‚åœç±»å‹å†³å®šåç»­æ“ä½œ
                        if (wasManuallyPaused) {
                            // æ‰‹åŠ¨æš‚åœï¼šä¿æŒæš‚åœçŠ¶æ€
                            this.setStatus('æš‚åœ', 'stopped');
                            this.updateUI();
                            this.addSystemMessage('â¸ï¸ ä¿æŒæš‚åœçŠ¶æ€ï¼Œè¯·æ‰‹åŠ¨ç‚¹å‡»ç»§ç»­æŒ‰é’®', 'info');
                        } else {
                            // è‡ªåŠ¨æš‚åœï¼šè‡ªåŠ¨ç»§ç»­å¯¹è¯
                            this.addSystemMessage('â–¶ï¸ è‡ªåŠ¨ç»§ç»­å¯¹è¯', 'success');
                            this.isPaused = false;
                            this.isPausedManually = false;
                            this.updateUI();

                            // é‡è¯•æˆåŠŸåï¼Œåˆ‡æ¢åˆ°å¯¹æ–¹AIç»§ç»­å‘è¨€
                            // ä¾‹å¦‚ï¼šAIBé‡è¯•æˆåŠŸåï¼ŒnextSpeakerä»Båˆ‡æ¢åˆ°A
                            this.nextSpeaker = this.nextSpeaker === 'A' ? 'B' : 'A';
                            this.currentRound++;
                            this.updateRoundCounter();
                            await this.sleep(1000);
                            this.runDialogue();
                        }
                    } else {
                        throw new Error('å“åº”å†…å®¹ä¸ºç©º');
                    }
                } catch (error) {
                    // é‡è¯•å¤±è´¥
                    console.error(`é‡è¯•å¤±è´¥:`, error);
                    this.addMessageToUI(`AI ${aiToRetry}`, `âŒ é‡è¯•å¤±è´¥: ${error.message}`, false, loadingMessageId);
                    this.showMessage(`é‡è¯•å¤±è´¥: ${error.message}`, 'error');
                    this.setStatus('æš‚åœ', 'stopped');
                    this.currentStreamingMessageId = null;
                    this.isAIWorking = false;
                    this.updateUI();
                    // ä¿æŒæš‚åœçŠ¶æ€
                }
            }

            exportDialogue() {
                let exportText = '# AIåŒäººå¯¹è¯è®°å½•\n\n';
                exportText += `å¯¼å‡ºæ—¶é—´: ${new Date().toLocaleString()}\n`;
                exportText += `æ€»è½®æ¬¡: ${this.currentRound}\n`;
                exportText += `ä¸Šä¸‹æ–‡é™åˆ¶: ${this.contextLimit || 'æ— é™åˆ¶'}\n`;
                exportText += `AIæ™ºèƒ½å‹ç¼©: ${this.enableCompression ? 'å·²å¯ç”¨' : 'æœªå¯ç”¨'}\n`;
                if (this.enableCompression) {
                    exportText += `å‹ç¼©å¼ºåº¦: ${(this.compressionRatio * 100).toFixed(0)}%\n`;
                    exportText += `ä¿æŠ¤æœ€è¿‘: ${this.keepRecentCount}æ¡æ¶ˆæ¯\n`;
                    if (this.compressionStats.compressionCount > 0) {
                        const totalSaved = this.compressionStats.originalTokens - this.compressionStats.compressedTokens;
                        const savedPercentage = ((totalSaved / this.compressionStats.originalTokens) * 100).toFixed(1);
                        const netSaved = totalSaved - this.compressionStats.aiCompressionTokens;
                        exportText += `TokenèŠ‚çœ: ${totalSaved} (${savedPercentage}%)\n`;
                        exportText += `AIå‹ç¼©æˆæœ¬: ${this.compressionStats.aiCompressionTokens} tokens\n`;
                        exportText += `å‡€èŠ‚çœ: ${netSaved} tokens\n`;
                    }
                }
                exportText += '\n';

                this.conversations.forEach((conv, index) => {
                    exportText += `## ${conv.speaker}\n\n${conv.content}\n\n`;
                });

                const blob = new Blob([exportText], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ai_dialogue_${new Date().getTime()}.txt`;
                a.click();
                URL.revokeObjectURL(url);
            }

            clearDialogue() {
                if (confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰å¯¹è¯è®°å½•å—ï¼Ÿ')) {
                    this.conversations = [];
                    this.currentRound = 0;
                    this.isRunning = false;
                    this.isPaused = false;
                    this.isPausedManually = false;
                    this.needsReset = false;
                    this.openingMessage = '';
                    this.nextSpeaker = 'B';
                    this.currentStreamingMessageId = null;
                    this.isAIWorking = false;
                    
                    // é‡ç½®å‹ç¼©ç»Ÿè®¡å’Œç¼“å­˜
                    this.compressedMessages = [];
                    this.compressionCache.clear();
                    this.lastCompressionIndex = 0;
                    this.compressionStats = {
                        originalTokens: 0,
                        compressedTokens: 0,
                        compressionCount: 0,
                        aiCompressionTokens: 0
                    };

                    this.elements.chatMessages.innerHTML = `
                        <div style="text-align: center; color: #666; margin-top: 50px;">
                            <h3>æ¬¢è¿ä½¿ç”¨AIåŒäººå¯¹è¯ç³»ç»Ÿ</h3>
                            <p>è¯·å…ˆé…ç½®AIå‚æ•°ï¼Œç„¶åè¾“å…¥å¼€åœºç™½å¼€å§‹å¯¹è¯</p>
                        </div>
                    `;

                    this.updateRoundCounter();
                    this.updateUI();
                    this.updateCompressionStatsUI();
                }
            }

            // æ”¹è¿›çš„æ¶ˆæ¯æ˜¾ç¤ºæ–¹æ³•
            showMessage(message, type) {
                // åœ¨èŠå¤©ç•Œé¢æ˜¾ç¤ºæ¶ˆæ¯è€Œä¸æ˜¯å¼¹å‡ºæ¡†
                if (type === 'error') {
                    this.addSystemMessage(`âŒ ${message}`, 'error');
                } else if (type === 'success') {
                    this.addSystemMessage(`âœ… ${message}`, 'success');
                } else {
                    this.addSystemMessage(`â„¹ï¸ ${message}`, 'info');
                }
            }

            // æ–°å¢ç³»ç»Ÿæ¶ˆæ¯æ˜¾ç¤ºæ–¹æ³•
            addSystemMessage(message, type = 'info') {
                const messagesContainer = this.elements.chatMessages;
                const messageDiv = document.createElement('div');

                const colorMap = {
                    'error': '#e74c3c',
                    'success': '#27ae60',
                    'info': '#3498db'
                };

                messageDiv.style.cssText = `
                    margin: 10px 0;
                    padding: 8px 12px;
                    border-radius: 4px;
                    background: rgba(${type === 'error' ? '231, 76, 60' : type === 'success' ? '39, 174, 96' : '52, 152, 219'}, 0.1);
                    border-left: 3px solid ${colorMap[type]};
                    color: ${colorMap[type]};
                    font-size: 13px;
                    text-align: center;
                `;

                messageDiv.textContent = message;
                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            /**
             * æ£€æŸ¥æ˜¯å¦åº”è¯¥è·³è¿‡æ˜¾ç¤ºè¿™æ¡æ¶ˆæ¯ï¼ˆå› ä¸ºå·²è¢«å‹ç¼©åˆ°æ‘˜è¦ä¸­ï¼‰
             * @param {string} speaker - å‘è¨€è€…
             * @param {string} content - æ¶ˆæ¯å†…å®¹
             * @returns {boolean} æ˜¯å¦åº”è¯¥è·³è¿‡æ˜¾ç¤º
             */
            shouldSkipMessage(speaker, content) {
                // æ£€æŸ¥conversationsæ•°ç»„ä¸­æ˜¯å¦æœ‰å‹ç¼©æ‘˜è¦æ¶ˆæ¯åŒ…å«è¿™æ¡åŸå§‹æ¶ˆæ¯
                const compressedMessage = this.conversations.find(conv => 
                    (conv.aiCompressed || conv.batchCompressed) &&
                    conv.originalMessages &&
                    conv.originalMessages.some(orig => 
                        orig.speaker === speaker && orig.content === content
                    )
                );
                
                return !!compressedMessage;
            }

            /**
             * è·å–æ¶ˆæ¯çš„å‹ç¼©ä¿¡æ¯ï¼ˆåŸºäºåŸå§‹æ¶ˆæ¯æŸ¥æ‰¾å¯¹åº”çš„å‹ç¼©æ¶ˆæ¯ï¼‰
             * @param {string} speaker - å‘è¨€è€…
             * @param {string} content - æ¶ˆæ¯å†…å®¹
             * @param {Object} messageData - æ¶ˆæ¯æ•°æ®
             * @returns {Object} å‹ç¼©ä¿¡æ¯
             */
            getCompressionInfoForMessage(speaker, content, messageData) {
                // æŸ¥æ‰¾åŒ…å«è¿™æ¡åŸå§‹æ¶ˆæ¯çš„å‹ç¼©æ¶ˆæ¯
                const compressedMessage = this.conversations.find(conv => 
                    (conv.aiCompressed || conv.batchCompressed) &&
                    conv.originalMessages &&
                    conv.originalMessages.some(orig => 
                        orig.speaker === speaker && orig.content === content
                    )
                );
                
                if (!compressedMessage) {
                    return { ratio: '0%', originalLength: 0, compressedLength: 0 };
                }
                
                const originalLength = compressedMessage.originalLength || 0;
                const compressedLength = compressedMessage.compressedLength || 0;
                const savedLength = originalLength - compressedLength;
                const ratio = originalLength > 0 ? Math.round((savedLength / originalLength) * 100) : 0;
                
                return {
                    originalLength,
                    compressedLength,
                    savedLength,
                    ratio: `${ratio}%`,
                    batchSize: compressedMessage.batchSize || 1,
                    compressionLevel: compressedMessage.compressionLevel || 0.5,
                    compressedContent: compressedMessage.compressedContent || compressedMessage.content
                };
            }

            /**
             * è·å–å‹ç¼©åçš„å†…å®¹ï¼ˆåŸºäºåŸå§‹æ¶ˆæ¯æŸ¥æ‰¾ï¼‰
             * @param {string} speaker - å‘è¨€è€…
             * @param {string} content - æ¶ˆæ¯å†…å®¹
             * @param {Object} messageData - æ¶ˆæ¯æ•°æ®
             * @returns {string} å‹ç¼©åçš„å†…å®¹
             */
            getCompressedContentForMessage(speaker, content, messageData) {
                // æŸ¥æ‰¾åŒ…å«è¿™æ¡åŸå§‹æ¶ˆæ¯çš„å‹ç¼©æ¶ˆæ¯
                const compressedMessage = this.conversations.find(conv => 
                    (conv.aiCompressed || conv.batchCompressed) &&
                    conv.originalMessages &&
                    conv.originalMessages.some(orig => 
                        orig.speaker === speaker && orig.content === content
                    )
                );
                
                return compressedMessage?.compressedContent || compressedMessage?.content || null;
            }

            /**
             * æ˜¾ç¤ºå‹ç¼©åçš„å†…å®¹
             * @param {string} messageId - æ¶ˆæ¯ID
             */
            showCompressedContent(messageId) {
                const messageElement = document.getElementById(messageId);
                if (!messageElement) return;

                const compressedContent = messageElement.getAttribute('data-compressed-content');
                const compressionStatsData = messageElement.getAttribute('data-compression-stats');
                
                if (!compressedContent) {
                    this.showMessage('æœªæ‰¾åˆ°å‹ç¼©å†…å®¹', 'error');
                    return;
                }

                try {
                    const compressionStats = JSON.parse(compressionStatsData || '{}');
                    
                    // è·å–åŸå§‹æ¶ˆæ¯å†…å®¹
                    const originalContent = messageElement.querySelector('.message-content').textContent;
                    
                    this.createCompressedContentPopup(originalContent, compressedContent, compressionStats);
                } catch (error) {
                    console.error('è§£æå‹ç¼©æ•°æ®å¤±è´¥:', error);
                    this.showMessage('å‹ç¼©æ•°æ®æ ¼å¼é”™è¯¯', 'error');
                }
            }

            /**
             * åˆ›å»ºå‹ç¼©å†…å®¹å¯¹æ¯”å¼¹çª—
             * @param {string} originalContent - åŸå§‹å†…å®¹
             * @param {string} compressedContent - å‹ç¼©å†…å®¹
             * @param {Object} compressionStats - å‹ç¼©ç»Ÿè®¡
             */
            createCompressedContentPopup(originalContent, compressedContent, compressionStats) {
                // ç§»é™¤ç°æœ‰å¼¹çª—
                this.closeOriginalMessagesPopup();

                // åˆ›å»ºé®ç½©å±‚
                const overlay = document.createElement('div');
                overlay.className = 'popup-overlay';
                overlay.onclick = () => this.closeOriginalMessagesPopup();

                // åˆ›å»ºå¼¹çª—
                const popup = document.createElement('div');
                popup.className = 'original-content-popup';
                popup.id = 'originalMessagesPopup';
                popup.style.maxWidth = '90%';

                // å¼¹çª—å¤´éƒ¨
                const header = document.createElement('div');
                header.className = 'popup-header';
                header.innerHTML = `
                    <h3 class="popup-title">å‹ç¼©å†…å®¹å¯¹æ¯”</h3>
                    <button class="popup-close" onclick="window.aiDialogue.closeOriginalMessagesPopup()">Ã—</button>
                `;

                // å¼¹çª—å†…å®¹
                const content = document.createElement('div');
                content.className = 'popup-content';
                content.innerHTML = `
                    <div style="display: flex; gap: 20px; margin-bottom: 15px;">
                        <div style="flex: 1;">
                            <h4 style="color: #2c3e50; margin-bottom: 10px;">ğŸ“„ åŸå§‹å†…å®¹</h4>
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; border-left: 4px solid #3498db; max-height: 300px; overflow-y: auto;">
                                ${marked.parse(originalContent)}
                            </div>
                        </div>
                        <div style="flex: 1;">
                            <h4 style="color: #e67e22; margin-bottom: 10px;">ğŸ—œï¸ å‹ç¼©å†…å®¹</h4>
                            <div style="background: #fff3cd; padding: 15px; border-radius: 6px; border-left: 4px solid #f39c12; max-height: 300px; overflow-y: auto;">
                                ${marked.parse(compressedContent)}
                            </div>
                        </div>
                    </div>
                `;

                // æ˜¾ç¤ºå‹ç¼©ç»Ÿè®¡
                if (compressionStats.originalLength) {
                    const statsDiv = document.createElement('div');
                    statsDiv.className = 'compression-stats';
                    statsDiv.innerHTML = `
                        <strong>ğŸ“Š å‹ç¼©ç»Ÿè®¡ï¼š</strong><br>
                        åŸå§‹é•¿åº¦: ${compressionStats.originalLength} tokens<br>
                        å‹ç¼©åé•¿åº¦: ${compressionStats.compressedLength} tokens<br>
                        èŠ‚çœç©ºé—´: ${compressionStats.savedLength} tokens (${compressionStats.ratio})<br>
                        <em>æ³¨ï¼šUIä¸­æ˜¾ç¤ºå®Œæ•´å†…å®¹ï¼ŒAPIè°ƒç”¨æ—¶ä½¿ç”¨å‹ç¼©å†…å®¹</em>
                    `;
                    content.appendChild(statsDiv);
                }

                popup.appendChild(header);
                popup.appendChild(content);

                document.body.appendChild(overlay);
                document.body.appendChild(popup);

                // æ˜¾ç¤ºå¼¹çª—
                setTimeout(() => {
                    overlay.style.display = 'block';
                    popup.style.display = 'block';
                }, 10);

                // ESCé”®å…³é—­
                const handleEsc = (e) => {
                    if (e.key === 'Escape') {
                        this.closeOriginalMessagesPopup();
                        document.removeEventListener('keydown', handleEsc);
                    }
                };
                document.addEventListener('keydown', handleEsc);
            }

            /**
             * æ˜¾ç¤ºåŸå§‹æ¶ˆæ¯å¼¹çª—
             * @param {string} messageId - æ¶ˆæ¯ID
             */
            showOriginalMessages(messageId) {
                const messageElement = document.getElementById(messageId);
                if (!messageElement) return;

                const originalMessagesData = messageElement.getAttribute('data-original-messages');
                const compressionStatsData = messageElement.getAttribute('data-compression-stats');
                const contextMessagesData = messageElement.getAttribute('data-context-messages');
                
                if (!originalMessagesData) {
                    this.showMessage('æœªæ‰¾åˆ°åŸå§‹æ¶ˆæ¯æ•°æ®', 'error');
                    return;
                }

                try {
                    const originalMessages = JSON.parse(originalMessagesData);
                    const compressionStats = JSON.parse(compressionStatsData || '{}');
                    const contextMessages = contextMessagesData ? JSON.parse(contextMessagesData) : null;
                    
                    this.createOriginalMessagesPopup(originalMessages, compressionStats, contextMessages);
                } catch (error) {
                    console.error('è§£æåŸå§‹æ¶ˆæ¯æ•°æ®å¤±è´¥:', error);
                    this.showMessage('åŸå§‹æ¶ˆæ¯æ•°æ®æ ¼å¼é”™è¯¯', 'error');
                }
            }

            /**
             * åˆ›å»ºåŸå§‹æ¶ˆæ¯å¼¹çª—
             * @param {Array} originalMessages - åŸå§‹æ¶ˆæ¯æ•°ç»„
             * @param {Object} compressionStats - å‹ç¼©ç»Ÿè®¡
             * @param {Array} contextMessages - ä¸Šä¸‹æ–‡æ¶ˆæ¯æ•°ç»„ï¼ˆå¯é€‰ï¼‰
             */
            createOriginalMessagesPopup(originalMessages, compressionStats, contextMessages = null) {
                // ç§»é™¤ç°æœ‰å¼¹çª—
                this.closeOriginalMessagesPopup();

                // åˆ›å»ºé®ç½©å±‚
                const overlay = document.createElement('div');
                overlay.className = 'popup-overlay';
                overlay.onclick = () => this.closeOriginalMessagesPopup();

                // åˆ›å»ºå¼¹çª—
                const popup = document.createElement('div');
                popup.className = 'original-content-popup';
                popup.id = 'originalMessagesPopup';

                // å¼¹çª—å¤´éƒ¨
                const header = document.createElement('div');
                header.className = 'popup-header';
                const totalMessages = originalMessages.length + (contextMessages ? contextMessages.length : 0);
                header.innerHTML = `
                    <h3 class="popup-title">å‹ç¼©ç›¸å…³æ¶ˆæ¯ (${totalMessages}æ¡${contextMessages ? 'ï¼Œå«' + contextMessages.length + 'æ¡ä¸Šä¸‹æ–‡' : ''})</h3>
                    <button class="popup-close" onclick="window.aiDialogue.closeOriginalMessagesPopup()">Ã—</button>
                `;

                // å¼¹çª—å†…å®¹
                const content = document.createElement('div');
                content.className = 'popup-content';

                // æ˜¾ç¤ºä¸Šä¸‹æ–‡æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                if (contextMessages && contextMessages.length > 0) {
                    const contextTitle = document.createElement('div');
                    contextTitle.innerHTML = '<h4 style="color: #666; margin: 15px 0 10px 0;">ğŸ“– ä¸Šä¸‹æ–‡æ¶ˆæ¯ï¼ˆç”¨äºç†è§£è¯­å¢ƒï¼‰</h4>';
                    content.appendChild(contextTitle);
                    
                    contextMessages.forEach((msg, index) => {
                        const msgDiv = document.createElement('div');
                        msgDiv.className = 'original-message';
                        msgDiv.style.opacity = '0.7';
                        msgDiv.innerHTML = `
                            <div class="original-message-header">${msg.speaker} (ä¸Šä¸‹æ–‡ ${index + 1})</div>
                            <div class="original-message-content">${marked.parse(msg.content)}</div>
                        `;
                        content.appendChild(msgDiv);
                    });
                }

                // æ˜¾ç¤ºåŸå§‹æ¶ˆæ¯ï¼ˆè¢«å‹ç¼©çš„ç›®æ ‡æ¶ˆæ¯ï¼‰
                if (contextMessages && contextMessages.length > 0) {
                    const originalTitle = document.createElement('div');
                    originalTitle.innerHTML = '<h4 style="color: #e74c3c; margin: 15px 0 10px 0;">ğŸ¯ è¢«å‹ç¼©çš„ç›®æ ‡æ¶ˆæ¯</h4>';
                    content.appendChild(originalTitle);
                }

                originalMessages.forEach((msg, index) => {
                    const msgDiv = document.createElement('div');
                    msgDiv.className = 'original-message';
                    if (contextMessages && contextMessages.length > 0) {
                        msgDiv.style.borderLeft = '4px solid #e74c3c';
                    }
                    msgDiv.innerHTML = `
                        <div class="original-message-header">${msg.speaker} ${contextMessages ? '(ç›®æ ‡æ¶ˆæ¯)' : '(ç¬¬' + (index + 1) + 'æ¡)'}</div>
                        <div class="original-message-content">${marked.parse(msg.content)}</div>
                    `;
                    content.appendChild(msgDiv);
                });

                // æ˜¾ç¤ºå‹ç¼©ç»Ÿè®¡
                if (compressionStats.originalLength) {
                    const statsDiv = document.createElement('div');
                    statsDiv.className = 'compression-stats';
                    const compressionType = compressionStats.batchSize > 1 ? 'æ‰¹é‡å‹ç¼©' : 'å•æ¡å‹ç¼©';
                    statsDiv.innerHTML = `
                        <strong>ğŸ“Š å‹ç¼©ç»Ÿè®¡ï¼š</strong><br>
                        å‹ç¼©æ–¹å¼: ${compressionType}<br>
                        åŸå§‹é•¿åº¦: ${compressionStats.originalLength} å­—ç¬¦<br>
                        å‹ç¼©åé•¿åº¦: ${compressionStats.compressedLength} å­—ç¬¦<br>
                        èŠ‚çœç©ºé—´: ${compressionStats.savedLength} å­—ç¬¦ (${compressionStats.ratio})<br>
                        ${compressionStats.batchSize > 1 ? 'åˆå¹¶æ¶ˆæ¯æ•°: ' + compressionStats.batchSize + ' æ¡' : ''}
                    `;
                    content.appendChild(statsDiv);
                }

                popup.appendChild(header);
                popup.appendChild(content);

                document.body.appendChild(overlay);
                document.body.appendChild(popup);

                // æ˜¾ç¤ºå¼¹çª—
                setTimeout(() => {
                    overlay.style.display = 'block';
                    popup.style.display = 'block';
                }, 10);

                // ESCé”®å…³é—­
                const handleEsc = (e) => {
                    if (e.key === 'Escape') {
                        this.closeOriginalMessagesPopup();
                        document.removeEventListener('keydown', handleEsc);
                    }
                };
                document.addEventListener('keydown', handleEsc);
            }

            /**
             * å…³é—­åŸå§‹æ¶ˆæ¯å¼¹çª—
             */
            closeOriginalMessagesPopup() {
                const overlay = document.querySelector('.popup-overlay');
                const popup = document.getElementById('originalMessagesPopup');
                
                if (overlay) overlay.remove();
                if (popup) popup.remove();
            }

            /**
             * é‡æ–°æ¸²æŸ“æ‰€æœ‰æ¶ˆæ¯ï¼ˆåŒ…æ‹¬å‹ç¼©æ¶ˆæ¯çš„å¯è§†åŒ–ï¼‰
             */
            rerenderAllMessages() {
                const messagesContainer = this.elements.chatMessages;
                messagesContainer.innerHTML = '';

                this.conversations.forEach((conv, index) => {
                    // å§‹ç»ˆæ˜¾ç¤ºå®Œæ•´æ¶ˆæ¯å†…å®¹ï¼Œä½†ä¼ é€’å‹ç¼©ä¿¡æ¯ç”¨äºæ˜¾ç¤ºå›¾æ ‡
                    const messageId = this.addMessageToUI(conv.speaker, conv.content, false, null, conv);
                });

                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            /**
             * æ›´æ–°æ¶ˆæ¯çš„å‹ç¼©å›¾æ ‡æ˜¾ç¤º
             * @param {number} messageIndex - æ¶ˆæ¯åœ¨conversationsæ•°ç»„ä¸­çš„ç´¢å¼•
             */
            updateMessageCompressionIcon(messageIndex) {
                if (messageIndex < 0 || messageIndex >= this.conversations.length) return;
                
                const conv = this.conversations[messageIndex];
                if (!conv.isCompressed || !conv.compressedContent) return;
                
                console.log(`ğŸ” å°è¯•ä¸ºæ¶ˆæ¯ ${messageIndex} æ·»åŠ å‹ç¼©å›¾æ ‡:`, conv.speaker);
                
                // æŸ¥æ‰¾å¯¹åº”çš„æ¶ˆæ¯å…ƒç´ ï¼ˆé€šè¿‡ä½ç½®å’Œå‘è¨€è€…åŒ¹é…ï¼‰
                const messageElements = document.querySelectorAll('.message');
                let targetElement = null;
                let matchCount = 0;
                
                // å…ˆæŒ‰å‘è¨€è€…ç­›é€‰ï¼Œç„¶åæŒ‰ä½ç½®åŒ¹é…
                for (let i = 0; i < messageElements.length; i++) {
                    const element = messageElements[i];
                    const headerElement = element.querySelector('.message-header');
                    
                    if (headerElement) {
                        const headerText = headerElement.textContent.trim();
                        
                        // æ£€æŸ¥å‘è¨€è€…æ˜¯å¦åŒ¹é…
                        if (headerText.includes(conv.speaker)) {
                            // å¦‚æœè¿™æ˜¯ç¬¬messageIndexä¸ªåŒ¹é…çš„å…ƒç´ ï¼Œå°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„
                            let speakerMatchIndex = 0;
                            for (let j = 0; j < this.conversations.length; j++) {
                                if (this.conversations[j].speaker === conv.speaker) {
                                    if (j === messageIndex) {
                                        break;
                                    }
                                    speakerMatchIndex++;
                                }
                            }
                            
                            if (matchCount === speakerMatchIndex) {
                                targetElement = element;
                                break;
                            }
                            matchCount++;
                        }
                    }
                }
                
                if (targetElement) {
                    const headerElement = targetElement.querySelector('.message-header');
                    
                    // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰å‹ç¼©å›¾æ ‡
                    if (!headerElement.querySelector('.compression-indicator')) {
                        console.log(`âœ… ä¸ºæ¶ˆæ¯ ${messageIndex} æ·»åŠ å‹ç¼©å›¾æ ‡`);
                        
                        // æ·»åŠ å‹ç¼©å›¾æ ‡
                        const originalLength = this.estimateTokens(conv.content);
                        const compressedLength = this.estimateTokens(conv.compressedContent);
                        const ratio = originalLength > 0 ? 
                            Math.round(((originalLength - compressedLength) / originalLength) * 100) : 0;
                        
                        const compressionIndicator = document.createElement('span');
                        compressionIndicator.className = 'compression-indicator';
                        compressionIndicator.onclick = () => this.showCompressedContent(targetElement.id);
                        compressionIndicator.title = 'ç‚¹å‡»æŸ¥çœ‹å‹ç¼©åçš„å†…å®¹';
                        compressionIndicator.innerHTML = `
                            <span class="compression-icon">ğŸ—œï¸</span>
                            <span>å·²å‹ç¼© ${ratio}%</span>
                        `;
                        
                        headerElement.appendChild(compressionIndicator);
                        
                        // å­˜å‚¨å‹ç¼©ç›¸å…³æ•°æ®
                        targetElement.setAttribute('data-compressed-content', conv.compressedContent);
                        targetElement.setAttribute('data-compression-stats', JSON.stringify({
                            originalLength: originalLength,
                            compressedLength: compressedLength,
                            savedLength: originalLength - compressedLength,
                            ratio: `${ratio}%`,
                            compressionIndex: conv.compressionIndex
                        }));
                    } else {
                        console.log(`âš ï¸ æ¶ˆæ¯ ${messageIndex} å·²æœ‰å‹ç¼©å›¾æ ‡ï¼Œè·³è¿‡`);
                    }
                } else {
                    console.warn(`âŒ æœªæ‰¾åˆ°æ¶ˆæ¯ ${messageIndex} å¯¹åº”çš„DOMå…ƒç´ :`, conv.speaker);
                }
            }

            // ====== ä¸Šä¸‹æ–‡å‹ç¼©åŠŸèƒ½æ ¸å¿ƒæ–¹æ³• ======

            /**
             * è·å–é»˜è®¤çš„å‹ç¼©æç¤ºè¯æ¨¡æ¿
             * @returns {string} é»˜è®¤æç¤ºè¯æ¨¡æ¿
             */
            getDefaultCompressionPromptTemplate() {
                return `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å¯¹è¯å‹ç¼©åŠ©æ‰‹ã€‚ä½ çš„ä»»åŠ¡æ˜¯å°†ç›®æ ‡æ¶ˆæ¯æ™ºèƒ½å‹ç¼©ï¼Œå‡å°‘çº¦{compressionRatio}%çš„å†…å®¹é•¿åº¦ï¼ŒåŒæ—¶æœ€å¤§ç¨‹åº¦ä¿ç•™å…³é”®ä¿¡æ¯ã€‚

## å‹ç¼©åŸåˆ™ï¼š
1. **ä¿ç•™æ ¸å¿ƒä¿¡æ¯**ï¼šä¿æŒä¸»è¦è§‚ç‚¹ã€ç»“è®ºå’Œé‡è¦ç»†èŠ‚
2. **ç»´æŒé€»è¾‘è¿è´¯**ï¼šç¡®ä¿å‹ç¼©åçš„å†…å®¹é€»è¾‘æ¸…æ™°ã€æ˜“äºç†è§£
3. **åˆ é™¤å†—ä½™**ï¼šå»é™¤é‡å¤ã€å•°å—¦ã€å®¢å¥—è¯ã€è¿‡æ¸¡è¯ç­‰æ— å…³ç´§è¦çš„å†…å®¹
4. **ä¿æŒè¯­æ°”å’Œé£æ ¼**ï¼šå°½é‡ä¿æŒåŸæœ‰çš„å¯¹è¯è¯­æ°”
5. **ä¿ç•™å…³é”®æ•°æ®**ï¼šä¸“ä¸šæœ¯è¯­ã€æ•°å­—ã€æ—¶é—´ã€ä¸“æœ‰åè¯ç­‰å¿…é¡»ä¿ç•™

## å‹ç¼©ç­–ç•¥ï¼š
- åˆå¹¶ç›¸ä¼¼è§‚ç‚¹å’Œé‡å¤å†…å®¹
- ç®€åŒ–å†—é•¿è¡¨è¿°ï¼Œç”¨æ›´ç²¾ç‚¼çš„è¯­è¨€
- åˆ é™¤å¯’æš„ã€æ„Ÿå¹è¯ç­‰éæ ¸å¿ƒå†…å®¹
- ä¿ç•™è®ºè¯é€»è¾‘å’Œå› æœå…³ç³»

## é‡è¦è¯´æ˜ï¼š
åªéœ€è¦è¾“å‡ºå‹ç¼©åçš„æ–‡æœ¬ï¼Œç¦æ­¢è¾“å‡ºå…¶ä»–ä»»ä½•å†…å®¹ã€‚`;
            }

            /**
             * è·å–AIå‹ç¼©çš„ç³»ç»Ÿæç¤ºè¯
             * @param {number} compressionRatio - å‹ç¼©æ¯”ç‡
             * @returns {string} å‹ç¼©æç¤ºè¯
             */
            getCompressionPrompt(compressionRatio) {
                const targetReduction = Math.round(compressionRatio * 100);
                let template = this.elements.promptSystem.value.trim();
                
                // å¦‚æœç”¨æˆ·æ²¡æœ‰è®¾ç½®è‡ªå®šä¹‰æ¨¡æ¿ï¼Œä½¿ç”¨é»˜è®¤æ¨¡æ¿
                if (!template) {
                    template = this.getDefaultCompressionPromptTemplate();
                }
                
                // æ›¿æ¢å˜é‡
                return template.replace(/\{compressionRatio\}/g, targetReduction);
            }

            /**
             * ä¼°ç®—æ–‡æœ¬çš„Tokenæ•°é‡ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
             * @param {string} text - è¦ä¼°ç®—çš„æ–‡æœ¬
             * @returns {number} ä¼°ç®—çš„Tokenæ•°é‡
             */
            estimateTokens(text) {
                if (!text) return 0;
                // ç®€åŒ–çš„Tokenä¼°ç®—ï¼šä¸­æ–‡å­—ç¬¦çº¦1.5ä¸ªtokenï¼Œè‹±æ–‡å•è¯çº¦1ä¸ªtoken
                const chineseChars = (text.match(/[\u4e00-\u9fff]/g) || []).length;
                const englishWords = (text.match(/[a-zA-Z]+/g) || []).length;
                const otherChars = text.length - chineseChars - englishWords;
                return Math.ceil(chineseChars * 1.5 + englishWords + otherChars * 0.5);
            }



            /**
             * AIæ™ºèƒ½å‹ç¼©å¯¹è¯å†å²ï¼ˆå•æ¡æ¶ˆæ¯å‹ç¼©æœºåˆ¶ï¼‰
             * @param {Array} conversations - å¯¹è¯å†å²æ•°ç»„
             * @returns {Array} ç”¨äºAPIçš„å¯¹è¯æ•°ç»„ï¼ˆåŒ…å«å‹ç¼©å†…å®¹ï¼‰
             */
            async compressConversations(conversations) {
                if (!this.enableCompression || conversations.length <= this.keepRecentCount) {
                    return conversations;
                }
                
                const totalCount = conversations.length;
                
                // è®¡ç®—éœ€è¦å‹ç¼©çš„æ¶ˆæ¯ä½ç½®ï¼ˆä»åå¾€å‰æ•°ç¬¬keepRecentCount+1æ¡ï¼‰
                const targetCompressIndex = totalCount - this.keepRecentCount - 1;
                
                // å¦‚æœç›®æ ‡å‹ç¼©ä½ç½®æ— æ•ˆæˆ–å·²ç»å‹ç¼©è¿‡ï¼Œæ„å»ºAPIç”¨çš„å¯¹è¯æ•°ç»„
                if (targetCompressIndex < 0) {
                    return conversations;
                }
                
                // æ£€æŸ¥æ˜¯å¦éœ€è¦å‹ç¼©æ–°æ¶ˆæ¯
                if (targetCompressIndex >= this.lastCompressionIndex) {
                    // éœ€è¦å‹ç¼©æ–°æ¶ˆæ¯
                    const targetMessage = conversations[targetCompressIndex];
                    const cacheKey = this.getMessageCacheKey(targetMessage, targetCompressIndex);
                    
                    if (!this.compressionCache.has(cacheKey)) {
                        // ç¡®å®šå‹ç¼©æ—¶çš„ä¸Šä¸‹æ–‡èŒƒå›´ï¼ˆåŒ…å«ç›®æ ‡æ¶ˆæ¯åœ¨å†…çš„æœ€è¿‘3æ¡ï¼Œä½¿ç”¨å®Œæ•´æ¶ˆæ¯ï¼‰
                        const contextSize = 3;
                        const contextStart = Math.max(0, targetCompressIndex - contextSize + 1);
                        const contextMessages = conversations.slice(contextStart, targetCompressIndex + 1);
                        
                        console.log(`ğŸ—œï¸ å‹ç¼©æ¶ˆæ¯ä½ç½® ${targetCompressIndex}ï¼Œä¸Šä¸‹æ–‡èŒƒå›´ ${contextStart}-${targetCompressIndex} (${contextMessages.length}æ¡)`);
                        
                        try {
                            // å‹ç¼©ç›®æ ‡æ¶ˆæ¯ï¼Œæºå¸¦ä¸Šä¸‹æ–‡ï¼ˆä½¿ç”¨å®Œæ•´æ¶ˆæ¯ï¼‰
                            const compressedContent = await this.compressTargetMessage(
                                targetMessage, 
                                contextMessages, 
                                targetCompressIndex
                            );
                            
                            // å­˜å…¥å‹ç¼©ç¼“å­˜ï¼ˆåªå­˜å‚¨å‹ç¼©åçš„å†…å®¹ï¼Œä¸æ˜¯å®Œæ•´æ¶ˆæ¯å¯¹è±¡ï¼‰
                            this.compressionCache.set(cacheKey, compressedContent);
                            
                            // æ›´æ–°å‹ç¼©ç´¢å¼•
                            this.lastCompressionIndex = targetCompressIndex + 1;
                            
                            // æ ‡è®°åŸæ¶ˆæ¯å·²è¢«å‹ç¼©ï¼ˆç”¨äºUIæ˜¾ç¤ºï¼‰
                            const targetMsg = conversations[targetCompressIndex];
                            if (targetMsg instanceof Message) {
                                targetMsg.markAsCompressed(compressedContent, targetCompressIndex);
                            } else {
                                // å‘åå…¼å®¹æ—§æ ¼å¼
                                targetMsg.isCompressed = true;
                                targetMsg.compressedContent = compressedContent;
                                targetMsg.compressionIndex = targetCompressIndex;
                            }
                            
                            // ç«‹å³æ›´æ–°UIæ˜¾ç¤ºå‹ç¼©å›¾æ ‡ï¼ˆå»¶è¿Ÿæ‰§è¡Œç¡®ä¿DOMå·²æ›´æ–°ï¼‰
                            setTimeout(() => {
                                this.updateMessageCompressionIcon(targetCompressIndex);
                            }, 200);
                            
                        } catch (error) {
                            console.error('å‹ç¼©å¤±è´¥:', error);
                            this.showCompressionError(error, 1);
                        }
                    } else {
                        // ä½¿ç”¨ç¼“å­˜çš„å‹ç¼©ç»“æœ
                        const cachedCompressed = this.compressionCache.get(cacheKey);
                        const targetMsg = conversations[targetCompressIndex];
                        if (targetMsg instanceof Message) {
                            targetMsg.markAsCompressed(cachedCompressed, targetCompressIndex);
                        } else {
                            // å‘åå…¼å®¹æ—§æ ¼å¼
                            targetMsg.isCompressed = true;
                            targetMsg.compressedContent = cachedCompressed;
                            targetMsg.compressionIndex = targetCompressIndex;
                        }
                        
                        // ç«‹å³æ›´æ–°UIæ˜¾ç¤ºå‹ç¼©å›¾æ ‡ï¼ˆå»¶è¿Ÿæ‰§è¡Œç¡®ä¿DOMå·²æ›´æ–°ï¼‰
                        setTimeout(() => {
                            this.updateMessageCompressionIcon(targetCompressIndex);
                        }, 200);
                        
                        console.log(`âœ… ä½¿ç”¨ç¼“å­˜ï¼Œè·³è¿‡å‹ç¼©ä½ç½® ${targetCompressIndex}`);
                    }
                }
                
                // æ„å»ºç”¨äºAPIçš„å¯¹è¯æ•°ç»„ï¼ˆä½¿ç”¨å‹ç¼©å†…å®¹ï¼‰
                return this.buildAPIConversations(conversations);
            }

            /**
             * æ„å»ºç”¨äºAPIçš„å¯¹è¯æ•°ç»„ï¼ˆä½¿ç”¨å‹ç¼©å†…å®¹ï¼‰
             * @param {Array} conversations - åŸå§‹å¯¹è¯æ•°ç»„
             * @returns {Array} ç”¨äºAPIçš„å¯¹è¯æ•°ç»„
             */
            buildAPIConversations(conversations) {
                const totalCount = conversations.length;
                const result = [];
                
                for (let i = 0; i < totalCount; i++) {
                    const conv = conversations[i];
                    
                    // åˆ¤æ–­æ˜¯å¦åº”è¯¥ä½¿ç”¨å‹ç¼©å†…å®¹
                    const shouldUseCompressed = conv.isCompressed && 
                                               i < (totalCount - this.keepRecentCount) && // ä¸åœ¨ä¿æŠ¤èŒƒå›´å†…
                                               conv.compressedContent; // æœ‰å‹ç¼©å†…å®¹
                    
                    if (shouldUseCompressed) {
                        // ä½¿ç”¨å‹ç¼©å†…å®¹
                        result.push({
                            role: conv.role,
                            content: conv.compressedContent,
                            speaker: conv.speaker,
                            isFromCompression: true
                        });
                    } else {
                        // ä½¿ç”¨å®Œæ•´å†…å®¹
                        result.push({
                            role: conv.role,
                            content: conv.content,
                            speaker: conv.speaker
                        });
                    }
                }
                
                return result;
            }

            /**
             * å‹ç¼©ç›®æ ‡æ¶ˆæ¯ï¼ˆæºå¸¦ä¸Šä¸‹æ–‡ï¼‰
             * @param {Object} targetMessage - ç›®æ ‡æ¶ˆæ¯
             * @param {Array} contextMessages - ä¸Šä¸‹æ–‡æ¶ˆæ¯æ•°ç»„ï¼ˆåŒ…å«ç›®æ ‡æ¶ˆæ¯ï¼‰
             * @param {number} targetIndex - ç›®æ ‡æ¶ˆæ¯åœ¨åŸæ•°ç»„ä¸­çš„ç´¢å¼•
             * @returns {string} å‹ç¼©åçš„å†…å®¹
             */
            async compressTargetMessage(targetMessage, contextMessages, targetIndex) {
                try {
                    // è®¡ç®—åŸå§‹Tokenæ•°é‡
                    const originalTokenCount = this.estimateTokens(targetMessage.content);
                    
                    // æ„å»ºå‹ç¼©è¯·æ±‚
                    const compressionPrompt = this.getCompressionPrompt(this.compressionRatio);
                    
                    // æ„å»ºä¸Šä¸‹æ–‡æ–‡æœ¬ï¼ˆç”¨äºAIç†è§£ä¸Šä¸‹æ–‡ï¼Œä½¿ç”¨å®Œæ•´æ¶ˆæ¯ï¼‰
                    const contextText = contextMessages.map((msg, idx) => {
                        const isTarget = msg === targetMessage;
                        const prefix = isTarget ? 'ã€ç›®æ ‡æ¶ˆæ¯ã€‘' : 'ã€ä¸Šä¸‹æ–‡ã€‘';
                        // å§‹ç»ˆä½¿ç”¨å®Œæ•´å†…å®¹ä½œä¸ºå‹ç¼©ä¸Šä¸‹æ–‡
                        return `${prefix}${msg.speaker}: ${msg.content}`;
                    }).join('\n\n');
                    
                    const messages = [
                        { role: 'system', content: compressionPrompt },
                        { 
                            role: 'user', 
                            content: `è¯·å‹ç¼©ä¸‹é¢æ ‡è®°ä¸ºã€ç›®æ ‡æ¶ˆæ¯ã€‘çš„å†…å®¹ï¼Œå…¶ä»–ã€ä¸Šä¸‹æ–‡ã€‘æ¶ˆæ¯ä»…ç”¨äºç†è§£è¯­å¢ƒï¼Œä¸éœ€è¦å‹ç¼©ï¼š\n\n${contextText}\n\nè¯·åªè¿”å›ç›®æ ‡æ¶ˆæ¯çš„å‹ç¼©ç‰ˆæœ¬ã€‚` 
                        }
                    ];
                    
                    // æ˜¾ç¤ºå‹ç¼©è¿›è¡Œä¸­çš„æç¤º
                    this.addSystemMessage(`ğŸ¤– AIæ­£åœ¨å‹ç¼©ç¬¬${targetIndex + 1}æ¡æ¶ˆæ¯ (æºå¸¦${contextMessages.length}æ¡ä¸Šä¸‹æ–‡)...`, 'info');
                    
                    // ä½¿ç”¨ç»Ÿä¸€çš„AIè°ƒç”¨é€»è¾‘ï¼ˆå¸¦é‡è¯•ï¼‰
                    const systemConfig = this.getAIConfig('System');
                    const response = await this.callAIWithRetry('System', systemConfig, messages);
                    
                    if (!response || !response.content) {
                        throw new Error('AIå‹ç¼©å“åº”ä¸ºç©º');
                    }
                    
                    // è§£æAIè¿”å›çš„å‹ç¼©ç»“æœï¼ˆç°åœ¨ç›´æ¥è¿”å›æ–‡æœ¬ï¼‰
                    const compressedContent = this.parseCompressionResult(response.content);
                    
                    if (!compressedContent || compressedContent.trim().length === 0) {
                        throw new Error('AIå‹ç¼©ç»“æœä¸ºç©º');
                    }
                    
                    // è®¡ç®—å‹ç¼©ç»Ÿè®¡
                    const compressedTokenCount = this.estimateTokens(compressedContent);
                    const aiCompressionCost = this.estimateTokens(compressionPrompt) + 
                                            this.estimateTokens(contextText) + 
                                            this.estimateTokens(response.content);
                    
                    // æ›´æ–°å‹ç¼©ç»Ÿè®¡
                    this.compressionStats.originalTokens += originalTokenCount;
                    this.compressionStats.compressedTokens += compressedTokenCount;
                    this.compressionStats.aiCompressionTokens += aiCompressionCost;
                    this.compressionStats.compressionCount++;
                    
                    const savedTokens = originalTokenCount - compressedTokenCount;
                    const savedPercentage = ((savedTokens / originalTokenCount) * 100).toFixed(1);
                    
                    // æ˜¾ç¤ºå‹ç¼©ç»Ÿè®¡ä¿¡æ¯
                    this.addSystemMessage(
                        `ğŸ¤– å‹ç¼©å®Œæˆï¼šç¬¬${targetIndex + 1}æ¡æ¶ˆæ¯ï¼ŒèŠ‚çœ ${savedTokens} tokens (${savedPercentage}%)`, 
                        'info'
                    );
                    
                    // å¼ºåˆ¶æ›´æ–°å‹ç¼©å›¾æ ‡ï¼ˆå»¶è¿Ÿæ‰§è¡Œï¼‰
                    setTimeout(() => {
                        console.log(`ğŸ”§ å¼ºåˆ¶æ›´æ–°æ¶ˆæ¯ ${targetIndex} çš„å‹ç¼©å›¾æ ‡`);
                        this.updateMessageCompressionIcon(targetIndex);
                    }, 1000);
                    
                    // æ›´æ–°å‹ç¼©ç»Ÿè®¡UI
                    this.updateCompressionStatsUI();
                    
                    // è¿”å›å‹ç¼©åçš„å†…å®¹å­—ç¬¦ä¸²
                    return compressedContent;
                    
                } catch (error) {
                    console.error('ç›®æ ‡æ¶ˆæ¯å‹ç¼©å¤±è´¥:', error);
                    throw error;
                }
            }

            /**
             * æ‰¹é‡å‹ç¼©ä¸€ç»„æ¶ˆæ¯ï¼ˆå¤šæ¡æ¶ˆæ¯å‹ç¼©ä¸ºä¸€æ¡ï¼‰- ä¿ç•™ç”¨äºå‘åå…¼å®¹
             * @param {Array} messageBatch - æ¶ˆæ¯æ‰¹æ¬¡ï¼ˆå¤šæ¡æ¶ˆæ¯ï¼‰
             * @returns {Array} å‹ç¼©åçš„æ¶ˆæ¯æ•°ç»„ï¼ˆåªæœ‰ä¸€æ¡æ¶ˆæ¯ï¼‰
             */
            async compressMessageBatch(messageBatch) {
                if (!messageBatch || messageBatch.length === 0) {
                    return [];
                }
                
                // ç”Ÿæˆæ‰¹æ¬¡ç¼“å­˜keyï¼ˆåŸºäºæ‰€æœ‰æ¶ˆæ¯çš„ç»„åˆå†…å®¹ï¼‰
                const batchCacheKey = this.getBatchCacheKey(messageBatch);
                
                // æ£€æŸ¥æ‰¹æ¬¡ç¼“å­˜
                if (this.compressionCache.has(batchCacheKey)) {
                    console.log(`âœ… ä½¿ç”¨æ‰¹æ¬¡ç¼“å­˜ï¼Œè·³è¿‡å‹ç¼© (${messageBatch.length}æ¡æ¶ˆæ¯)`);
                    return this.compressionCache.get(batchCacheKey);
                }
                
                try {
                    // è®¡ç®—åŸå§‹Tokenæ•°é‡
                    const originalTokenCount = messageBatch.reduce((sum, conv) => 
                        sum + this.estimateTokens(conv.content), 0);
                    
                    // æ„å»ºå‹ç¼©è¯·æ±‚
                    const compressionPrompt = this.getCompressionPrompt(this.compressionRatio);
                    const conversationText = messageBatch.map(conv => 
                        `${conv.speaker}: ${conv.content}`
                    ).join('\n\n');
                    
                    const messages = [
                        { role: 'system', content: compressionPrompt },
                        { 
                            role: 'user', 
                            content: `è¯·å°†ä»¥ä¸‹${messageBatch.length}æ¡è¿ç»­å¯¹è¯å‹ç¼©ä¸ºä¸€æ¡æ‘˜è¦æ¶ˆæ¯ï¼Œä¿æŒå¯¹è¯çš„æ ¸å¿ƒå†…å®¹å’Œé€»è¾‘ï¼š\n\n${conversationText}` 
                        }
                    ];
                    
                    // æ˜¾ç¤ºå‹ç¼©è¿›è¡Œä¸­çš„æç¤º
                    this.addSystemMessage(`ğŸ¤– AIæ­£åœ¨å°†${messageBatch.length}æ¡å¯¹è¯å‹ç¼©ä¸º1æ¡æ‘˜è¦...`, 'info');
                    
                    // ä½¿ç”¨ç»Ÿä¸€çš„AIè°ƒç”¨é€»è¾‘ï¼ˆå¸¦é‡è¯•ï¼‰
                    const systemConfig = this.getAIConfig('System');
                    const response = await this.callAIWithRetry('System', systemConfig, messages);
                    
                    if (!response || !response.content) {
                        throw new Error('AIæ‰¹é‡å‹ç¼©å“åº”ä¸ºç©º');
                    }
                    
                    // è§£æAIè¿”å›çš„å‹ç¼©ç»“æœ
                    const compressedResult = this.parseCompressionResult(response.content);
                    
                    if (!compressedResult || !compressedResult.compressed_messages || compressedResult.compressed_messages.length === 0) {
                        throw new Error('AIæ‰¹é‡å‹ç¼©ç»“æœè§£æå¤±è´¥');
                    }
                    
                    // åˆ›å»ºä¸€æ¡å‹ç¼©æ‘˜è¦æ¶ˆæ¯ï¼ˆåˆå¹¶å¤šæ¡æ¶ˆæ¯ä¸ºä¸€æ¡ï¼‰
                    const firstMessage = compressedResult.compressed_messages[0];
                    const compressedMessage = {
                        role: 'assistant',
                        content: firstMessage.content, // è¿™æ˜¯å‹ç¼©åçš„å†…å®¹ï¼Œä¼šæ˜¾ç¤ºåœ¨ç•Œé¢ä¸Š
                        speaker: `å‹ç¼©æ‘˜è¦ (${messageBatch.length}æ¡æ¶ˆæ¯)`,
                        originalLength: originalTokenCount,
                        compressedLength: this.estimateTokens(firstMessage.content),
                        compressionLevel: this.compressionRatio,
                        aiCompressed: true,
                        batchCompressed: true,
                        batchSize: messageBatch.length,
                        originalMessages: messageBatch.map(m => ({
                            speaker: m.speaker,
                            content: m.content,
                            originalLength: m.content.length
                        })),
                        compressedContent: firstMessage.content // å­˜å‚¨å‹ç¼©åçš„å†…å®¹
                    };
                    
                    // å­˜å…¥æ‰¹æ¬¡ç¼“å­˜
                    this.compressionCache.set(batchCacheKey, [compressedMessage]);
                    
                    // è®¡ç®—å‹ç¼©ç»Ÿè®¡
                    const compressedTokenCount = this.estimateTokens(firstMessage.content);
                    const aiCompressionCost = this.estimateTokens(compressionPrompt) + 
                                            this.estimateTokens(conversationText) + 
                                            this.estimateTokens(response.content);
                    
                    // æ›´æ–°å‹ç¼©ç»Ÿè®¡
                    this.compressionStats.originalTokens += originalTokenCount;
                    this.compressionStats.compressedTokens += compressedTokenCount;
                    this.compressionStats.aiCompressionTokens += aiCompressionCost;
                    this.compressionStats.compressionCount++;
                    
                    const savedTokens = originalTokenCount - compressedTokenCount;
                    const netSavedTokens = savedTokens - aiCompressionCost;
                    const savedPercentage = ((savedTokens / originalTokenCount) * 100).toFixed(1);
                    
                    // æ˜¾ç¤ºæ‰¹é‡å‹ç¼©ç»Ÿè®¡ä¿¡æ¯
                    this.addSystemMessage(
                        `ğŸ¤– å‹ç¼©å®Œæˆï¼š${messageBatch.length}æ¡æ¶ˆæ¯â†’1æ¡æ‘˜è¦ï¼ŒèŠ‚çœ ${savedTokens} tokens (${savedPercentage}%)`, 
                        'info'
                    );
                    
                    // æ›´æ–°å‹ç¼©ç»Ÿè®¡UI
                    this.updateCompressionStatsUI();
                    
                    return [compressedMessage];
                    
                } catch (error) {
                    console.error('æ‰¹é‡å‹ç¼©å¤±è´¥:', error);
                    
                    // æ˜¾ç¤ºè¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
                    this.showCompressionError(error, messageBatch.length);
                    
                    // æ‰¹é‡å‹ç¼©å¤±è´¥ï¼Œè¿”å›åŸå§‹æ¶ˆæ¯
                    this.addSystemMessage(`âŒ æ‰¹é‡å‹ç¼©å¤±è´¥ï¼Œä¿æŒåŸå§‹${messageBatch.length}æ¡æ¶ˆæ¯ä¸å‹ç¼©`, 'error');
                    return messageBatch;
                }
            }

            /**
             * ç”Ÿæˆæ‰¹æ¬¡ç¼“å­˜key
             * @param {Array} messageBatch - æ¶ˆæ¯æ‰¹æ¬¡
             * @returns {string} æ‰¹æ¬¡ç¼“å­˜key
             */
            getBatchCacheKey(messageBatch) {
                // å°†æ‰¹æ¬¡ä¸­æ‰€æœ‰æ¶ˆæ¯çš„å†…å®¹ç»„åˆç”Ÿæˆhash
                const batchContent = messageBatch.map(msg => `${msg.speaker}:${msg.content}`).join('|');
                const hash = batchContent.split('').reduce((a, b) => {
                    a = ((a << 5) - a) + b.charCodeAt(0);
                    return a & a;
                }, 0);
                return `batch_${messageBatch.length}_${hash.toString()}`;
            }

            /**
             * è·å–ç¼“å­˜çš„å‹ç¼©å¯¹è¯
             * @param {Array} conversations - å¯¹è¯å†å²æ•°ç»„
             * @returns {Array} ç¼“å­˜çš„å‹ç¼©ç»“æœ
             */
            getCachedCompressedConversations(conversations) {
                // å¦‚æœæ²¡æœ‰ç¼“å­˜ï¼Œåˆ™è¿”å›åŸå§‹å¯¹è¯
                if (this.compressionCache.size === 0) {
                    return conversations;
                }
                
                return conversations.map(conv => {
                    const cacheKey = this.getMessageCacheKey(conv);
                    return this.compressionCache.get(cacheKey) || conv;
                });
            }

            /**
             * ç”Ÿæˆæ¶ˆæ¯çš„ç¼“å­˜key
             * @param {Object} message - æ¶ˆæ¯å¯¹è±¡
             * @param {number} index - æ¶ˆæ¯åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•ï¼ˆå¯é€‰ï¼‰
             * @returns {string} ç¼“å­˜key
             */
            getMessageCacheKey(message, index = null) {
                // ä½¿ç”¨æ¶ˆæ¯å†…å®¹ã€å‘è¨€è€…å’Œä½ç½®ç”Ÿæˆhash
                const content = `${message.speaker}:${message.content}${index !== null ? ':' + index : ''}`;
                const hash = content.split('').reduce((a, b) => {
                    a = ((a << 5) - a) + b.charCodeAt(0);
                    return a & a;
                }, 0);
                return hash.toString();
            }





            /**
             * è§£æAIå‹ç¼©ç»“æœï¼ˆç®€åŒ–ç‰ˆ - ç›´æ¥è¿”å›æ–‡æœ¬ï¼‰
             * @param {string} content - AIè¿”å›çš„å†…å®¹
             * @returns {string} å‹ç¼©åçš„æ–‡æœ¬
             */
            parseCompressionResult(content) {
                if (!content || typeof content !== 'string') {
                    throw new Error('AIå“åº”å†…å®¹ä¸ºç©ºæˆ–æ ¼å¼ä¸æ­£ç¡®');
                }

                // æ¸…ç†å†…å®¹ï¼šå»é™¤å¯èƒ½çš„markdownä»£ç å—æ ‡è®°
                let cleanContent = content.trim();
                
                // å¦‚æœAIè¿”å›äº†ä»£ç å—æ ¼å¼ï¼Œæå–å†…å®¹
                const codeBlockMatch = cleanContent.match(/```(?:text|markdown)?\s*([\s\S]*?)\s*```/);
                if (codeBlockMatch) {
                    cleanContent = codeBlockMatch[1].trim();
                }
                
                // éªŒè¯å†…å®¹ä¸ä¸ºç©º
                if (!cleanContent || cleanContent.length < 10) {
                    throw new Error('AIè¿”å›çš„å‹ç¼©å†…å®¹è¿‡çŸ­æˆ–ä¸ºç©º');
                }
                
                console.log('âœ… å‹ç¼©å†…å®¹è§£ææˆåŠŸï¼Œé•¿åº¦:', cleanContent.length);
                
                // ç›´æ¥è¿”å›æ¸…ç†åçš„æ–‡æœ¬
                return cleanContent;
            }

            /**
             * æ˜¾ç¤ºå‹ç¼©é”™è¯¯çš„è¯¦ç»†ä¿¡æ¯
             * @param {Error} error - é”™è¯¯å¯¹è±¡
             * @param {number} messageCount - æ¶ˆæ¯æ•°é‡
             */
            showCompressionError(error, messageCount) {
                let errorType = 'æœªçŸ¥é”™è¯¯';
                let suggestion = '';
                
                if (error.message.includes('HTTP 401') || error.message.includes('Unauthorized')) {
                    errorType = 'APIå¯†é’¥é”™è¯¯';
                    suggestion = 'è¯·æ£€æŸ¥ç³»ç»ŸAIçš„APIå¯†é’¥æ˜¯å¦æ­£ç¡®';
                } else if (error.message.includes('HTTP 429') || error.message.includes('Rate limit')) {
                    errorType = 'APIè°ƒç”¨é¢‘ç‡é™åˆ¶';
                    suggestion = 'è¯·ç¨åé‡è¯•æˆ–æ£€æŸ¥APIé…é¢';
                } else if (error.message.includes('HTTP 400') || error.message.includes('Bad Request')) {
                    errorType = 'APIè¯·æ±‚æ ¼å¼é”™è¯¯';
                    suggestion = 'è¯·æ£€æŸ¥ç³»ç»ŸAIæ¨¡å‹åç§°æ˜¯å¦æ­£ç¡®';
                } else if (error.message.includes('HTTP 404')) {
                    errorType = 'APIç«¯ç‚¹ä¸å­˜åœ¨';
                    suggestion = 'è¯·æ£€æŸ¥ç³»ç»ŸAIçš„APIåœ°å€æ˜¯å¦æ­£ç¡®';
                } else if (error.message.includes('HTTP 500') || error.message.includes('Internal Server Error')) {
                    errorType = 'APIæœåŠ¡å™¨å†…éƒ¨é”™è¯¯';
                    suggestion = 'æœåŠ¡å™¨æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åé‡è¯•';
                } else if (error.message.includes('ç½‘ç»œé”™è¯¯') || error.message.includes('Failed to fetch')) {
                    errorType = 'ç½‘ç»œè¿æ¥é”™è¯¯';
                    suggestion = 'è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–APIåœ°å€';
                } else if (error.message.includes('è§£æå¤±è´¥') || error.message.includes('JSON')) {
                    errorType = 'AIå“åº”è§£æå¤±è´¥';
                    suggestion = 'å¯èƒ½æ˜¯æ¨¡å‹è¿”å›æ ¼å¼ä¸æ­£ç¡®ï¼Œå»ºè®®è°ƒæ•´æç¤ºè¯';
                } else if (error.message.includes('å“åº”ä¸ºç©º')) {
                    errorType = 'AIæ— å“åº”';
                    suggestion = 'æ¨¡å‹å¯èƒ½é‡åˆ°é—®é¢˜ï¼Œè¯·æ£€æŸ¥é…ç½®æˆ–ç¨åé‡è¯•';
                }
                
                const errorMessage = `
âŒ AIå‹ç¼©å¤±è´¥è¯¦æƒ…ï¼š
â€¢ é”™è¯¯ç±»å‹: ${errorType}
â€¢ å¤„ç†æ¶ˆæ¯: ${messageCount}æ¡
â€¢ å»ºè®®æ“ä½œ: ${suggestion}
â€¢ æŠ€æœ¯è¯¦æƒ…: ${error.message}
                `.trim();
                
                this.addSystemMessage(errorMessage, 'error');
            }

            /**
             * ç»Ÿä¸€çš„AIè°ƒç”¨æ–¹æ³•ï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
             * @param {string} aiType - AIç±»å‹
             * @param {Object} config - AIé…ç½®
             * @param {Array} messages - æ¶ˆæ¯æ•°ç»„
             * @returns {Object} APIå“åº”
             */
            async callAIWithRetry(aiType, config, messages) {
                let currentRetries = 0;
                
                while (currentRetries <= this.retryCount) {
                    try {
                        if (currentRetries > 0) {
                            this.addSystemMessage(`ğŸ”„ ${aiType === 'System' ? 'ç³»ç»ŸAI' : 'AI ' + aiType} é‡è¯•ä¸­ (${currentRetries}/${this.retryCount})...`, 'info');
                            await this.sleep(this.retryDelay);
                        }
                        
                        // æ ¹æ®AIç±»å‹è°ƒç”¨ç›¸åº”çš„API
                        if (config.endpointType === 'openai') {
                            if (aiType === 'System') {
                                return await this.callOpenAIForCompression(config, messages);
                            } else {
                                // å¯¹è¯AIä½¿ç”¨æµå¼è°ƒç”¨ï¼ˆè¿™é‡Œç®€åŒ–ä¸ºéæµå¼ï¼‰
                                return await this.callOpenAIForCompression(config, messages);
                            }
                        } else if (config.endpointType === 'gemini') {
                            if (aiType === 'System') {
                                return await this.callGeminiForCompression(config, messages);
                            } else {
                                // å¯¹è¯AIä½¿ç”¨æµå¼è°ƒç”¨ï¼ˆè¿™é‡Œç®€åŒ–ä¸ºéæµå¼ï¼‰
                                return await this.callGeminiForCompression(config, messages);
                            }
                        } else {
                            throw new Error(`ä¸æ”¯æŒçš„AIç±»å‹: ${config.endpointType}`);
                        }
                        
                    } catch (error) {
                        console.warn(`AI ${aiType} å°è¯• ${currentRetries + 1} å¤±è´¥:`, error.message);
                        currentRetries++;
                        
                        // å¦‚æœæ˜¯é…ç½®é”™è¯¯ï¼Œä¸éœ€è¦é‡è¯•
                        if (error.message.includes('HTTP 401') || 
                            error.message.includes('HTTP 404') || 
                            error.message.includes('ä¸æ”¯æŒçš„')) {
                            break;
                        }
                        
                        if (currentRetries <= this.retryCount) {
                            this.addSystemMessage(`âŒ AI ${aiType} è°ƒç”¨å¤±è´¥ï¼Œ${this.retryDelay/1000}ç§’åé‡è¯• (${currentRetries}/${this.retryCount})`, 'error');
                        }
                    }
                }
                
                // é‡è¯•æ¬¡æ•°ç”¨å®Œï¼Œæš‚åœå¯¹è¯
                this.addSystemMessage(`âŒ AI ${aiType} è°ƒç”¨å¤±è´¥ï¼Œå·²è¾¾é‡è¯•ä¸Šé™ï¼Œå¯¹è¯å·²æš‚åœ`, 'error');
                this.isPaused = true;
                this.updateUI();
                
                throw new Error(`AI ${aiType} è°ƒç”¨å¤±è´¥ï¼Œå·²è¾¾é‡è¯•ä¸Šé™`);
            }

            /**
             * è°ƒç”¨OpenAIè¿›è¡Œå‹ç¼©ï¼ˆéæµå¼ï¼‰
             */
            async callOpenAIForCompression(config, messages) {
                // ä¿®å¤ï¼šå¦‚æœURLä»¥#ç»“å°¾ï¼Œå¼ºåˆ¶ä½¿ç”¨è¾“å…¥åœ°å€ï¼›å¦åˆ™è‡ªåŠ¨è¡¥å…¨
                let url;
                if (config.apiUrl.endsWith('#')) {
                    url = config.apiUrl.slice(0, -1); // å»æ‰æœ«å°¾çš„#
                } else if (config.apiUrl.endsWith('/v1/chat/completions')) {
                    url = config.apiUrl;
                } else {
                    url = `${config.apiUrl}/v1/chat/completions`;
                }

                let response;
                try {
                    response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${config.apiKey}`
                        },
                        body: JSON.stringify({
                            model: config.model,
                            messages: messages,
                            temperature: 0.7
                        })
                    });
                } catch (error) {
                    throw new Error(`ç½‘ç»œé”™è¯¯: ${error.message}`);
                }

                if (!response.ok) {
                    let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        if (errorData.error && errorData.error.message) {
                            errorMessage += ` - ${errorData.error.message}`;
                        }
                    } catch (e) {
                        // å¿½ç•¥JSONè§£æé”™è¯¯
                    }
                    throw new Error(errorMessage);
                }

                let data;
                try {
                    data = await response.json();
                } catch (error) {
                    throw new Error(`å“åº”è§£æå¤±è´¥: ${error.message}`);
                }

                const content = data.choices?.[0]?.message?.content;
                if (!content) {
                    throw new Error('OpenAI APIå“åº”ä¸ºç©ºæˆ–æ ¼å¼ä¸æ­£ç¡®');
                }

                return { content };
            }

            /**
             * è°ƒç”¨Geminiè¿›è¡Œå‹ç¼©ï¼ˆéæµå¼ï¼‰
             */
            async callGeminiForCompression(config, messages) {
                const url = `${config.apiUrl}/v1beta/models/${config.model}:generateContent?key=${config.apiKey}`;

                // è½¬æ¢æ¶ˆæ¯æ ¼å¼
                const contents = messages.filter(m => m.role !== 'system').map(m => ({
                    role: m.role === 'assistant' ? 'model' : 'user',
                    parts: [{ text: m.content }]
                }));

                const systemInstruction = messages.find(m => m.role === 'system');
                const requestBody = {
                    contents: contents,
                    generationConfig: {
                        temperature: 0.7
                    }
                };

                if (systemInstruction) {
                    requestBody.systemInstruction = {
                        parts: [{ text: systemInstruction.content }]
                    };
                }

                let response;
                try {
                    response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });
                } catch (error) {
                    throw new Error(`ç½‘ç»œé”™è¯¯: ${error.message}`);
                }

                if (!response.ok) {
                    let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        if (errorData.error && errorData.error.message) {
                            errorMessage += ` - ${errorData.error.message}`;
                        }
                    } catch (e) {
                        // å¿½ç•¥JSONè§£æé”™è¯¯
                    }
                    throw new Error(errorMessage);
                }

                let data;
                try {
                    data = await response.json();
                } catch (error) {
                    throw new Error(`å“åº”è§£æå¤±è´¥: ${error.message}`);
                }

                // æ£€æŸ¥Geminiç‰¹æœ‰çš„é”™è¯¯æ ¼å¼
                if (data.error) {
                    throw new Error(`Gemini APIé”™è¯¯: ${data.error.message || 'æœªçŸ¥é”™è¯¯'}`);
                }

                const content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!content) {
                    // æ£€æŸ¥æ˜¯å¦è¢«å®‰å…¨è¿‡æ»¤å™¨é˜»æ­¢
                    if (data.candidates?.[0]?.finishReason === 'SAFETY') {
                        throw new Error('å†…å®¹è¢«Geminiå®‰å…¨è¿‡æ»¤å™¨é˜»æ­¢ï¼Œè¯·è°ƒæ•´æç¤ºè¯');
                    }
                    throw new Error('Gemini APIå“åº”ä¸ºç©ºæˆ–æ ¼å¼ä¸æ­£ç¡®');
                }

                return { content };
            }

            /**
             * è·å–å‹ç¼©ç»Ÿè®¡ä¿¡æ¯
             */
            getCompressionStats() {
                const stats = this.compressionStats;
                if (stats.compressionCount === 0) {
                    return 'æš‚æ— å‹ç¼©ç»Ÿè®¡';
                }
                
                const totalSaved = stats.originalTokens - stats.compressedTokens;
                const avgSavedPercentage = ((totalSaved / stats.originalTokens) * 100).toFixed(1);
                
                return `æ€»è®¡å‹ç¼© ${stats.compressionCount} æ¬¡ï¼ŒèŠ‚çœ ${totalSaved} tokens (${avgSavedPercentage}%)`;
            }

            /**
             * æ›´æ–°å‹ç¼©ç»Ÿè®¡UIæ˜¾ç¤º
             */
            updateCompressionStatsUI() {
                const statsSection = document.getElementById('compressionStatsSection');
                const statsDiv = document.getElementById('compressionStats');

                if (this.enableCompression && this.compressionStats.compressionCount > 0) {
                    const stats = this.compressionStats;
                    const totalSaved = stats.originalTokens - stats.compressedTokens;
                    const netSaved = totalSaved - (stats.aiCompressionTokens || 0);
                    const avgSavedPercentage = ((totalSaved / stats.originalTokens) * 100).toFixed(1);

                    let statsHtml = `
                        ğŸ“Š å‹ç¼©æ¬¡æ•°: ${stats.compressionCount}<br>
                        ğŸ’¾ èŠ‚çœToken: ${totalSaved} (${avgSavedPercentage}%)<br>
                        ğŸ“ˆ åŸå§‹Token: ${stats.originalTokens}<br>
                        ğŸ“‰ å‹ç¼©åToken: ${stats.compressedTokens}<br>
                        ğŸ¤– AIå‹ç¼©æˆæœ¬: ${stats.aiCompressionTokens} tokens<br>
                        ğŸ’° å‡€èŠ‚çœ: ${netSaved} tokens
                    `;

                    statsDiv.innerHTML = statsHtml;
                    statsSection.style.display = 'block';
                } else if (this.enableCompression) {
                    statsDiv.innerHTML = `
                        ğŸ¤– å‹ç¼©æ¨¡å¼: AIæ™ºèƒ½å‹ç¼©<br>
                        ğŸ“ å‹ç¼©å¼ºåº¦: ${(this.compressionRatio * 100).toFixed(0)}%<br>
                        ğŸ”’ ä¿æŠ¤æœ€è¿‘: ${this.keepRecentCount}æ¡æ¶ˆæ¯<br>
                        ğŸ“Š ç­‰å¾…å‹ç¼©æ•°æ®...
                    `;
                    statsSection.style.display = 'block';
                } else {
                    statsSection.style.display = 'none';
                }
            }

            // ====== Tabåˆ‡æ¢å’Œä»£ç†ç®¡ç†åŠŸèƒ½ ======

            /**
             * åˆ‡æ¢Tab
             * @param {string} tabId - Tab ID
             */
            switchTab(tabId) {
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-tab="${tabId}"]`).classList.add('active');

                // åˆ‡æ¢å†…å®¹æ˜¾ç¤º
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.style.display = 'none';
                });
                document.getElementById(tabId).style.display = 'block';

                this.currentTab = tabId;

                // å¦‚æœåˆ‡æ¢åˆ°ä»£ç†é…ç½®é¡µé¢ï¼Œåˆ·æ–°ä»£ç†åˆ—è¡¨
                if (tabId === 'proxy-config') {
                    this.renderProxyList();
                }
            }

            /**
             * ç”Ÿæˆå”¯ä¸€ID
             * @returns {string} å”¯ä¸€ID
             */
            generateId() {
                return 'proxy_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);
            }

            /**
             * æ·»åŠ æ–°ä»£ç†
             */
            addNewProxy() {
                const newProxy = {
                    id: this.generateId(),
                    name: 'æ–°ä»£ç†',
                    endpoint: 'openai',
                    apiUrl: 'https://xxx.com',
                    apiKey: 'sk-xxx',
                    modelName: 'gpt-4'
                };

                this.proxies.set(newProxy.id, newProxy);
                this.renderProxyList();
                this.updateProxySelectors(); // æ·»åŠ åæ›´æ–°é€‰æ‹©å™¨
            }

            /**
             * æ¸²æŸ“ä»£ç†åˆ—è¡¨
             */
            renderProxyList() {
                const container = this.elements.proxyListContainer;

                if (this.proxies.size === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; color: #666; padding: 30px;">
                            <p>æš‚æ— ä»£ç†é…ç½®</p>
                            <p style="font-size: 12px;">ç‚¹å‡»"æ–°å¢ä»£ç†"æŒ‰é’®æ·»åŠ ç¬¬ä¸€ä¸ªä»£ç†é…ç½®</p>
                        </div>
                    `;
                    return;
                }

                // å°†Mapè½¬æ¢ä¸ºæ•°ç»„å¹¶æŒ‰åˆ›å»ºæ—¶é—´å€’åºæ’åˆ—ï¼ˆæ–°çš„åœ¨å‰ï¼‰
                const proxiesArray = Array.from(this.proxies.entries()).reverse();

                let html = '';
                for (const [id, proxy] of proxiesArray) {
                    html += this.createProxyItemHTML(proxy);
                }

                container.innerHTML = html;

                // æ·»åŠ äº‹ä»¶ç›‘å¬
                this.setupProxyItemListeners();
            }

            /**
             * åˆ›å»ºä»£ç†é…ç½®é¡¹HTML
             * @param {Object} proxy - ä»£ç†é…ç½®å¯¹è±¡
             * @returns {string} HTMLå­—ç¬¦ä¸²
             */
            createProxyItemHTML(proxy) {
                return `
                    <div class="proxy-item" data-proxy-id="${proxy.id}">
                        <div class="proxy-item-header">
                            <div class="proxy-item-title">${proxy.name}</div>
                            <div class="proxy-item-actions">
                                <button class="btn btn-danger btn-small proxy-delete" data-proxy-id="${proxy.id}">åˆ é™¤</button>
                            </div>
                        </div>

                        <div class="proxy-form-row">
                            <div class="form-group">
                                <label class="form-label">ä»£ç†åç§°</label>
                                <input type="text" class="form-input proxy-name" value="${proxy.name}" data-proxy-id="${proxy.id}">
                            </div>
                            <div class="form-group">
                                <label class="form-label">ç«¯ç‚¹ç±»å‹</label>
                                <select class="form-select proxy-endpoint" data-proxy-id="${proxy.id}">
                                    <option value="openai" ${proxy.endpoint === 'openai' ? 'selected' : ''}>OpenAI</option>
                                    <option value="gemini" ${proxy.endpoint === 'gemini' ? 'selected' : ''}>Gemini</option>
                                </select>
                            </div>
                        </div>

                        <div class="proxy-form-row">
                            <div class="form-group">
                                <label class="form-label">APIåœ°å€</label>
                                <input type="text" class="form-input proxy-apiurl" value="${proxy.apiUrl}" data-proxy-id="${proxy.id}">
                                <div class="api-hint">OpenAI: ç³»ç»Ÿä¼šè‡ªåŠ¨è¡¥å…¨ /v1/chat/completionsï¼Œå¦‚éœ€ä½¿ç”¨å®Œæ•´åœ°å€è¯·åœ¨æœ«å°¾åŠ #</div>
                            </div>
                        </div>

                        <div class="proxy-form-row">
                            <div class="form-group">
                                <label class="form-label">APIå¯†é’¥</label>
                                <input type="text" class="form-input proxy-apikey" value="${proxy.apiKey}" data-proxy-id="${proxy.id}">
                            </div>
                            <div class="form-group">
                                <label class="form-label">æ¨¡å‹åç§°</label>
                                <input type="text" class="form-input proxy-modelname" value="${proxy.modelName}" data-proxy-id="${proxy.id}">
                            </div>
                        </div>
                    </div>
                `;
            }

            /**
             * è®¾ç½®ä»£ç†é…ç½®é¡¹çš„äº‹ä»¶ç›‘å¬
             */
            setupProxyItemListeners() {
                // åˆ é™¤ä»£ç†
                document.querySelectorAll('.proxy-delete').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const proxyId = e.target.dataset.proxyId;
                        this.deleteProxy(proxyId);
                    });
                });

                // ç›‘å¬è¾“å…¥å˜åŒ–ï¼Œå®æ—¶æ›´æ–°æ•°æ®
                document.querySelectorAll('.proxy-name').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const proxyId = e.target.dataset.proxyId;
                        const proxy = this.proxies.get(proxyId);
                        if (proxy) {
                            proxy.name = e.target.value;
                            // æ›´æ–°æ ‡é¢˜æ˜¾ç¤º
                            const titleElement = e.target.closest('.proxy-item').querySelector('.proxy-item-title');
                            titleElement.textContent = e.target.value;
                        }
                    });
                });

                document.querySelectorAll('.proxy-endpoint').forEach(select => {
                    select.addEventListener('change', (e) => {
                        const proxyId = e.target.dataset.proxyId;
                        const proxy = this.proxies.get(proxyId);
                        if (proxy) {
                            proxy.endpoint = e.target.value;
                            // æ ¹æ®ç«¯ç‚¹ç±»å‹æ›´æ–°é»˜è®¤å€¼
                            this.updateProxyDefaults(proxyId, e.target.value);
                        }
                    });
                });

                document.querySelectorAll('.proxy-apiurl').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const proxyId = e.target.dataset.proxyId;
                        const proxy = this.proxies.get(proxyId);
                        if (proxy) {
                            proxy.apiUrl = e.target.value;
                        }
                    });
                });

                document.querySelectorAll('.proxy-apikey').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const proxyId = e.target.dataset.proxyId;
                        const proxy = this.proxies.get(proxyId);
                        if (proxy) {
                            proxy.apiKey = e.target.value;
                        }
                    });
                });

                document.querySelectorAll('.proxy-modelname').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const proxyId = e.target.dataset.proxyId;
                        const proxy = this.proxies.get(proxyId);
                        if (proxy) {
                            proxy.modelName = e.target.value;
                        }
                    });
                });
            }

            /**
             * åˆ é™¤ä»£ç†é…ç½®
             * @param {string} proxyId - ä»£ç†ID
             */
            deleteProxy(proxyId) {
                if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä»£ç†é…ç½®å—ï¼Ÿ')) {
                    this.proxies.delete(proxyId);
                    this.renderProxyList();
                    this.updateProxySelectors(); // åˆ é™¤åæ›´æ–°é€‰æ‹©å™¨
                }
            }

            /**
             * æ ¹æ®ç«¯ç‚¹ç±»å‹æ›´æ–°ä»£ç†çš„é»˜è®¤å€¼
             * @param {string} proxyId - ä»£ç†ID
             * @param {string} endpoint - ç«¯ç‚¹ç±»å‹
             */
            updateProxyDefaults(proxyId, endpoint) {
                const proxy = this.proxies.get(proxyId);
                if (!proxy) return;

                if (endpoint === 'openai') {
                    proxy.apiUrl = 'https://xxx.com';
                    proxy.apiKey = 'sk-xxx';
                    proxy.modelName = 'gpt-4';
                } else if (endpoint === 'gemini') {
                    proxy.apiUrl = 'https://generativelanguage.googleapis.com';
                    proxy.apiKey = 'akxxx';
                    proxy.modelName = 'gemini-2.5-pro';
                }

                // é‡æ–°æ¸²æŸ“ä»¥æ›´æ–°UI
                this.renderProxyList();
            }

            /**
             * ä¿å­˜ä»£ç†é…ç½®
             */
            saveProxyConfiguration() {
                const proxiesData = {};
                for (const [id, proxy] of this.proxies) {
                    proxiesData[id] = proxy;
                }

                localStorage.setItem('aiDialogueProxies', JSON.stringify(proxiesData));
                this.updateProxySelectors(); // ä¿å­˜åæ›´æ–°é€‰æ‹©å™¨
                this.showMessage('ä»£ç†é…ç½®å·²ä¿å­˜', 'success');
            }

            /**
             * åŠ è½½ä»£ç†é…ç½®
             */
            loadProxyConfiguration() {
                const saved = localStorage.getItem('aiDialogueProxies');
                if (saved) {
                    const proxiesData = JSON.parse(saved);
                    this.proxies.clear();

                    for (const [id, proxy] of Object.entries(proxiesData)) {
                        this.proxies.set(id, proxy);
                    }

                    console.log('å·²åŠ è½½ä»£ç†é…ç½®:', this.proxies.size, 'ä¸ªä»£ç†');
                }
            }

            // ====== é…ç½®å¯¼å…¥å¯¼å‡ºåŠŸèƒ½ ======

            /**
             * å¯¼å‡ºé…ç½®
             */
            exportConfiguration() {
                try {
                    // æ”¶é›†æ‰€æœ‰é…ç½®æ•°æ®
                    const exportData = {
                        version: '1.0',
                        timestamp: new Date().toISOString(),

                        // AIé…ç½®
                        aiConfig: JSON.parse(localStorage.getItem('aiDialogueConfig') || '{}'),

                        // ä»£ç†é…ç½®
                        proxies: {}
                    };

                    // å¯¼å‡ºä»£ç†é…ç½®
                    for (const [id, proxy] of this.proxies) {
                        exportData.proxies[id] = proxy;
                    }

                    // åˆ›å»ºä¸‹è½½æ–‡ä»¶
                    const dataStr = JSON.stringify(exportData, null, 2);
                    const blob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);

                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `ai_dialogue_config_${new Date().getTime()}.json`;
                    a.click();

                    URL.revokeObjectURL(url);
                    this.showMessage('é…ç½®å¯¼å‡ºæˆåŠŸ', 'success');
                } catch (error) {
                    console.error('å¯¼å‡ºé…ç½®å¤±è´¥:', error);
                    this.showMessage('é…ç½®å¯¼å‡ºå¤±è´¥: ' + error.message, 'error');
                }
            }

            /**
             * å¯¼å…¥é…ç½®
             * @param {Event} event - æ–‡ä»¶é€‰æ‹©äº‹ä»¶
             */
            importConfiguration(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importData = JSON.parse(e.target.result);

                        // éªŒè¯é…ç½®æ–‡ä»¶æ ¼å¼
                        if (!importData.version || !importData.aiConfig || !importData.proxies) {
                            throw new Error('é…ç½®æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®');
                        }

                        // ç¡®è®¤å¯¼å…¥
                        if (!confirm('å¯¼å…¥é…ç½®å°†è¦†ç›–å½“å‰æ‰€æœ‰é…ç½®ï¼Œç¡®å®šç»§ç»­å—ï¼Ÿ')) {
                            return;
                        }

                        // å¯¼å…¥AIé…ç½®
                        localStorage.setItem('aiDialogueConfig', JSON.stringify(importData.aiConfig));

                        // å¯¼å…¥ä»£ç†é…ç½®
                        this.proxies.clear();
                        for (const [id, proxy] of Object.entries(importData.proxies)) {
                            this.proxies.set(id, proxy);
                        }
                        localStorage.setItem('aiDialogueProxies', JSON.stringify(importData.proxies));

                        // é‡æ–°åŠ è½½é…ç½®åˆ°UI
                        this.loadConfiguration();
                        this.updateProxySelectors();
                        this.renderProxyList();

                        this.showMessage('é…ç½®å¯¼å…¥æˆåŠŸ', 'success');

                        // æ¸…ç©ºæ–‡ä»¶é€‰æ‹©å™¨
                        event.target.value = '';

                    } catch (error) {
                        console.error('å¯¼å…¥é…ç½®å¤±è´¥:', error);
                        this.showMessage('é…ç½®å¯¼å…¥å¤±è´¥: ' + error.message, 'error');
                        event.target.value = '';
                    }
                };

                reader.readAsText(file);
            }
        }

        // åˆå§‹åŒ–ç³»ç»Ÿ
        document.addEventListener('DOMContentLoaded', () => {
            new AIDialogueSystem();
        });
    </script>
</body>
</html>